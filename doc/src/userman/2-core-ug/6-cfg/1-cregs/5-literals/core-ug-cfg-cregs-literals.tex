
\subsubsection{LAC literals}
\label{sec:core-ug-cfg-cregs-literals}

LAC supports the following literal syntaxes for literals for each primitive
type.

\begin{itemize}

\item \texttt{boolean}: the literals for a \code{boolean} are \code{true}
and \code{false}.

\item \texttt{natural}: natural numbers can be represented in decimal,
hexadecimal by prefixing \texttt{0x}, octal by prefixing \texttt{0} and binary
by prefixing \texttt{0b}.

\item \texttt{bit}: the literals for a \code{bit} are \code{'1'} and
\code{'0'}.

\item \texttt{bitvec}: \code{bitvec} literals can be represented as a
binary string enclosed in double quotes, for instance \code{"0101"}. In
addition, hexadecimal notation is supported by prefixing an \code{X}, for
instance \code{X"DEADBEEF"}.

\item \texttt{unsigned}: \texttt{unsigned} literals can be represented in
the same way as \code{bitvec} literals by simply prefixing the literal with a
\code{U}. For instance, \code{U"0101"} and \code{UX"DEADBEEF"}.

\end{itemize}

\noindent Aggregate types can be assigned and initialized using an compound 
literal. The syntax is similar to VHDL aggregates.

\begin{lstlisting}[numbers=none, language=nothing]
some_aggregate = {
  <name>                        => <expression>,
  <name>{<array index literal>} => <expression>,
  <name>{others}                => <expression>,
  others                        => <expression>
};
\end{lstlisting}

\noindent Unlike in VHDL, 'others' can assign any kind of combination of types, 
as long as the expression can be coerced to each member type. For instance, the 
aggregate {others => 0} will initialize any aggregate which does not itself 
contain another aggregate to all zeros.

Aggregate literals can not be used anywhere in an expression like the other
kinds of literals. They can only be assigned directly to an object or used as an
initialization expression.
