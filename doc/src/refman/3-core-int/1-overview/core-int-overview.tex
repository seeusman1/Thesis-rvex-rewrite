
\clearpage
\section{Overview}
\label{sec:core-int-overview}

This section gives an overview of the structural hierarchy of the core, as
well as a VHDL entity and package file listing. The last section documents the
coding style employed within all \rvex{} core files.

\subsection{Architecture}
\label{sec:core-int-overview-diagram}

A block diagram of the rvex core is shown in 
Figure~\ref{fig:core-int-overview-diagram}. The abbreviations used are described 
in the next section. The same abbreviations are used in the code to mark the 
source and/or destination of a signal, as described in
Section~\ref{sec:core-int-overview-style}.

\begin{figure}[h!]
  \subimport{../../}{assets/rvex-block-diagram/rvex-block-diagram-linked.tex}
  \caption{Block diagram of the \rvex{} core.}
  \label{fig:core-int-overview-diagram}
\end{figure}

\subsection{File and abbreviation list}
\label{sec:core-int-overview-files}

This section lists all the core files and their functions. Files describing
entities also have their entity abbreviation listed. Abbreviations without a
corresponding file are also listed, at the bottom of the list.

\newcommand{\entity}[4]{
  \vspace{12pt} \noindent 
  \begin{minipage}{\textwidth}
    \textbf{#1} \tabto{6cm} \textbf{\code{#2}} \tabto{8cm} \code{#3} \\[6pt]
    #4
  \end{minipage}
}

\newcommand{\entitylbl}[4]{\hypertarget{entity:#2}{}\entity{#1}{#2}{#3}{#4}}

\entitylbl{\rvex{} processor}{rv}{core.vhd}{
This is the toplevel file for the \rvex{} processor.
}

\entity{External \rvex{} package}{-}{core_pkg.vhd}{
This package contains type definitions and constants relevant both in the core 
internally and for the external interface of the core. In particular, it 
contains the type specification for the \code{CFG} generic, and the 
\code{rvex_cfg} subprogram that should be used to construct or modify it.
}

\entity{Internal \rvex{} package}{-}{core_intIface_pkg.vhd}{
This package contains all type specifications, constants and subprograms that 
are relevant only to the core files and do not belong in a specific file. This 
file does not contain configuration constants, aside from the following 
constants related to simulation performance: \code{GEN_VHDL_SIM_INFO}, 
\code{SIM_FULL_GPREG_FILE} and \code{RVEX_UNDEF}. These constants are documented 
extensively in the code.
}

\entitylbl{Pipelanes}{pls}{core_pipelanes.vhd}{
This entity contains the datapaths for the processor. It also contains the 
reconfigurable routing logic used to couple or decouple lane groups.
}

\entitylbl{Pipelane}{pl}{core_pipelane.vhd}{
This entity contains the datapath for a single pipelane, capable of executing a 
single syllable. It instantiates the necessary functional units based on 
configuration and its index. The pipeline is described in a single behavioral 
process, in such a way that the timing can be modified by just changing 
constants. These constants may be found in \code{core_pipeline_pkg.vhd}. Assert 
statements are in place to check the configuration specified by 
\code{core_pipeline_pkg.vhd}.
}

\entity{Pipeline configuration}{-}{core_pipeline_pkg.vhd}{
This contains constants that define the timing and the number of stages of the 
pipeline. This file is generated by the configuration scripts. The template VHDL
file used is \code{core_pipeline_pkg.template.vhd}.
}

\entitylbl{Branch unit}{br}{core_branch.vhd}{
This entity determines the program counter for the next cycle and provides its 
pipelane with the capability of executing branch class syllables. There must be 
exactly one branch unit in each pipelane group, and only the branch unit in the 
highest indexed pipelane group is active when groups are coupled.
}

\entitylbl{Arithmetic logic unit}{alu}{core_alu.vhd}{
This entity contains the arithmetic unit for the \rvex{}. The ALU takes up to 
two 32-bit integer operands and one boolean operand as input, and outputs a 
32-bit integer and/or a boolean. Registers may be inserted in two places in the 
datapath, affecting the timing of the ALU. Insertion is controlled by 
\code{L_ALU1} and \code{L_ALU2}, defined in \code{core_pipeline_pkg.vhd}.
}

\entitylbl{Memory unit}{memu}{core_memu.vhd}{
This entity interfaces with the data memory port and control registers of the 
\rvex{}. When present, it provides its pipelane with the capability of executing 
memory class syllables. There must be exactly one memory unit in each pipelane 
group, and only the memory unit in the highest indexed pipelane group is active 
when groups are coupled.
}

\entitylbl{Multiply unit}{mulu}{core_mulu.vhd}{
This entity contains a 32x16 multiplier. When present, it provides its pipelane 
with the capability of executing multiply class syllables. The latency is 
configurable using the \code{L_MUL} constant in \code{core_pipeline_pkg.vhd}. 
Directives for the Xilinx synthesis tools are in place to have the tools 
automatically insert the pipeline registers in the appropriate places within the 
DSP core.
}

\entitylbl{Breakpoint unit}{brku}{core_brku.vhd}{
This entity matches the PC and memory access command against the up to four 
enabled hardware breakpoint registers, and generates debug traps if there is a 
match. It should only be instantiated in pipelanes that also have a memory 
unit.
}

\entity{Opcode package}{-}{core_opcode_pkg.vhd}{
This package defines the \code{OPCODE_TABLE} constant array, which maps the 
8-bit opcode portion of a syllable to its control signals and (dis)assembly 
information. The actual decoding table is generated by the configuration
scripts. The template VHDL file used is \code{core_opcode_pkg.template.vhd}.
}

\entity{Datapath ctrl. signal package}{-}{core_opcodeDatapath_pkg.vhd}{
This package defines sets of control signals defining how the functional units 
are to be connected to the register files and each other, for use in 
\code{core_opcode_pkg.vhd}.
}

\entity{ALU ctrl. signal package}{-}{core_opcodeAlu_pkg.vhd}{
This package defines the records needed for ALU instruction decoding in
\code{core_opcode_pkg.vhd}.
}

\entity{Mult. ctrl. signal package}{-}{core_opcodeMultiplier_pkg.vhd}{
This package defines the records needed for multiply instruction decoding in
\code{core_opcode_pkg.vhd}.
}

\entity{Mem. ctrl. signal package}{-}{core_opcodeMemory_pkg.vhd}{
This package defines the records needed for memory instruction decoding in
\code{core_opcode_pkg.vhd}.
}

\entity{Branch ctrl. signal package}{-}{core_opcodeBranch_pkg.vhd}{
This package defines the records needed for branch instruction decoding in
\code{core_opcode_pkg.vhd}.
}

\entity{(Dis)assembler package}{-}{core_asDisas_pkg.vhd}{
This package defines simulation/elaboration only subprograms that can perform 
basic assembly and disassembly, used for the core unit test runner and the 
simulation-only core state output signal.
}

\entitylbl{General purpose registers}{gpreg}{core_gpRegs.vhd}{
This entity instantiates the general purpose register file and associated 
forwarding logic. Two register file implementations are available, specified in 
\code{core_gpRegs_sim.vhd} and \code{core_gpRegs_mem.vhd}.
}

\entity{BRAM-based \code{gpreg} spec.}{-}{core_gpRegs_mem.vhd}{
This entity specifies the general purpose register file in such a way that block 
RAMs are inferred for the register contents. In order to provide simultaneous 
access to all read and write ports, the contents of the register file are 
duplicated for each read and write port pair. Fabric based registers are used to 
store which write port last wrote to each register. Because of the duplication, 
it is hard to trace the contents of the register file in simulation. Therefore, 
\code{core_gpRegs_sim.vhd} will be used for simulation instead, unless 
\code{SIM_FULL_GPREG_FILE} in \code{core_intIface_pkg.vhd} is set to 
\code{true}.
}

\entity{Behavioral \code{gpreg} spec.}{-}{core_gpRegs_sim.vhd}{
This entity specifies the general purpose register file behaviorally, in such a 
way that the register contents can be easily traced in simulation. However, it 
is not decently synthesizable.
}

\entitylbl{Forwarding logic}{fwd}{core_forward.vhd}{
This entity infers the priority encoder and muxes needed for forwarding. It is 
highly generic and customizable, allowing it to be used for both the general 
purpose register file as well as the branch register file and link register.
}

\entitylbl{Context-pipelane interface}{cxplif}{core_contextPipelaneIFace.vhd}{
This entity serves as a central reconfigurable routing matrix between all 
pipelanes, pipelane groups and contexts.
}

\entitylbl{Data memory switch}{dmsw}{core_dmemSwitch.vhd}{
This entity switches between forwarding data memory access requests to the 
external data memory port and the core control registers. It adds additional 
latency stages to the core control register read data signal when the memory 
latency (\code{L_MEM} in \code{core_pipeline_pkg.vhd}) is specified to be 
greater than one.
}

\entitylbl{Stop bit routing}{sbit}{core_stopBitRouting.vhd}{
This entity contains the logic needed to correctly disable lanes following the
first instruction with the stop bit set and route branch instructions to the
active branch unit lane. It also contains some routing for PC+1 generation.
While this entity is always instantiated, it is no-op, and thus effectively
optimized away, if stop bits support is disabled at design time.
}

\entitylbl{Long immediate routing}{limm}{core_limmRouting.vhd}{
This entity contains the inter-pipelane routing needed to support long immediate 
(\code{LIMMH}) instructions. It can be configured to support routing long 
immediate data between aligned pipelane pairs and/or from the previous pair by 
means of the \code{limmhFromNeighbor} and \code{limmhFromPreviousPair} members 
of the \code{CFG} generic. When \code{limmhFromNeighbor} is set, a \code{LIMMH} 
instruction in lane 0 can forward to lane 1, lane 1 can forward to lane 0, lane 
2 to 3, 3 to 2 and so on. When \code{limmhFromPreviousPair} is set, lane 0 can 
forward to lane 2, lane 1 to 3, 3 to 4 and so on. Registers are instantiated in 
this case when the generic binary bundle size (\code{genBundleSizeLog2} in 
\code{CFG}) is set to be larger than the size of a lane group to store the 
\code{LIMMH} data from the previous instruction when necessary.
}

\entitylbl{Trap routing}{trap}{core_trapRouting.vhd}{
This entity merges trap information from pipelanes together when they are 
coupled, and broadcasts the merged information back to the lanes for the 
invalidation logic.
}

\entity{Trap code package}{-}{core_trap_pkg.vhd}{
This package defines the \code{TRAP_TABLE} constant array, which maps an 8-bit 
trap cause code to its friendly name and control signals. Constants are also 
available for each trap cause, prefixed by \code{RVEX_TRAP_}. In general, the 
definitions in this package can be changed without breaking functionality, as 
long as existing traps are not removed. This file is generated by the 
configuration scripts. The template VHDL file used is 
\code{core_trap_pkg.template.vhd}.
}

\entitylbl{Instruction buffer}{ibuf}{core_instructionBuffer.vhd}{
This entity handles the misaligned bundle accesses needed for stop-bit enabled
cores. It does so by storing the previous fetch result and muxing the syllable
output to each lane between the current and previous fetch, based on the cache
line offset part of the program counter. It is not instantiated when stop-bit
support is not enabled at design time.
}

\entitylbl{Control registers}{creg}{core_ctrlRegs.vhd}{
This entity contains the bus logic needed to access the control register files
from the memory units and the debug bus, as well as accessing the general
purpose register files from the debug bus.
}

\entity{Ctrl. reg. map package}{-}{core_ctrlRegs_pkg.vhd}{
This package defines constants for all the control registers in VHDL,
fulfilling a similar purpose as \code{rvex.h} in C. This file is generated by
the configuration scripts. The template VHDL file used is
\code{core_ctrlRegs_pkg.template.vhd}.
}

\entity{Ctrl. reg. bus switch}{-}{core_ctrlRegs_busSwitch.vhd}{
This entity connects a single control register bus master to several slaves, 
switching based on the request address.
}

\entity{Ctrl. reg. context switch}{-}{core_ctrlRegs_contextLaneSwitch.vhd}{
This entity connects the control register busses from the memory units to the 
appropriate context-specific register bank, based on the current runtime 
configuration.
}

\entitylbl{Context register logic}{cxreg}{core_contextRegLogic.vhd}{
This entity defines the functionality of the context-specific control registers. 
This file is generated by the configuration scripts. The template VHDL file used
is \code{core_contextRegLogic.template.vhd}.
}

\entitylbl{Global register logic}{gbreg}{core_globalRegLogic.vhd}{
Similar to \code{core_contextRegLogic.vhd}, this entity defines the 
functionality of the global core control registers. The template VHDL file used
is \code{core_globalRegLogic.template.vhd}.
}

\entitylbl{Configuration control}{cfg}{core_cfgCtrl.vhd}{
This entity provides the runtime configuration control signals to the rest of 
the core and controls the timing for runtime reconfiguration.
}

\entity{Configuration decoder}{-}{core_cfgCtrl_decode.vhd}{
This entity error-checks and decodes the configuration words as presented by the 
core or the debug bus when they request reconfiguration.
}

\entitylbl{Trace unit}{trace}{core_trace.vhd}{
This optional unit (enabled through \code{CFG.traceEnable}) configurably selects 
and compresses trace information into a byte stream. While the byte stream is 
being written to the memory system or peripheral connected to the trace 
interface of the core, this unit ensures that the core is properly stalled.
}

\entity{Version information}{-}{core_version_pkg.vhd}{
This package defines the core version tag for placement in the control register
file. It is generated by the versioning system.
}

\entitylbl{Memory}{mem}{-}{
Abbreviation for the memory or cache connected to the \rvex{}.
}

\entitylbl{Instruction memory}{imem}{-}{
Abbreviation for the instruction memory or cache connected to the \rvex{}.
}

\entitylbl{Data memory}{dmem}{-}{
Abbreviation for the data memory or cache connected to the \rvex{}.
}

\entitylbl{Debug bus}{dbg}{-}{
Abbreviation for the debug bus connected to the \rvex{}.
}

\entitylbl{Run control}{rctrl}{-}{
Abbreviation for the entity or group of entities connected to the \rvex{} run 
control interface.
}

\entitylbl{Simulation}{sim}{-}{
Abbreviation for the behavioral VHDL simulator, used as destination for 
simulation-only debug output signals.
}

\entitylbl{Trace data sink}{trsink}{-}{
Abbreviation for the external system that the trace output data is sent to.
}

\subsection{Coding style}
\label{sec:core-int-overview-style}

All code within the \rvex{} packages is wrote using a consistent code style.
Special attention was paid to naming conventions, as VHDL easily becomes
confusing due to the large amount of signals and variables everywhere.

\begin{itemize}

\item All signals, entity names, package names and types use a combination of 
camelCase and underscores. Typically, underscores are used as a form of 
hierarchy separation, where the VHDL language does not otherwise allow it, and 
camelCase is used to indicate word boundaries within one level of hierarchy. For 
example, \code{core_ctrlRegs_bank} refers to a (register) bank for the control 
registers for the \rvex{} core.

\item Most signal names start with an underscore-terminated abbreviation, which
indicates the source and destination entity. This identifier contains two entity 
abbreviation codes separated by a \code{2}. The entity abbreviation codes are 
defined at the top of \code{core.vhd} and are also listed in the previous
section. Sometimes other abbreviations are used for signals local to one entity,
which should be clear from context.

\item All constant names are uppercase with underscores.

\item Labels typically use underscores only, to prevent conflicts between 
similarly named entities and signals.

\item Types use one of the following suffixes to indicate what kind of type they 
represent.
\begin{itemize}
    \item \code{_type}: scalar type.
    \item \code{_array}: array type.
    \item \code{_ptr}: access type for a scalar.
    \item \code{_array_ptr}: access type for an array.
\end{itemize}

\item Enties and packages have the same name as their filename; exactly one 
entity or package is defined per VHDL file. Package names end in \code{_pkg}. 
All \rvex{} core files start with \code{core_} to keep their names unique within 
the \code{rvex} package, which contains a number of supporting packages as well.

\item Entity descriptions must clearly document the function of every port and
generic that passes it by, \emph{especially} when the entity generates or uses
the signal (as opposed to just routing it). All hope of future generations
comprehending the code is lost when interfaces are not clear.

\item Ports should be grouped by function or route. The groups should be made
apparent in the entity descriptions using blocks so they're easy to spot.

\item Entity instantiation code should include the port group names.

\item If words cannot describe how the code works, ASCII art diagrams might. 
This may seem a bit silly, but the only way to maintain up-to-date documentation 
is by having the documentation right in the developer's face. A picture 
somewhere in some documentation folder simply will not do. This manual is 
already a stretch.
\item Indentation is accomplished using two spaces, tabs are not used.

\item The \code{:} symbol in declarations, and the \code{=>} symbol in case
statements, port maps and generic maps, is generally aligned to column 33 using
spaces for aesthetically pleasing code.

\item Comments must wrap at column 80 for easy readability. Code should also not 
be too wide, although the column 80 limit is not strictly adhered to.

\end{itemize}

