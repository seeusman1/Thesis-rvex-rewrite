\newcounter{TrapCounter}
\begin{itemize}
\setcounter{enumi}{-1}
\item \refstepcounter{TrapCounter} \label{trap:NONE} \trap{NONE} = 0x00
\\[6 pt]
Trap cause 0 is reserved to indicate normal operation. When an 
\insn{RFI} instruction is executed, the trap cause register (cause field in 
\creg{CCR}) will be reset to 0, so an external debug system can always determine 
what a program is doing, unless nested traps are utilized.

\setcounter{enumi}{0}
\item \refstepcounter{TrapCounter} \label{trap:INVALID_OP} \trap{INVALID_OP} = 0x01
\\[6 pt]
This trap is generated by hardware in the following conditions.

\begin{itemize}

\item An unknown opcode is encountered.

\item The stop bit was set such that the next bundle would start on an address
violating the minimum design-time configured bundle alignment.

\item A branch opcode is encountered in a pipelane that does not have an active
branch unit.

\item A memory opcode is encountered in a pipelane that is not design-time
configured to include a memory unit.

\item A multiplier opcode is encountered in a pipelane that is not design-time
configured to include a multiplier.

\end{itemize}

\noindent The trap argument is set to the lane index that caused the trap.

\setcounter{enumi}{1}
\item \refstepcounter{TrapCounter} \label{trap:MISALIGNED_BRANCH} \trap{MISALIGNED_BRANCH} = 0x02
\\[6 pt]
This trap is generated by hardware when a branch to a misaligned address is
requested. The trap argument is set to the branch target.

\setcounter{enumi}{2}
\item \refstepcounter{TrapCounter} \label{trap:FETCH_FAULT} \trap{FETCH_FAULT} = 0x03
\\[6 pt]
This trap is generated by hardware when an instruction fetch resulted in a bus
fault. The trap argument is unused; the program counter can be determined from
the trap point.

\setcounter{enumi}{3}
\item \refstepcounter{TrapCounter} \label{trap:MISALIGNED_ACCESS} \trap{MISALIGNED_ACCESS} = 0x04
\\[6 pt]
This trap is generated by hardware when a misaligned memory access was
requested. That is, a 32-bit word access was attempted with an address that is
not divisible by four, or a 16-bit word access was attempted with an odd
address. The trap argument is set to the requested memory address.

\setcounter{enumi}{4}
\item \refstepcounter{TrapCounter} \label{trap:DMEM_FAULT} \trap{DMEM_FAULT} = 0x05
\\[6 pt]
This trap is generated by hardware when a data memory access resulted in a bus
fault. The trap argument is set to the requested memory address.

\setcounter{enumi}{5}
\item \refstepcounter{TrapCounter} \label{trap:LIMMH_FAULT} \trap{LIMMH_FAULT} = 0x06
\\[6 pt]
This trap is generated by hardware under the following conditions.

\begin{itemize}

\item A \insn{LIMMH} instruction is trying to forward to a lane for which no
route is available in the core. Note that only the least significant bit of the
target lane is actually checked, though. In this case, the trap argument is the
index of the lane with the \insn{LIMMH} instruction.

\item Two \insn{LIMMH} instructions are trying to forward to the same lane. In
this case, the trap argument is the index of the target lane.

\item A \insn{LIMMH} instruction is attempting to forward to a syllable that
is not using an immediate. In this case, the trap argument is also the index of
the target lane.

\end{itemize}

\setcounter{enumi}{6}
\item \refstepcounter{TrapCounter} \label{trap:EXT_INTERRUPT} \trap{EXT_INTERRUPT} = 0x07
\\[6 pt]
This trap is generated by hardware when the external interrupt request line is
asserted while interrupts are enabled by means of the I flag in \creg{CCR}. When
the trap service routine is entered, the state of the external interrupt ID
signal is saved as the trap argument in \creg{TA}, and in the same cycle, the
interrupt is acknowledged. This ensures that the interrupt ID presented to the
trap service routine always matches the acknowledged interrupt.

There is a delay between the core registering that the external interrupt
request line is asserted and generating the trap, and the actual entering of the
trap service routine. This delay is due to the pipeline flush required to do
this, and is in the order of a couple cycles; compared to actually servicing a
trap this delay is negligible. However, if it is ever possible that an active
interrupt is disabled before it is acknowledged by the core, it is possible that
the core will enter the trap service routine due to an interrupt that was
disabled before it could be handled. In this case, the interrupt controller
should provide the core with an otherwise reserved interrupt ID indicating that
there was no interrupt. The trap service routine should handle this special
interrupt ID as no-operation.

\setcounter{enumi}{7}
\item \refstepcounter{TrapCounter} \label{trap:STOP} \trap{STOP} = 0x08
\\[6 pt]
This trap is generated by hardware in the instruction immediately following a
\insn{STOP} instruction. It is handled in a completely different way than the
other traps are; the hardware will not jump to \creg{TH} or \creg{PH}. Instead,
the D and B flags in \creg{DCR} are set, thus stopping execution, and the
program counter is set to the trap point. This allows an external debugging or
control system to resume processing after the stop trap by simply writing
a one to the R flag in \creg{DCR}.

\setcounter{enumi}{8}
\item \refstepcounter{TrapCounter} \label{trap:CONTEXT_SWITCH} \trap{CONTEXT_SWITCH} = 0x09
\\[6 pt]
This trap is generated by hardware when the contents of \creg{RSC} differ from
\creg{CSC} while this trap is enabled using the C flag in \creg{CCR}. The
intended use of this trap is to allow hardware context 0 to control software
context switching on the other hardware contexts. When used in this way, the
trap service routine for this trap should perform the following tasks.

\begin{itemize}
\item If \creg{CSC} $\neq$ -1, save the current context to the memory
identified by \creg{CSC}.
\item Set \creg{CSC} to \creg{RSC}.
\item Restore the software context identified by \creg{RSC} from memory.
\end{itemize}

The way in which \creg{RSC} and \creg{CSC} identify the software context to be
exchanged is up to the operating system code.

\setcounter{enumi}{247}
\item \refstepcounter{TrapCounter} \label{trap:SOFT_DEBUG_0} \trap{SOFT_DEBUG_0} = 0xF8
\vskip -10 pt\relax
\item \refstepcounter{TrapCounter} \label{trap:SOFT_DEBUG_1} \trap{SOFT_DEBUG_1} = 0xF9
\vskip -10 pt\relax
\item \refstepcounter{TrapCounter} \label{trap:SOFT_DEBUG_2} \trap{SOFT_DEBUG_2} = 0xFA
\\[6 pt]
These traps are never generated by hardware, but are intended to be used as soft
breakpoints using the \insn{TRAP} instruction. That is, the debug system may
override one of the syllables in a any bundle where a breakpoint is desired with
a \insn{TRAP} syllable. It may return control to the application by reverting
the \insn{TRAP} syllable back into the original syllable. If it is not the
intention of the debugger to disable the breakpoint, it may single step over
the instruction at the breakpoint, and then replace the \insn{TRAP} syllable.

Unlike the other undefined traps (which may be used as arbitrary software
traps), these traps behave like hardware debug traps. That is, they will be
handled by halting the core if the core is in external debug mode (i.e. the E
flag in \creg{DCR} is set). This means that an external debugger can also use
this system to support an arbitrary number of breakpoints.

Likewise, disabling breakpoints using the B flag in \creg{CCR} will prevent even
the \insn{TRAP} instruction from actually generating a trap.

\setcounter{enumi}{250}
\item \refstepcounter{TrapCounter} \label{trap:STEP_COMPLETE} \trap{STEP_COMPLETE} = 0xFB
\\[6 pt]
This trap is generated by hardware whenever the S flag in \creg{DCR} is set
while debug traps are enabled. This allows the debug system to single-step.
Refer to the documentation of \creg{DCR} for more information.

\setcounter{enumi}{251}
\item \refstepcounter{TrapCounter} \label{trap:HW_BREAKPOINT_0} \trap{HW_BREAKPOINT_0} = 0xFC
\vskip -10 pt\relax
\item \refstepcounter{TrapCounter} \label{trap:HW_BREAKPOINT_1} \trap{HW_BREAKPOINT_1} = 0xFD
\vskip -10 pt\relax
\item \refstepcounter{TrapCounter} \label{trap:HW_BREAKPOINT_2} \trap{HW_BREAKPOINT_2} = 0xFE
\vskip -10 pt\relax
\item \refstepcounter{TrapCounter} \label{trap:HW_BREAKPOINT_3} \trap{HW_BREAKPOINT_3} = 0xFF
\\[6 pt]
These traps are generated by hardware when the corresponding hardware breakpoint
or watchpoint is hit while debug traps are enabled.

\end{itemize}
