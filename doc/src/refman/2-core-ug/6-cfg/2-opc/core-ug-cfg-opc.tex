
\subsection{Instruction set}
\label{sec:core-ug-cfg-opc}

The instruction set configuration files reside in the \code{config/opcodes}
directory of the \rvex{} repository. The configuration consists of a set of
LaTeX-styled files, interpreted ordered alphabetically by their filenames,
and a single key-value configuration file (\code{encoding.ini}), containing
miscellaneous information for the instruction decoder. The complete
configuration controls roughly the following things.

\begin{itemize}

\item The opcode for each syllable.

\item The functionality of each syllable, by means of specifying the control
      signals. The functional units themselves are \emph{not} controlled by this
      configuration.
      
\item The assembly syntax for each syllable. \todo{rvex-opc.c is not currently
      generated by the configuration system, so the assembly syntax of the
      actual toolchain may not be in sync.}
      
\item Documentation for each syllable, as it appears in
      Section~\ref{sec:core-ug-isa-insn-set}.

\item The encoding of the branch offset field.

\end{itemize}

\noindent The next section describes the structure of the LaTeX-style
configuration files, and the subsequent section provides a command reference.
The last section describes the key-value configuration file.


\subsubsection[.tex file structure]{\texttt{.tex} file structure}
\label{sec:core-ug-cfg-opc-struct}

Every description of a syllable/opcode starts with a \code{\syllable} command. 
Any unrecognized commands or textual lines following a \code{\syllable} command 
are considered to be LaTeX documentation for the syllable. To provide structure 
among the many instructions, \code{\section} commands are used to group 
syllables. There is only one level of hierarchy this way (i.e. there is no 
\code{\subsection} etc.), and it must be used. That is, \code{\syllable} 
commands before the first \code{\section} command are illegal. Any unrecognized 
command or text between a \code{\section} and \code{\syllable} command is 
considered to be LaTeX documentation for the syllable group.

All commands other than \code{\section} and \code{\syllable} specify attributes 
for the syllables. These are used to describe the characteristics and 
functionality of the instructions. These may be placed anywhere in the
configuration files; their position relative to the \code{\section} and
\code{\syllable} commands determine to which syllables they apply.

\begin{itemize}

\item Attribute commands placed before the first \code{\section} commands apply
      to all syllables. They can be thought of as being the default attributes.
      All syllable attributes \emph{must} have a default value.
      
\item Attribute commands placed between a \code{\section} and \code{\syllable}
      command apply to all syllables in the group, overriding the global
      defaults.

\item Attribute commands placed after a \code{\syllable} command apply to that
      syllable, overriding the global and group defaults.

\end{itemize}


\subsubsection[.tex command reference]{\texttt{.tex} command reference}
\label{sec:core-ug-cfg-opc-cref}

The following LaTeX-like commands are interpreted by the Python scripts to 
define the instruction set. They must be the only thing on a certain line aside 
from optional LaTeX-style comments at the end of the line, otherwise they are 
interpreted as part of a documentation section.

\vskip 6 pt
\codehead{\section{<name>}}

\noindent This command starts a group of syllable definitions. \code{<name>} 
will appear as a section header in the documentation. Any unrecognized command 
or text between \code{\section} and the first \code{\syllable} command is 
interpreted as LaTeX documentation for the group.

\vskip 6 pt
\codehead{\syllable{<opcode>}{<mnemonic>}{<syntax>}}

\noindent This command starts the definition of a syllable.

\begin{itemize}

\item \code{<opcode>} should be a 9-bit binary string, used by the hardware to 
      identify the syllable. Dashes may be used for don't cares. The 9 bits map
      to syllable bit 31..23. The value of the LSB is not really part of the
      opcode (the opcode field is only 8 bits wide), but defines whether the
      instruction can be used with only a register for the second operand (0),
      only an immediate for the second operand (1), or both (-). This bit is
      referred to as the \code{imm_sw} (immediate switch) bit.

\item \code{<mnemonic>} is the name of the syllable. It will be made lowercase
      for the assembler syntax and uppercase for the documentation.
   
\item \code{<syntax>} describes the assembler syntax of the syllable. In this, 
      the LaTeX-like commands from Table~\ref{tbl:core-ug-cfg-opc-cref-asm-macros}
      may be used inline. The \code{{}} may be omitted here.

\end{itemize}

\noindent Any textual lines between \code{\syllable} and \code{\section} or the 
next \code{\syllable} is interpreted as LaTeX documentation for the syllable. 
These text sections may also use the inline commands from 
Table~\ref{tbl:core-ug-cfg-opc-cref-asm-macros}, but here the \code{{}} may 
\emph{not} be omitted.

\begin{table}[h]
\centering
\caption{Mapping commands from assembly syntax to instruction encoding.}
\label{tbl:core-ug-cfg-opc-cref-asm-macros}
\footnotesize\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Command} & \textbf{In docs.} & \textbf{Description} & \textbf{Encoding} & \textbf{Condition} \\
\hline
\texttt{\detokenize{\rd{}}} & \texttt{\$r0.d}   & Integer destination register & Bit $22..17$ & -- \\
\hline
\texttt{\detokenize{\rx{}}} & \texttt{\$r0.x}   & Integer operand 1 register   & Bit $16..11$ & -- \\
\hline
\texttt{\detokenize{\ry{}}} & \texttt{\$r0.y}   & Integer operand 2 register   & Bit $10..5$  & \texttt{imm\_sw} = 0 \\
                            & \texttt{imm}      & Integer immediate            & Bit $10..2$  & \texttt{imm\_sw} = 1 \\
\hline
\texttt{\detokenize{\rs{}}} & \texttt{\$r0.1}   & Stack pointer                & --           & -- \\
\hline
\texttt{\detokenize{\bd{}}} & \texttt{\$r0.bd}  & Branch destination register  & Bit $19..17$ & \texttt{brFmt} = 0 \\
                            &                   &                              & Bit $4..2$   & \texttt{brFmt} = 1 \\
\hline
\texttt{\detokenize{\bs{}}} & \texttt{\$r0.bs}  & Branch operand register      & Bit $4..2$   & \texttt{brFmt} = 0 \\
                            &                   &                              & Bit $26..24$ & \texttt{brFmt} = 1 \\
\hline
\texttt{\detokenize{\lr{}}} & \texttt{\$l0.0}   & Link register                & --           & -- \\
\hline
\texttt{\detokenize{\of{}}} & \texttt{offs}     & Branch offset immediate      & Bit $23..5$  & -- \\
\hline
\texttt{\detokenize{\sa{}}} & \texttt{stackadj} & Stack adjustment immediate   & Bit $23..5$  & -- \\
\hline
\texttt{\detokenize{\lt{}}} & \texttt{tgt}      & Long immediate lane target   & Bit $27..25$ & -- \\
\hline
\texttt{\detokenize{\li{}}} & \texttt{imm}      & Long immediate               & Bit $24..2$  & -- \\
\hline
\end{tabular}\normalsize
\end{table}

\vskip 6 pt
\codehead{\class{<name>}}

\noindent This command specifies the resource class. \code{<name>} must be 
\code{ALU}, \code{MEM}, \code{MUL}, \code{BR} or \code{LIMMH}.

\vskip 6 pt
\codehead{\datapath{<key>}{<value>}}

\codehead{\alu{<key>}{<value>}}

\codehead{\branch{<key>}{<value>}}

\codehead{\memory{<key>}{<value>}}

\codehead{\multiplier{<key>}{<value>}}

\noindent These commands specify the control signals for the syllable. Which
keys and values are recognized depend on the VHDL code in
\code{core_opcode*_pkg.vhd}. They are documented in the comments of the code.
Note that the configuration scripts do \emph{not} perform error checking.
Instruction set configuration errors thus will not appear until the VHDL code is
compiled. Of course, if you are making changes here, you should test the core
anyway.

\vskip 6 pt
\codehead{\noasm{}}

\noindent This attribute specifies that this syllable cannot appear in 
user-written assembly code. This is the case for LIMMH instructions, which are 
inferred by the assembler.


\subsubsection[encoding.ini reference]{\texttt{encoding.ini} reference}
\label{sec:core-ug-cfg-opc-ini}

This file currently defines only a single value. It determines which encoding is 
used for the relative branch offset, and may be set to 2 or 3. When set to 3, 
the LSB of the branch offset has a weight of to 64 bits. When set to 2, the 
branch offset is shifted right by one bit, to allow branching to 32 bit 
boundaries. The syntax of the file is shown below.

\begin{lstlisting}[numbers=none, language=nothing]
[encoding]
branch_offset_shift = 3
\end{lstlisting}



