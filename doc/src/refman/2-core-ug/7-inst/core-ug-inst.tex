
\label{sec:core-ug-inst}

This section describes how the core should be instantiated, what the function of
all the external signals are, and how the core may be design-time configured. It
is intended for HDL designers who wish to incorporate the bare-metal core into
their design. \todo{Refer to some place that designers can turn to if they want
to instantiate higher-level \rvex{} core blocks, such as the cached core.}

\subsection{Data types}
\label{sec:core-ug-inst-types}

The following basic VHDL data types are used for the ports and generics. They
are defined in \code{common_pkg}.

\begin{lstlisting}[numbers=none]
subtype rvex_address_type     is std_logic_vector(31 downto  0);
subtype rvex_data_type        is std_logic_vector(31 downto  0);
subtype rvex_mask_type        is std_logic_vector( 3 downto  0);
subtype rvex_syllable_type    is std_logic_vector(31 downto  0);
subtype rvex_byte_type        is std_logic_vector( 7 downto  0);

type rvex_address_array       is array (natural range <>) of rvex_address_type;
type rvex_data_array          is array (natural range <>) of rvex_data_type;
type rvex_mask_array          is array (natural range <>) of rvex_mask_type;
type rvex_syllable_array      is array (natural range <>) of rvex_syllable_type;
type rvex_byte_array          is array (natural range <>) of rvex_byte_type;
\end{lstlisting}

\noindent The \code{address}, \code{data} and \code{syllable} types all 
represent 32-bit words. The distinction is made only for clarity; one can not 
simply give the \rvex{} processor 64-bit address map by widening the address 
type.

The \code{mask} type is used for byte-masking the data vectors for bus
operations. As all memory operations operate on 32-bit words, the \code{mask}
type has four bits to mask each byte. The most significant bit of the these
masks maps to the most significant byte of the 32-bit word, and thus to the
lowest byte address, as the \rvex{} system is big endian.

The \code{byte} type should be self-explanatory.

\subsection{Instantiation template}
\label{sec:core-ug-inst-template}

The following listing serves as an instantiation template for the core. The code
is documented in the following sections.

If you get errors when instantiating the core with this template, the
documentation might be out of date. Fear not, for the signals are also
documented in the entity description in \code{core.vhdl}.

\begin{lstlisting}[numbers=none, basicstyle=\tiny]
library rvex;
use rvex.common_pkg.all;
use rvex.core_pkg.all;

-- ...

rvex_inst: entity rvex.core
  generic map (
    
    -- Core configuration.
    CFG => rvex_cfg(
      numLanesLog2              => 3,
      numLaneGroupsLog2         => 2,
      numContextsLog2           => 2
      -- ...
    ),
    CORE_ID                     => CORE_ID,
    PLATFORM_TAG                => PLATFORM_TAG
    
  )
  port map (
    
    -- System control.
    reset                       => reset,
    resetOut                    => resetOut,
    clk                         => clk,
    clkEn                       => clkEn,
    
    -- Run control interface.
    rctrl2rv_irq                => rctrl2rv_irq,
    rctrl2rv_irqID              => rctrl2rv_irqID,
    rv2rctrl_irqAck             => rv2rctrl_irqAck,
    rctrl2rv_run                => rctrl2rv_run,
    rv2rctrl_idle               => rv2rctrl_idle,
    rctrl2rv_reset              => rctrl2rv_reset,
    rctrl2rv_resetVect          => rctrl2rv_resetVect,
    rv2rctrl_done               => rv2rctrl_done,
    
    -- Common memory interface.
    rv2mem_decouple             => rv2mem_decouple,
    mem2rv_blockReconfig        => mem2rv_blockReconfig,
    mem2rv_stallIn              => mem2rv_stallIn,
    rv2mem_stallOut             => rv2mem_stallOut,
    mem2rv_cacheStatus          => mem2rv_cacheStatus,
    
    -- Instruction memory interface.
    rv2imem_PCs                 => rv2imem_PCs,
    rv2imem_fetch               => rv2imem_fetch,
    rv2imem_cancel              => rv2imem_cancel,
    imem2rv_instr               => imem2rv_instr,
    imem2rv_affinity            => imem2rv_affinity,
    imem2rv_busFault            => imem2rv_busFault,
    
    -- Data memory interface.
    rv2dmem_addr                => rv2dmem_addr,
    rv2dmem_readEnable          => rv2dmem_readEnable,
    rv2dmem_writeData           => rv2dmem_writeData,
    rv2dmem_writeMask           => rv2dmem_writeMask,
    rv2dmem_writeEnable         => rv2dmem_writeEnable,
    dmem2rv_readData            => dmem2rv_readData,
    dmem2rv_ifaceFault          => dmem2rv_ifaceFault,
    dmem2rv_busFault            => dmem2rv_busFault,
    
    -- Control/debug bus interface.
    dbg2rv_addr                 => dbg2rv_addr,
    dbg2rv_readEnable           => dbg2rv_readEnable,
    dbg2rv_writeEnable          => dbg2rv_writeEnable,
    dbg2rv_writeMask            => dbg2rv_writeMask,
    dbg2rv_writeData            => dbg2rv_writeData,
    rv2dbg_readData             => rv2dbg_readData,
    
    -- Trace interface.
    rv2trsink_push              => rv2trsink_push,
    rv2trsink_data              => rv2trsink_data,
    rv2trsink_end               => rv2trsink_end,
    trsink2rv_busy              => trsink2rv_busy
    
  );

\end{lstlisting}

\subsection{Interface description}
\label{sec:core-ug-inst-iface}

As you can see in the template, the generics and signals are grouped by their 
function. The following subsections will document each group.

\subimport{iface/}{1-core-ug-cfg-inst-iface-generics}
\subimport{iface/}{2-core-ug-cfg-inst-iface-syscon}
\subimport{iface/}{3-core-ug-cfg-inst-iface-rctrl}
\subimport{iface/}{4-core-ug-cfg-inst-iface-cmem}
\subimport{iface/}{5-core-ug-cfg-inst-iface-imem}
\subimport{iface/}{6-core-ug-cfg-inst-iface-dmem}
\subimport{iface/}{7-core-ug-cfg-inst-iface-debug}
\subimport{iface/}{8-core-ug-cfg-inst-iface-trace}


