\documentclass[main.tex]{subfiles}

\begin{document}

\section{Instantiation and interface}

The following listing serves as an instantiation template for the core. The code is documented in the following sections.

\begin{lstlisting}[numbers=none]
library rvex;
use rvex.common_pkg.all;
use rvex.core_pkg.all;

-- ...

rvex_inst: entity rvex.core
  generic map (
    
    -- Core configuration.
    CFG => rvex_cfg(
      numLanesLog2              => 3,
      numLaneGroupsLog2         => 2,
      numContextsLog2           => 2
      -- ...
    )
    
  )
  port map (
    
    -- System control.
    reset                       => reset,
    clk                         => clk,
    clkEn                       => clkEn,
    
    -- Run control interface.
    rctrl2rv_irq                => rctrl2rv_irq,
    rctrl2rv_irqID              => rctrl2rv_irqID,
    rv2rctrl_irqAck             => rv2rctrl_irqAck,
    rctrl2rv_run                => rctrl2rv_run,
    rv2rctrl_idle               => rv2rctrl_idle,
    rctrl2rv_reset              => rctrl2rv_reset,
    rv2rctrl_done               => rv2rctrl_done,
    
    -- Common memory interface.
    rv2mem_decouple             => rv2mem_decouple,
    mem2rv_blockReconfig        => mem2rv_blockReconfig,
    mem2rv_stallIn              => mem2rv_stallIn,
    rv2mem_stallOut             => rv2mem_stallOut,
    
    -- Instruction memory interface.
    rv2imem_PCs                 => rv2imem_PCs,
    rv2imem_fetch               => rv2imem_fetch,
    rv2imem_cancel              => rv2imem_cancel,
    imem2rv_instr               => imem2rv_instr,
    imem2rv_affinity            => imem2rv_affinity,
    imem2rv_fault               => imem2rv_fault,
    
    -- Data memory interface.
    rv2dmem_addr                => rv2dmem_addr,
    rv2dmem_readEnable          => rv2dmem_readEnable,
    rv2dmem_writeData           => rv2dmem_writeData,
    rv2dmem_writeMask           => rv2dmem_writeMask,
    rv2dmem_writeEnable         => rv2dmem_writeEnable,
    dmem2rv_readData            => dmem2rv_readData,
    dmem2rv_fault               => dmem2rv_fault,
    
    -- Control/debug bus interface.
    dbg2rv_addr                 => dbg2rv_addr,
    dbg2rv_readEnable           => dbg2rv_readEnable,
    dbg2rv_writeEnable          => dbg2rv_writeEnable,
    dbg2rv_writeMask            => dbg2rv_writeMask,
    dbg2rv_writeData            => dbg2rv_writeData,
    rv2dbg_readData             => rv2dbg_readData
    
  );

\end{lstlisting}

\clearpage
\subsection{Configuration vector}

The \code{CFG} generic is used to configure the \rvex{} core. A function from the \code{core_pkg} package is used to generate this record in such a way that code instantiating the core will be forward compatible: because the parameters in the function are optional, parameters can be added without breaking old instantiation code.

The instantiation template does not list all the configuration parameters available. For an up-to-date list, refer to the comments in the \code{rvex_generic_config_type} type declaration in \code{core_pkg}.

\subsection{Signal types}

The following custom VHDL types are used in the interface signals. They are defined in \code{common_pkg}.

\begin{lstlisting}[numbers=none]
subtype rvex_address_type     is std_logic_vector(31 downto  0);
subtype rvex_data_type        is std_logic_vector(31 downto  0);
subtype rvex_mask_type        is std_logic_vector( 3 downto  0);
subtype rvex_syllable_type    is std_logic_vector(31 downto  0);

type rvex_address_array       is array (natural range <>) of rvex_address_type;
type rvex_data_array          is array (natural range <>) of rvex_data_type;
type rvex_mask_array          is array (natural range <>) of rvex_mask_type;
type rvex_syllable_array      is array (natural range <>) of rvex_syllable_type;
\end{lstlisting}

The \code{address}, \code{data} and \code{mask} types are used for the data bus interfaces, wherein \code{mask} is used for a per-byte write mask. The \code{syllable} types represent a syllable, i.e., an instruction word for a single lane.

\subsection{System control}

The system control signals include the clock source for the core, a synchronous reset signal and a global clock enable signal. \code{clk} and \code{reset} are required \code{std_logic} input signals. \code{clkEn} is an optional \code{std_logic} input signal.

The core is clocked on the rising edge of \code{clk} while \code{clkEn} is high. When a rising edge on \code{clk} occurs while \code{reset} is high, all resettable components of the core will be reset, regardless of the state of \code{clkEn}. Only block and distributed RAM resources are not reset, because this is not possible on Xilinx FPGAs without reconfiguration. In particular, this means that the general purpose registers are not reset to 0 by asserting \code{reset}, thus their contents should be considered to be undefined when a program starts. \code{r0.0} is an exception to this rule, as it is always zero.

\subsection{Run control}

The run control signals provide an interface between the core and an interrupt controller and/or host controller. All signals are optional. All signals are arrays of some sort, indexed by hardware context IDs in descending order.

\begin{itemize}

  \item \code{rctrl2rv_irq : in std_logic_vector(}\textit{number of contexts - 1}\code{ downto 0)}
  \item \code{rctrl2rv_irqID : in rvex_address_array(}\textit{number of contexts - 1}\code{ downto 0)}
  \item \code{rv2rctrl_irqAck : out std_logic_vector(}\textit{number of contexts - 1}\code{ downto 0)}
  
  When \code{rctrl2rv_irq} is high, an interrupt trap will be generated within the indexed context as soon as possible, if the interrupt enable flag in the context control register is set. Interrupt entry is acknowledged by \code{rv2rctrl_irqAck} being asserted high for one \code{clkEn}abled cycle. \code{rctrl2rv_irqID} is sampled in exactly that cycle and is made available to the trap handler through the trap argument register. When not specified, \code{rctrl2rv_irq} is tied to \code{'0'} and \code{rctrl2rv_irqID} is tied to \code{X"00000000"}.
  
  When \code{rv2rctrl_irqAck} is high, an interrupt controller would typically release \code{rctrl2rv_irq} and set \code{rctrl2rv_irqID} to a value signalling that no interrupt is active. Alternatively, if more interrupts are pending, \code{rctrl2rv_irq} may remain high and \code{rctrl2rv_irqID} may be set to the code identifying the next interrupt.
  
  Releasing \code{rctrl2rv_irq} while \code{rv2rctrl_irqAck} is \textit{not} high may lead to unexpected behavior. Because it takes time for traps to propagate through the pipeline, interrupt traps are issued before they are acknowledged, after which they cannot be stopped anymore. Therefore, the core might acknowledge an interrupt which was recently cleared while interrupts are enabled, and enter the trap handler accordingly.
  
  Acknowledging the interrupt and registering the ID when the trap is issued is not a viable option, because the trap might theoretically be overruled by a regular trap issued by a previous instruction in a later pipeline stage, in which case it would be possible for interrupts to be lost. The stage in which interrupt traps are issued is defined by the stage in which the application can update the interrupt enable flag.
  
  This behavior may be handled by defining a certain interrupt ID as a cleared interrupt, which is serviced by the trap handler as no operation. In addition, the behavior may be prevented altogether by only clearing interrupts while interrupts are disabled.
  
  \vspace{1em}
  \item \code{rctrl2rv_run : in std_logic_vector(}\textit{number of contexts - 1}\code{ downto 0)}
  \item \code{rv2rctrl_idle : out std_logic_vector(}\textit{number of contexts - 1}\code{ downto 0)}
  
  When \code{rctrl2rv_run} is asserted low, the indexed context will stop executing instructions as soon as possible. It will finish instructions which were already in the pipeline and have already committed data, and set the program counter to point to the next instruction which should be issued for the program to be resumed correctly. When the context has finished pausing, \code{rv2rctrl_idle} will be asserted high. This may also happen while \code{rctrl2rv_run} is low, when the core is being halted for a different reason (for example, to prepare for reconfiguration, because a context is not configured to run, etc.).
  
  When \code{rctrl2rv_run} is not specified, it is tied to \code{'1'}.
  
  Note that per this definition of idle, a context is not necessarily idle when it is stalled, because instructions may still be pending completion in the pipeline.
  
  \vspace{1em}
  \item \code{rctrl2rv_reset : in std_logic_vector(}\textit{number of contexts - 1}\code{ downto 0)}
  \item \code{rv2rctrl_done : out std_logic_vector(}\textit{number of contexts - 1}\code{ downto 0)}
  
  When \code{rctrl2rv_reset} is asserted, the context control registers for the indexed context are synchronously reset in the next \code{clkEn}abled cycle. When it is not specified, it is tied to \code{'0'}. \code{rv2rctrl_done} will be asserted high when a \code{stop} instruction is encountered.
  
  When the \rvex{} is running as a co-processor, \code{rctrl2rv_reset} could be used as an active low flag indicating that the currently loaded kernel needs to be executed, in which case \code{rv2rctrl_done} signals completion.
  
\end{itemize}

\subsection{Common memory interface}

These control signals are common to both the data and instruction memory interface.

\begin{itemize}
  
  \item \code{rv2mem_decouple : out std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  This vector represents the current runtime configuration of the core. In particular, it specifies which lane groups are working together to execute code within a single context. When a bit in this vector is high, the indexed lane group is ``decoupled'' from the next lane group, i.e., is operating within a different context. When a bit is low, the indexed lane group is working as a slave to the next higher indexed lane group for which the bit is set.
  
  Due to constraints in the core, the indices of pipelane groups working together are always aligned to the number of pipelane groups in the group. As an example, if pipelane groups 0 and 1 are working together, group 2 cannot join them without group 3 also joining them. This allows binary tree structures to be used in the coupling logic. This means that, in the default core configuration, only the following decouple vectors are legal: \code{"1111"}, \code{"1110"}, \code{"1011"}, \code{"1010"} and \code{"1000"}.
  
  The state of the \code{rv2mem_decouple} signal has several implications on the behavior of the memory ports on the \rvex{}.
  
  \begin{itemize}
    
    \item The data memory ports associated with lane groups for which the \code{rv2mem_decouple} signal is low will not make requests, and may thus be ignored if this is favourable for the memory implementation.
    
    \item The PCs presented by the instruction memory ports will always be contiguous and aligned for groups which are working together. The fetch and cancel signals will always be identical.
    
  \end{itemize}
  
  In addition, the \rvex{} assumes that the \code{mem2rv_blockReconfig} and \code{mem2rv_stallIn} signals are identical for coupled pipelane groups. Undefined behavior will result if these assumptions are violated.
  
  \vspace{1em}
  \item \code{mem2rv_blockReconfig : in std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  This signal can be used by the memories to block reconfiguration due to ongoing operations. When a bit in this vector is high, the indexed group will not split up or merge with other groups. The \rvex{} will assume that the associated bits in the \code{mem2rv_blockReconfig} signal will be released eventually when no operations are requested by those pipelane groups. When pipelane groups are coupled, their respective \code{mem2rv_blockReconfig} signals must be identical. When this signal is not specified, it is tied to all zeros.
  
  \vspace{1em}
  \item \code{mem2rv_stallIn : in std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}

  Stall input signals for each pipelane group. When the stall signal for a pipelane group is high, it will behave as if it is clock gated. When pipelane groups are coupled, their respective \code{mem2rv_stallIn} signals must be identical. When this signal is not specified, it is tied to all zeros.
  
  \vspace{1em}
  \item \code{rv2mem_stallOut : out std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Stall output signals for each pipelane group. This serves as a combined stall signal from all stall sources, indicating whether a pipelane group is actually stalled or not. When \code{rv2mem_stallOut} is high, all memory request signals from the associated pipelane group should be considered to be undefined. Memory access requests should thus be initiated (and registered) only at the rising edge of the \code{clk} signal when \code{clkEn} is high and the associated \code{rv2mem_stallOut} signal is low.
  
  When pipelane groups are coupled, their respective \code{rv2mem_stallOut} signals will be equal. In addition, the \code{unifiedStall} configuration parameter in the \code{CFG} record may be set to \code{true} to enforce equal stall signals for all pipelane groups at all times, should this be desirable for the memory implementation.

\end{itemize}

\subsection{Instruction memory interface}

These signals interface between the \rvex{} and the instruction memory or cache. All signals in this section are clock gated by not only \code{clkEn}, but also by the respective signal in \code{rv2mem_stallOut}. They should be considered to be invalid when the respective \code{rv2mem_stallOut} signal is high. The number of enabled clock cycles after which the reply for a request is assumed to be valid is defined by \code{L_IF}, which is defined in \code{core_pipeline_pkg}. \code{L_IF} defaults to 1.

\begin{itemize}

  \item \code{rv2imem_PCs : out rvex_address_array(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Program counter outputs for each lane group. These will always be aligned to the size of an instruction for a full lane group. When lane groups are coupled, the PC for the first lane group will always be aligned to the size of the instruction to be executed on the set of lane groups, and the PCs for those lang groups will be contiguous.
  
  \vspace{1em}
  \item \code{rv2imem_fetch : out std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Read enable output. When high, the instruction memory should supply the instructions pointed to by \code{rv2imem_PCs} on \code{imem2rv_instr} after \code{L_IF} processor cycles. \code{L_IF} is set in \code{core_pipeline_pkg.vhd} and defaults to 1.
  
  \vspace{1em}
  \item \code{rv2imem_cancel : out std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Cancel signal. This signal will go high combinatorially (regardless of the stall input from the memory) when it has been determined that the instruction requested for this cycle will not be used. In this case, the memory may cancel the request in order to be able to release the stall signal earlier. This signal can safely be ignored for correct operation.
  
  \vspace{1em}
  \item \code{imem2rv_instr : in rvex_syllable_array(}\textit{number of} lanes \textit{- 1}\code{ downto 0)}
  
  Syllable input for each lane. Expected to be valid \code{L_IF} processor cycles after \code{rv2imem_fetch} is asserted if \code{rv2imem_cancel} and \code{imem2rv_fault} are low.
  
  \vspace{1em}
  \item \code{imem2rv_affinity : in std_logic_vector(}\textit{n} log(\textit{n}) \textit{- 1}\code{ downto 0)}\\
  \textit{Where n = number of lane groups}
  
  Optional block affinity input signal for reconfigurable caches. If used, it is expected to have the same timing as the \code{imem2rv_instr} signal. Each lane group has log(\textit{number of lane groups}) bits in this signal, forming an unsigned integer which indexes the lane group which serviced the instruction read. When the processor wants to reconfigure, it may use this signal as a hint to determine which program should be placed on which lane group next, assuming that there will be fewer cache misses if the currently running application is mapped to the lane group indexed by the affinity signal.
  
  \vspace{1em}
  \item \code{imem2rv_fault : in std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Instruction fetch fault input signal. Expected to have the same timing as the \code{imem2rv_instr} signal. When high, an instruction fetch trap is generated and the instruction defined by \code{imem2rv_instr} will not be executed.
  
\end{itemize}

\subsection{Data memory interface}

These signals interface between the \rvex{} and the data memory or cache. All signals in this section are clock gated by not only \code{clkEn}, but also by the respective signal in \code{rv2mem_stallOut}. They should be considered to be invalid when the respective \code{rv2mem_stallOut} signal is high. The number of enabled clock cycles after which the reply for a request is assumed to be valid is defined by \code{L_MEM}, which is defined in \code{core_pipeline_pkg}. \code{L_MEM} defaults to 1.

\begin{itemize}
  
  \item \code{rv2dmem_addr : out rvex_address_array(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Memory address which is to be accessed if \code{rv2dmem_readEnable} or \code{rv2dmem_writeEnable} is high. The two least significant bits of the address will always be \code{"00"} and may be ignored. Note that a configurable 128 byte block within this 4 GiB memory space is inaccessible, because it is replaced by the core control registers. This is configurable through the \code{cregStartAddress} entry in \code{CFG}, which defaults to 0xFFFFFF80, meaning that 0xFFFFFF80..0xFFFFFFFF is inaccessible.
  
  \vspace{1em}
  \item \code{rv2dmem_readEnable : out std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Active high read enable signal from the core for each memory unit. This signal will never be asserted when the respective signal in \code{rv2mem_decouple} is low. When high during an enabled rising clock edge, the \rvex{} expects the access result to be valid \code{L_MEM} enabled cycles later.
  
  \vspace{1em}
  \item \code{rv2dmem_writeData : out rvex_data_array(}\textit{number of lane groups - 1}\code{ downto 0)}
  \item \code{rv2dmem_writeMask : out rvex_mask_array(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  These signals define the write operation to be performed when \code{rv2dmem_writeEnable} is high. \code{rv2dmem_writeMask} contains a bit for each byte in \code{rv2dmem_writeData}, which determines whether the byte should be written or not: when high, the respective byte should be written; when low, the byte should not be affected. Mask bit $i$ governs data bits $i*8+7$ downto $i*8$.

  \vspace{1em}
  \item \code{rv2dmem_writeEnable : out std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  Active high read enable signal from the core for each memory unit. This signal will never be asserted when the respective signal in \code{rv2mem_decouple} is low. When high during an enabled rising clock edge, the \rvex{} expects either that the write request defined by \code{rv2dmem_addr}, \code{rv2dmem_writeData} and \code{rv2dmem_writeMask} will be performed, or that \code{dmem2rv_fault} is asserted high \code{L_MEM} cycles later.

  \vspace{1em}
  \item \code{dmem2rv_readData : in rvex_data_array(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  This is expected to contain the read data for read requested by \code{rv2dmem_readEnable} and \code{rv2dmem_addr} \code{L_MEM} enabled cycles earlier, unless \code{dmem2rv_fault} is high, indicating that a bus fault occurred.

  \vspace{1em}
  \item \code{dmem2rv_fault : in std_logic_vector(}\textit{number of lane groups - 1}\code{ downto 0)}
  
  This is expected to be valid \code{L_MEM} enabled cycles after a read or write request. When high, this indicates that the read or write could not be performed for some reason. In this case, a \code{DMEM_FAULT} trap will be issued. The trap argument will be set to the address which was requested.
  
\end{itemize}

\subsection{Control/debug bus interface}

The debug bus provides an optional slave bus interface capable of accessing most of the registers within the core.

\begin{itemize}
  
  \item \code{dbg2rv_addr : in  rvex_address_type}
  \item \code{dbg2rv_readEnable : in std_logic}
  \item \code{dbg2rv_writeEnable : in std_logic}
  \item \code{dbg2rv_writeMask : in rvex_mask_type}
  \item \code{dbg2rv_writeData : in rvex_data_type}
  \item \code{rv2dbg_readData : out rvex_data_type}
  
  Debug interface bus. \code{dbg2rv_readEnable} and \code{dbg2rv_writeEnable} are active high and should not be active at the same time. \code{rv2dbg_readData} is valid one cycle after \code{dbg2rv_readEnable} is asserted and contains the data read from \code{dbg2rv_addr} as it was while \code{dbg2rv_readEnable} was asserted. \code{dbg2rv_writeMask}, \code{dbg2rv_writeData} and \code{dbg2rv_addr} define the write request when \code{dbg2rv_writeEnable} is asserted. All input signals are tied to \code{'0'} when not specified.
  
\end{itemize}

\end{document}
