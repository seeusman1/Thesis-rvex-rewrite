#include <vexasm.h>

typedef unsigned char uint8_t;

static void sim_putc(const char c) {
  *((volatile char*)(0xDEB00000)) = c;
}

static void sim_puts(const char *c) {
  while (*c) *((volatile char*)(0xDEB00000)) = *c++;
}

int abs(int a)
{
  if (a < 0)
    return -a;
  else
    return a;
}

static int x264_pixel_sad_16x16( uint8_t *pix1, int i_stride_pix1,
    uint8_t *pix2, int i_stride_pix2 )
{
  int i_sum = 0;
  int x, y;
  for( y = 0; y < 16; y++ )
  {
    sim_puts("y = ");
    sim_putc(((y < 10) ? '0' : ('A' - 10)) + y);
    sim_puts("\n");
    for( x = 0; x < 16; x++ )
    {
      i_sum += abs( pix1[x] - pix2[x] );
    }
    pix1 += i_stride_pix1;
    pix2 += i_stride_pix2;
  }
  return i_sum;
}

static void x264_pixel_sad_x4_16x16( uint8_t *fenc, uint8_t *pix0, uint8_t *pix1,
    uint8_t *pix2, uint8_t *pix3, int i_stride, int scores[4] )
{
  sim_puts("0%...\n");
  scores[0] = x264_pixel_sad_16x16( fenc, 16, pix0, i_stride );
  sim_puts("25%...\n");
  scores[1] = x264_pixel_sad_16x16( fenc, 16, pix1, i_stride );
  sim_puts("50%...\n");
  scores[2] = x264_pixel_sad_16x16( fenc, 16, pix2, i_stride );
  sim_puts("75%...\n");
  scores[3] = x264_pixel_sad_16x16( fenc, 16, pix3, i_stride );
  sim_puts("100%...\n");
}

uint8_t fenc[16*16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};

  uint8_t pix0[16*16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
int main(void)
{
  //uint8_t pix0[16*16];
  uint8_t pix1[16*16];
  uint8_t pix2[16*16];
  uint8_t pix3[16*16];
  int scores[4];
  int i_stride = 16;
  int i;

  x264_pixel_sad_x4_16x16(&fenc, &pix0, &pix1, &pix2, &pix3, i_stride, scores);
  
  if (scores[0] == 1920) {
    sim_puts("Computation 1 correct\n");
  } else {
    sim_puts("Computation 1 INCORRECT\n");
  }
  if (scores[1] == 1920) {
    sim_puts("Computation 2 correct\n");
  } else {
    sim_puts("Computation 2 INCORRECT\n");
  }
  if (scores[2] == 1920) {
    sim_puts("Computation 3 correct\n");
  } else {
    sim_puts("Computation 3 INCORRECT\n");
  }
  if (scores[3] == 1920) {
    sim_puts("Computation 4 correct\n");
  } else {
    sim_puts("Computation 4 INCORRECT\n");
  }

  return 1;
}
