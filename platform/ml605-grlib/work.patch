diff -rupN '--exclude=ram.srec' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/config.vhd work/config.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/config.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/config.vhd	2015-02-20 18:44:53.206526654 +0100
@@ -13,6 +13,15 @@
 library techmap;
 use techmap.gencomp.all;
 
+library ieee;
+use ieee.std_logic_1164.all;
+
+library rvex;
+use rvex.common_pkg.all;
+use rvex.core_pkg.all;
+use rvex.cache_pkg.all;
+use rvex.rvsys_grlib_pkg.all;
+
 package config is
 -- Technology and synthesis options
   constant CFG_FABTECH : integer := virtex6;
@@ -21,8 +30,8 @@ package config is
   constant CFG_NOASYNC : integer := 0;
   constant CFG_SCAN : integer := 0;
 -- LEON3 processor core
-  constant CFG_LEON3 : integer := 1;
-  constant CFG_NCPU : integer := (1);
+  constant CFG_LEON3 : integer := 0;
+  constant CFG_NLEON : integer := 0;
   constant CFG_NWIN : integer := (8);
   constant CFG_V8 : integer := 16#32# + 4*0;
   constant CFG_MAC : integer := 0;
@@ -61,7 +70,7 @@ package config is
   constant CFG_TLB_TYPE : integer := 1 + 0*2;
   constant CFG_TLB_REP : integer := 1;
   constant CFG_MMU_PAGE : integer := 0;
-  constant CFG_DSU : integer := 1;
+  constant CFG_DSU : integer := 0;
   constant CFG_ITBSZ : integer := 4;
   constant CFG_ATBSZ : integer := 4;
   constant CFG_LEON3FT_EN : integer := 0;
@@ -73,6 +82,27 @@ package config is
   constant CFG_LEON3_NETLIST: integer := 0;
   constant CFG_DISAS : integer := 0 + 0;
   constant CFG_PCLOW : integer := 2;
+-- r-VEX processor core
+  constant CFG_RVEX : integer := 1;
+  constant CFG_NRVEX : integer := 1;
+  constant CFG_RVEX_CFG : rvex_grlib_generic_config_type := rvex_grlib_cfg(
+    
+    -- Core configuration
+    core => rvex_cfg(
+      numLanesLog2        => 3,
+      numLaneGroupsLog2   => 2,
+      numContextsLog2     => 2
+    ), core_valid => true,
+    
+    -- Cache configuration
+    cache => cache_cfg(
+      instrCacheLinesLog2 => 8, -- 8 kiB
+      dataCacheLinesLog2  => 8  -- 1 KiB
+    ), cache_valid => true
+    
+  );
+-- Total number of processors
+  constant CFG_NCPU : integer := CFG_NLEON + CFG_NRVEX * 2**CFG_RVEX_CFG.core.numLaneGroupsLog2;
 -- AMBA settings
   constant CFG_DEFMST : integer := (0);
   constant CFG_RROBIN : integer := 1;
@@ -85,7 +115,8 @@ package config is
   constant CFG_AHB_MONWAR : integer := 0;
   constant CFG_AHB_DTRACE : integer := 0;
 -- DSU UART
-  constant CFG_AHB_UART : integer := 0;
+  constant CFG_AHB_UART : integer := 1;
+  constant CFG_AHB_UART_RVEX : integer := 1; -- Use rvex debug UART instead of grlib UART
 -- JTAG based DSU interface
   constant CFG_AHB_JTAG : integer := 1;
 -- Ethernet DSU
@@ -96,7 +127,7 @@ package config is
   constant CFG_ETH_ENM : integer := 16#020789#;
   constant CFG_ETH_ENL : integer := 16#000123#;
 -- LEON2 memory controller
-  constant CFG_MCTRL_LEON2 : integer := 1;
+  constant CFG_MCTRL_LEON2 : integer := 0;
   constant CFG_MCTRL_RAM8BIT : integer := 1;
   constant CFG_MCTRL_RAM16BIT : integer := 1;
   constant CFG_MCTRL_5CS : integer := 0;
@@ -123,7 +154,7 @@ package config is
   constant CFG_GRETH_FT : integer := 0;
   constant CFG_GRETH_EDCLFT : integer := 0;
 -- UART 1
-  constant CFG_UART1_ENABLE : integer := 1;
+  constant CFG_UART1_ENABLE : integer := 0;
   constant CFG_UART1_FIFO : integer := 8;
 -- LEON3 interrupt controller
   constant CFG_IRQ3_ENABLE : integer := 1;
@@ -163,5 +194,5 @@ package config is
   constant CFG_DUART : integer := 0;
 -- Xilinx MIG DDR2 controller
   constant CFG_MIG_DDR2 : integer := 1;
-  constant CFG_MIG_CLK4 : integer := 16;
+  constant CFG_MIG_CLK4 : integer := 32;
 end;
diff -rupN '--exclude=ram.srec' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.ucf work/leon3mp.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/leon3mp.ucf	2015-02-20 18:44:53.206526654 +0100
@@ -386,8 +386,8 @@ INST "ddr3ctrl/u_infrastructure/u_mmcm_a
 
 #NET  "heartbeat"                LOC = "AC24";   # ML605 GPIO LED 1
 #NET  "pll_lock"                 LOC = "AC22" ;  # ML605 GPIO LED 0
-
-
+
+
 NET "address(0)"                      LOC = "AL8";    ## 29 on U4, A1 on U27
 NET "address(1)"                      LOC = "AK8";    ## 25 on U4, B1 on U27
 NET "address(2)"                      LOC = "AC9";    ## 24 on U4, C1 on U27
@@ -435,7 +435,7 @@ NET "oen"                    LOC = "AA24
 NET "alatch"                 LOC = "AC23";   ##           H1 on U27
 NET "romsn"                    LOC = "Y24";    ## 30 on U4, B4 on U27 (U10 and switch S2.2 setting select either U4 or U27)
 ##
-
+
 NET "erx_col"                       LOC = "AK13";   ## 114 on U80
 NET "erx_crs"                       LOC = "AL13";   ## 115 on U80
 NET "emdint"                       LOC = "AH14";   ## 32  on U80
@@ -465,20 +465,20 @@ NET "etxd(5)"                      LOC =
 NET "etxd(6)"                      LOC = "AE11";   ## 28  on U80
 NET "etxd(7)"                      LOC = "AF11";   ## 29  on U80
 NET "etx_er"                      LOC = "AH10";   ## 13  on U80
-
+
 NET "dsurx"                      LOC = "J24";    ## 24  on U34
 NET "dsutx"                      LOC = "J25";    ## 25  on U34
-
+
 #NET "GPIO_DIP_SW1"                  LOC = "D22";    ## 1   on SW1 DIP switch (active-high)
 #NET "GPIO_DIP_SW2"                  LOC = "C22";    ## 2   on SW1 DIP switch (active-high)
 #NET "GPIO_DIP_SW3"                  LOC = "L21";    ## 3   on SW1 DIP switch (active-high)
 #NET "GPIO_DIP_SW4"                  LOC = "L20";    ## 4   on SW1 DIP switch (active-high)
 #NET "GPIO_DIP_SW5"                  LOC = "C18";    ## 5   on SW1 DIP switch (active-high)
-NET "dsubre"                  LOC = "B18";    ## 6   on SW1 DIP switch (active-high)
+#NET "dsubre"                  LOC = "B18";    ## 6   on SW1 DIP switch (active-high)
 #NET "GPIO_DIP_SW7"                  LOC = "K22";    ## 7   on SW1 DIP switch (active-high)
 #NET "GPIO_DIP_SW8"                  LOC = "K21";    ## 8   on SW1 DIP switch (active-high)
 ##
-
+
 NET "led(0)"                    LOC = "AC22";   ## 2   on LED DS12, 1 on J62
 NET "led(1)"                    LOC = "AC24";   ## 2   on LED DS11, 2 on J62
 NET "led(2)"                    LOC = "AE22";   ## 2   on LED DS9,  3 on J62
@@ -489,14 +489,14 @@ NET "led(5)"                    LOC = "A
 #NET "GPIO_LED_5"                    LOC = "AG23";   ## 2   on LED DS14, 6 on J62
 #NET "GPIO_LED_6"                    LOC = "AE24";   ## 2   on LED DS22, 7 on J62
 #NET "GPIO_LED_7"                    LOC = "AD24";   ## 2   on LED DS21, 8 on J62
-
+
 NET "dvi_iic_scl"                   LOC = "AN10";   ## 2   on Q5, 15 on U38
 NET "iic_scl_main"               LOC = "AK9";    ## 2   on Q19
 #NET "IIC_SCL_SFP"                   LOC = "AA34";   ## 2   on Q23
 NET "dvi_iic_sda"                   LOC = "AP10";   ## 2   on Q6, 14 on U38
 NET "iic_sda_main"               LOC = "AE9";    ## 2   on Q20
 #NET "IIC_SDA_SFP"                   LOC = "AA33";   ## 2   on Q21
-
+
 NET "tft_lcd_data(0)"                        LOC = "AJ19";   ## 63 on U38 (thru series R111 47.5 ohm)
 NET "tft_lcd_data(1)"                        LOC = "AH19";   ## 62 on U38 (thru series R110 47.5 ohm)
 NET "tft_lcd_data(2)"                        LOC = "AM17";   ## 61 on U38 (thru series R109 47.5 ohm)
@@ -516,7 +516,7 @@ NET "tft_lcd_reset_b"                LOC
 NET "tft_lcd_vsync"                         LOC = "AD15";   ## 5  on U38 (thru series R114 47.5 ohm)
 NET "tft_lcd_clk_n"                    LOC = "AC17";   ## 56 on U38
 NET "tft_lcd_clk_p"                    LOC = "AC18";   ## 57 on U38
-
+
 #NET "SYSACE_CFGTDI"                 LOC = "AC8";    ## 81  on U19
 NET "sysace_d(0)"                     LOC = "AM15";   ## 66  on U19
 NET "sysace_d(1)"                     LOC = "AJ17";   ## 65  on U19
@@ -539,52 +539,52 @@ NET "sysace_mpirq"                  LOC
 NET "sysace_mpoe"                   LOC = "AL15";   ## 77  on U19
 NET "sysace_mpwe"                   LOC = "AL14";   ## 76  on U19
 NET "clk_33"              LOC = "AE16";   ## 93  on U19
-NET "clk_33" PERIOD = 30.000 ;
-OFFSET = IN : 20.000 : BEFORE clk_33 ;
-OFFSET = OUT : 20.000 : AFTER clk_33 ;
-
-
-NET "clkm" 		TNM_NET = "clkm";
-NET "clk_ddr" 		TNM_NET = "clk_ddr";
-
-TIMESPEC "TS_clkm_clk_ddr" = FROM "clkm" TO "clk_ddr" TIG;
-TIMESPEC "TS_clk_ddr_clkm" = FROM "clk_ddr" TO "clkm" TIG;
-
-NET "erx_clk" PERIOD = 8.000 ;
-OFFSET = IN : 5.000 : BEFORE erx_clk ;
-#OFFSET = IN : 2.000 : BEFORE erx_clk ;
-
-NET "etx_clk" PERIOD = 40.000 ;
-OFFSET = OUT : 15.000 : AFTER etx_clk ;
-OFFSET = IN : 8.000 : BEFORE etx_clk ;
-
-NET "etx_clk" MAXSKEW= 1.0 ns;
-NET "erx_clk" MAXSKEW= 1.0 ns;
-
-#NET "egtx_clk" PERIOD = 8.000 ;
-#OFFSET = OUT : 5.500 : AFTER egtx_clk;
-#NET "egtx_clk" CLOCK_DEDICATED_ROUTE = FALSE;
-
-NET "gmiiclk_p"                 LOC = "H6";
-NET "gmiiclk_n"                 LOC = "H5";
-NET "gmiiclk_p" PERIOD = 8.000 ;
-OFFSET = OUT : 12.000 : AFTER gmiiclk_p;
-
-////////////////////////////////////////////////////////////////////////////
-// VGA clock
-////////////////////////////////////////////////////////////////////////////
-#NET "clkvga" TNM_NET = "clkvga" | PERIOD = 15.385;
-#TIMESPEC "TSPLB_TFT25" = FROM "clkm" TO "clkvga" TIG;
-#TIMESPEC "TSPLB_TFT40" = FROM "clkvga" TO "clkm" TIG;
-
-
-
-######################################################################################
-## MMCM_ADV CONSTRAINTS                                                             ##
-######################################################################################
-
-INST "uddr3ctrl/_infrastructure/u_mmcm_adv"      LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36
-
+NET "clk_33" PERIOD = 30.000 ;
+OFFSET = IN : 20.000 : BEFORE clk_33 ;
+OFFSET = OUT : 20.000 : AFTER clk_33 ;
+
+
+NET "clkm" 		TNM_NET = "clkm";
+NET "clk_ddr" 		TNM_NET = "clk_ddr";
+
+TIMESPEC "TS_clkm_clk_ddr" = FROM "clkm" TO "clk_ddr" TIG;
+TIMESPEC "TS_clk_ddr_clkm" = FROM "clk_ddr" TO "clkm" TIG;
+
+NET "erx_clk" PERIOD = 8.000 ;
+OFFSET = IN : 5.000 : BEFORE erx_clk ;
+#OFFSET = IN : 2.000 : BEFORE erx_clk ;
+
+NET "etx_clk" PERIOD = 40.000 ;
+OFFSET = OUT : 15.000 : AFTER etx_clk ;
+OFFSET = IN : 8.000 : BEFORE etx_clk ;
+
+NET "etx_clk" MAXSKEW= 1.0 ns;
+NET "erx_clk" MAXSKEW= 1.0 ns;
+
+#NET "egtx_clk" PERIOD = 8.000 ;
+#OFFSET = OUT : 5.500 : AFTER egtx_clk;
+#NET "egtx_clk" CLOCK_DEDICATED_ROUTE = FALSE;
+
+NET "gmiiclk_p"                 LOC = "H6";
+NET "gmiiclk_n"                 LOC = "H5";
+NET "gmiiclk_p" PERIOD = 8.000 ;
+OFFSET = OUT : 12.000 : AFTER gmiiclk_p;
+
+////////////////////////////////////////////////////////////////////////////
+// VGA clock
+////////////////////////////////////////////////////////////////////////////
+#NET "clkvga" TNM_NET = "clkvga" | PERIOD = 15.385;
+#TIMESPEC "TSPLB_TFT25" = FROM "clkm" TO "clkvga" TIG;
+#TIMESPEC "TSPLB_TFT40" = FROM "clkvga" TO "clkm" TIG;
+
+
+
+######################################################################################
+## MMCM_ADV CONSTRAINTS                                                             ##
+######################################################################################
+
+INST "uddr3ctrl/_infrastructure/u_mmcm_adv"      LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36
+
 # Constrain BUFR clocks used to synchronize data from IOB to fabric logic
 # Note that ISE cannot infer this from other PERIOD constraints because
 # of the use of OSERDES blocks in the BUFR clock generation path
@@ -610,4 +610,4 @@ TIMESPEC "TS_clk_rsync_rise_to_fall_xst"
 # Used only by the phy modules.
 #INST "u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
 #TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = 10 ns;  ## = "2.5ns * 4" ML605 single clock
-
+
diff -rupN '--exclude=ram.srec' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.vhd work/leon3mp.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/leon3mp.vhd	2015-02-20 19:19:04.017428390 +0100
@@ -49,6 +49,15 @@ use work.pcie.all;
 -- pragma translate_off
 use gaisler.sim.all;
 -- pragma translate_on
+library rvex;
+use rvex.common_pkg.all;
+use rvex.bus_pkg.all;
+use rvex.bus_addrConv_pkg.all;
+use rvex.core_pkg.all;
+use rvex.cache_pkg.all;
+use rvex.rvsys_grlib_pkg.all;
+library unisim;
+use unisim.vcomponents.all;
 
 entity leon3mp is
   generic (
@@ -67,12 +76,12 @@ entity leon3mp is
     clk_ref_n     : in    std_logic;
 
     -- PROM interface
-    address   : out   std_logic_vector(23 downto 0);
-    data      : inout std_logic_vector(15 downto 0);
-    romsn     : out   std_ulogic;
-    oen       : out   std_ulogic;
-    writen    : out   std_ulogic;
-    alatch    : out   std_ulogic;
+    address   : out   std_logic_vector(23 downto 0) := (others => '0');
+    data      : inout std_logic_vector(15 downto 0) := (others => 'Z');
+    romsn     : out   std_ulogic := '0';
+    oen       : out   std_ulogic := '0';
+    writen    : out   std_ulogic := '0';
+    alatch    : out   std_ulogic := '0';
 
     -- DDR3 memory
     ddr3_dq       : inout std_logic_vector(DQ_WIDTH-1 downto 0);
@@ -92,7 +101,9 @@ entity leon3mp is
     ddr3_ck_n     : out   std_logic_vector(CK_WIDTH-1 downto 0);
 
     -- Debug support unit
-    dsubre    : in    std_ulogic;       -- Debug Unit break (connect to button)
+    --dsubre    : in    std_ulogic;       -- Debug Unit break (connect to button)
+    -- Pin removed because we're not using the LEON DSU (much less the physical
+    -- switches) and it was giving I/O standard conflicts with the DD3 signals.
 
     -- AHB Uart
     dsurx     : in    std_ulogic;
@@ -150,7 +161,7 @@ entity leon3mp is
 
 
     -- Output signals to LEDs
-    led       : out   std_logic_vector(6 downto 0)
+    led       : out   std_logic_vector(6 downto 0) := (others => '0')
     );
 end;
 
@@ -179,8 +190,8 @@ architecture rtl of leon3mp is
   signal irqi : irq_in_vector(0 to CFG_NCPU-1);
   signal irqo : irq_out_vector(0 to CFG_NCPU-1);
 
-  signal dbgi : l3_debug_in_vector(0 to CFG_NCPU-1);
-  signal dbgo : l3_debug_out_vector(0 to CFG_NCPU-1);
+  signal dbgi : l3_debug_in_vector(0 to CFG_NLEON-1);
+  signal dbgo : l3_debug_out_vector(0 to CFG_NLEON-1);
 
   signal dsui : dsu_in_type;
   signal dsuo : dsu_out_type;
@@ -245,9 +256,18 @@ architecture rtl of leon3mp is
   constant VCO_FREQ  : integer := 1200000;                               -- MMCM VCO frequency in KHz
   constant CPU_FREQ   : integer := VCO_FREQ / CFG_MIG_CLK4;  -- cpu frequency in KHz
   constant I2C_FILTER : integer := (CPU_FREQ*5+50000)/100000+1;
-
+  
+  -- rvex bus master interface.
+  signal rvbmo  : bus_mst2slv_type;
+  signal rvbmi  : bus_slv2mst_type;
+  
+  -- rvex bus slave interfaces.
+  constant N_RVB_SLAVES : integer := CFG_NRVEX + CFG_AHB_UART*CFG_AHB_UART_RVEX;
+  signal rvbsi  : bus_mst2slv_array(0 to N_RVB_SLAVES - 1);
+  signal rvbso  : bus_slv2mst_array(0 to N_RVB_SLAVES - 1);
+  
 begin
-
+  
 ----------------------------------------------------------------------
 ---  Reset and Clock generation  -------------------------------------
 ----------------------------------------------------------------------
@@ -258,9 +278,64 @@ begin
   erstn <= rstn;
 
   -- Glitch free reset that can be used for the Eth Phy and flash memory
-
-  rst0 : rstgen generic map (acthigh => 1)
-    port map (reset, clkm, lock, rstn, rstraw);
+  reset_block: block is
+    
+    signal lockTimeoutRst  : std_logic;
+    signal lockTimeoutA    : unsigned(12 downto 0) := (others => '0');
+    signal lockTimeoutB    : unsigned(13 downto 0) := (others => '0');
+    signal lockTimeout     : std_logic;
+    signal resetOrTimeout  : std_logic;
+    
+  begin
+    
+    -- Generate reset signal for the clock lock/PHY init timeout.
+    lockTimeoutRst <= reset or lock;
+    
+    -- Generate the lock/PHY timeout counters. Use the clkace 33 MHz clock
+    -- signal for this instead of clkm, because clkace always runs, whereas
+    -- clkm comes from an MMCM in the MIG, which is reset when we generate
+    -- a timeout.
+    lock_timeout_proc: process (clkace) is
+    begin
+      if rising_edge(clkace) then
+        if lockTimeoutRst = '1' then
+          lockTimeoutA  <= (others => '0');
+          lockTimeoutB  <= (others => '0');
+          lockTimeout   <= '0';
+        else
+          if lockTimeoutA(12) = '0' then
+            lockTimeoutA <= lockTimeoutA + 1;
+          else
+            lockTimeoutA <= (others => '0');
+            if lockTimeoutB(13) = '0' then
+              lockTimeoutB <= lockTimeoutB + 1;
+            else
+              lockTimeoutB <= (others => '0');
+            end if;
+          end if;
+          lockTimeout <= lockTimeoutB(12) and lockTimeoutB(11)
+                     and lockTimeoutB(10) and lockTimeoutB(9);
+        end if;
+      end if;
+    end process;
+    
+    -- Combine the incoming reset signal with the lock timeout.
+    resetOrTimeout <= reset or lockTimeout;
+    
+    -- Original reset generator.
+    rst0 : rstgen
+      generic map (
+        acthigh   => 1
+      )
+      port map (
+        rstin     => resetOrTimeout,
+        clk       => clkm,
+        clklock   => lock,
+        rstout    => rstn,
+        rstoutraw => rstraw
+      );
+    
+  end block;
 
 ----------------------------------------------------------------------
 ---  AHB CONTROLLER --------------------------------------------------
@@ -270,7 +345,7 @@ begin
     generic map (defmast => CFG_DEFMST, split => CFG_SPLIT,
                  rrobin  => CFG_RROBIN, ioaddr => CFG_AHBIO, ioen => 1,
                  nahbm => CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE+CFG_PCIEXP,
-                 nahbs => 9)
+                 nahbs => 10)
     port map (rstn, clkm, ahbmi, ahbmo, ahbsi, ahbso);
 
 ----------------------------------------------------------------------
@@ -279,7 +354,7 @@ begin
 
   -- LEON3 processor
   nosh : if CFG_GRFPUSH = 0 generate
-    cpu : for i in 0 to CFG_NCPU-1 generate
+    cpu : for i in 0 to CFG_NLEON-1 generate
       l3ft : if CFG_LEON3FT_EN /= 0 generate
         leon3ft0 : leon3ft		-- LEON3 processor
         generic map (i, fabtech, memtech, CFG_NWIN, CFG_DSU, CFG_FPU*(1-CFG_GRFPUSH), CFG_V8,
@@ -287,7 +362,7 @@ begin
 	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
 	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
           CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
+          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NLEON-1,
 	  CFG_IUFT_EN, CFG_FPUFT_EN, CFG_CACHE_FT_EN, CFG_RF_ERRINJ,
 	  CFG_CACHE_ERRINJ, CFG_DFIXED, CFG_LEON3_NETLIST, CFG_SCAN, CFG_MMU_PAGE)
         port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
@@ -301,7 +376,7 @@ begin
 	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
 	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
           CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
+          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NLEON-1,
 	  CFG_DFIXED, CFG_SCAN, CFG_MMU_PAGE)
         port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
     		irqi(i), irqo(i), dbgi(i), dbgo(i));
@@ -310,7 +385,7 @@ begin
   end generate;
 
   sh : if CFG_GRFPUSH = 1 generate
-    cpu : for i in 0 to CFG_NCPU-1 generate
+    cpu : for i in 0 to CFG_NLEON-1 generate
       l3ft : if CFG_LEON3FT_EN /= 0 generate
         leon3ft0 : leon3ftsh		-- LEON3 processor
         generic map (i, fabtech, memtech, CFG_NWIN, CFG_DSU, CFG_FPU, CFG_V8,
@@ -318,7 +393,7 @@ begin
 	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
 	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
           CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
+          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NLEON-1,
 	  CFG_IUFT_EN, CFG_FPUFT_EN, CFG_CACHE_FT_EN, CFG_RF_ERRINJ,
 	  CFG_CACHE_ERRINJ, CFG_DFIXED, CFG_LEON3_NETLIST, CFG_SCAN, CFG_MMU_PAGE)
         port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
@@ -332,30 +407,36 @@ begin
 	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
 	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
           CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
+          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NLEON-1,
 	  CFG_DFIXED, CFG_SCAN, CFG_MMU_PAGE)
         port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
     		irqi(i), irqo(i), dbgi(i), dbgo(i), fpi(i), fpo(i));
       end generate;
     end generate;
 
-    grfpush0 : grfpushwx generic map ((CFG_FPU-1), CFG_NCPU, fabtech)
+    grfpush0 : grfpushwx generic map ((CFG_FPU-1), CFG_NLEON, fabtech)
     port map (clkm, rstn, fpi, fpo);
 
   end generate;
 
-  lerrorn <= dbgo(0).error and rstn;
+  error_leon: if CFG_NLEON /= 0 generate
+    lerrorn <= dbgo(0).error and rstn;
+  end generate;
+  error_no_leon: if CFG_NLEON = 0 generate
+    lerrorn <= rstn;
+  end generate;
   error_pad : odpad generic map (level => cmos, voltage => x25v, tech => padtech) port map (errorn, lerrorn);
 
-  dsugen : if CFG_DSU = 1 generate
+  dsugen : if CFG_DSU = 1 and CFG_NLEON /= 0 generate
     -- LEON3 Debug Support Unit
     dsugen : if CFG_DSU = 1 generate
       dsu0 : dsu3
         generic map (hindex => 2, haddr => 16#900#, hmask => 16#F00#,
-                     ncpu   => CFG_NCPU, tbits => 30, tech => memtech, irq => 0, kbytes => CFG_ATBSZ)
+                     ncpu   => CFG_NLEON, tbits => 30, tech => memtech, irq => 0, kbytes => CFG_ATBSZ)
         port map (rstn, clkm, ahbmi, ahbsi, ahbso(2), dbgo, dbgi, dsui, dsuo);
 
-      dsubre_pad : inpad generic map (level => cmos, voltage => x15v, tech  => padtech) port map (dsubre, dsui.break);
+      --dsubre_pad : inpad generic map (level => cmos, voltage => x15v, tech  => padtech) port map (dsubre, dsui.break);
+      dsui.break <= '0';
 
       dsui.enable <= '1';
       led(2) <= dsuo.active;
@@ -366,10 +447,66 @@ begin
   end generate;
 
   -- Debug UART
-  dcomgen : if CFG_AHB_UART = 1 generate
+  dcomgen : if CFG_AHB_UART = 1 and CFG_AHB_UART_RVEX = 0 generate
     dcom0 : ahbuart
       generic map (hindex => CFG_NCPU, pindex => 4, paddr => 7)
       port map (rstn, clkm, dui, duo, apbi, apbo(4), ahbmi, ahbmo(CFG_NCPU));
+  end generate;
+  rvuartgen : if CFG_AHB_UART = 1 and CFG_AHB_UART_RVEX = 1 generate
+    signal reset        : std_logic;
+    signal clk          : std_logic;
+    signal rx           : std_logic;
+    signal tx           : std_logic;
+    signal uart2dbg_bus : bus_mst2slv_type;
+    signal dbg2uart_bus : bus_slv2mst_type;
+  begin
+    
+    reset <= not rstn;
+    clk <= clkm;
+    rx <= dui.rxd;
+    duo.txd <= tx;
+    
+    -- Instantiate the AHB master for the debug UART.
+    rvex_uart_mst_inst: entity rvex.bus2ahb
+      generic map (
+        AHB_MASTER_INDEX  => CFG_NCPU,
+        AHB_VENDOR_ID     => VENDOR_TUDELFT,
+        AHB_DEVICE_ID     => TUDELFT_UART
+      )
+      port map (
+        reset             => reset,
+        clk               => clk,
+        bus2bridge        => uart2dbg_bus,
+        bridge2bus        => dbg2uart_bus,
+        bridge2ahb        => ahbmo(CFG_NCPU),
+        ahb2bridge        => ahbmi
+      );
+    
+    -- Instantiate the UART.
+    rvex_uart_inst: entity rvex.periph_uart
+      generic map (
+        F_CLK             => real(CPU_FREQ) * 1000.0,
+        F_BAUD            => 115200.0
+      )
+      port map (
+        reset             => reset,
+        clk               => clk,
+        clkEn             => '1',
+        rx                => rx,
+        tx                => tx,
+        bus2uart          => rvbsi(CFG_NRVEX),
+        uart2bus          => rvbso(CFG_NRVEX),
+        irq               => open,
+        uart2dbg_bus      => uart2dbg_bus,
+        dbg2uart_bus      => dbg2uart_bus
+        
+      );
+    
+    -- We're not using the APB slot, so tie that to none.
+    apbo(4) <= apb_none;
+    
+  end generate;
+  dbguartgen : if CFG_AHB_UART = 1 generate
     dsurx_pad : inpad generic map (level => cmos, voltage => x25v, tech  => padtech) port map (dsurx, dui.rxd);
     dsutx_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech) port map (dsutx, duo.txd);
     led(0) <= not dui.rxd;
@@ -384,6 +521,113 @@ begin
   end generate;
 
 ----------------------------------------------------------------------
+---  r-VEX processor -------------------------------------------------
+----------------------------------------------------------------------
+  
+  -- Check rvex configuration.
+  assert CFG_RVEX_CFG.core.numLaneGroupsLog2 = CFG_RVEX_CFG.core.numContextsLog2
+    report "numLaneGroups must equal numContexts due to platform constraints"
+    severity failure;
+  
+  rvsys_gen: for i in 0 to CFG_NRVEX-1 generate
+    constant PIND : integer := CFG_NLEON + i * 2**CFG_RVEX_CFG.core.numLaneGroupsLog2;
+    constant PNUM : integer := 2**CFG_RVEX_CFG.core.numLaneGroupsLog2;
+  begin
+  
+    rvsys_inst: entity rvex.rvsys_grlib
+      generic map (
+        CFG                     => CFG_RVEX_CFG,
+        AHB_MASTER_INDEX_START  => PIND,
+        CHECK_MEM               => true,
+        CHECK_MEM_FILE          => "ram.srec"
+      )
+      port map (
+        clki                    => clkm,
+        rstn                    => rstn,
+        ahbmi                   => ahbmi,
+        ahbmo                   => ahbmo(PIND+PNUM-1 downto PIND),
+        ahbsi                   => ahbsi,
+        bus2dgb                 => rvbsi(i),
+        dbg2bus                 => rvbso(i),
+        irqi                    => irqi(PIND to PIND+PNUM-1),
+        irqo                    => irqo(PIND to PIND+PNUM-1)
+      );
+    
+  end generate;
+  
+----------------------------------------------------------------------
+---  r-VEX bus bridge ------------------------------------------------
+----------------------------------------------------------------------
+  
+  rvex_bus_bridge_block: block is
+    
+    signal reset        : std_logic;
+    signal clk          : std_logic;
+    
+    function addr_map return addrRangeAndMapping_array is
+      variable retval : addrRangeAndMapping_array(0 to N_RVB_SLAVES - 1);
+      variable i : natural;
+    begin
+      i := 0;
+      
+      for c in 0 to CFG_NRVEX - 1 loop
+        retval(i) := addrRangeAndMap(
+          match => X"D0" & std_logic_vector(to_unsigned(c, 4)) & "----" & "--------" & "--------"
+        );
+        i := i + 1;
+      end loop;
+      
+      if CFG_AHB_UART*CFG_AHB_UART_RVEX = 1 then
+        retval(i) := addrRangeAndMap(
+          match => X"D1" & "--------" & "--------" & "--------"
+        );
+        i := i + 1;
+      end if;
+      
+      return retval;
+    end function;
+    
+  begin
+    
+    reset <= not rstn;
+    clk <= clkm;
+    
+    -- Instantiate the bus bridge.
+    rvex_bus_bridge_inst: entity rvex.ahb2bus
+      generic map (
+        AHB_INDEX       => 9,
+        AHB_ADDR        => 16#D00#,
+        AHB_MASK        => 16#F00#,
+        AHB_VENDOR_ID   => VENDOR_TUDELFT,
+        AHB_DEVICE_ID   => TUDELFT_BRIDGE
+      )
+      port map (
+        reset           => reset,
+        clk             => clk,
+        ahb2bridge      => ahbsi,
+        bridge2ahb      => ahbso(9),
+        bridge2bus      => rvbmo,
+        bus2bridge      => rvbmi
+      );
+    
+    -- Instantiate the demuxer.
+    rvex_bus_bridge_demux: entity rvex.bus_demux
+      generic map (
+        ADDRESS_MAP     => addr_map
+      )
+      port map (
+        reset           => reset,
+        clk             => clk,
+        clkEn           => '1',
+        mst2demux       => rvbmo,
+        demux2mst       => rvbmi,
+        demux2slv       => rvbsi,
+        slv2demux       => rvbso
+      );
+    
+  end block;
+  
+----------------------------------------------------------------------
 ---  Memory controllers ----------------------------------------------
 ----------------------------------------------------------------------
 
@@ -429,7 +673,7 @@ begin
 --  mig_gen : if (CFG_MIG_DDR2 = 1) generate
 
     ahb2mig0 : ahb2mig_ml605
-      generic map ( hindex => 0, haddr => 16#400#, hmask => 16#E00#,
+      generic map ( hindex => 0, haddr => 16#000#, hmask => 16#E00#,
     MHz => 400, Mbyte => 512, nosync => boolean'pos(CFG_MIG_CLK4=12)) --CFG_CLKDIV/12)
       port map (
     rst => rstn, clk_ahb => clkm, clk_ddr => clk_ddr,
diff -rupN '--exclude=ram.srec' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/Makefile work/Makefile
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/Makefile	2014-04-16 16:50:08.000000000 +0200
+++ work/Makefile	2015-02-20 18:44:53.207526654 +0100
@@ -1,5 +1,5 @@
 include .config
-GRLIB=../..
+GRLIB=../../../grlib/grlib-gpl-1.3.7-b4144
 TOP=leon3mp
 DESIGN=leon3-xilinx-ml605
 BOARD=xilinx-ml605-xc6vlx240t
@@ -14,6 +14,7 @@ EFFORT=high
 XSTOPT=-uc leon3mp.xcf
 SYNPOPT="set_option -pipe 1; set_option -retiming 0; set_option -enable_prepacking 1;\
 set_option -write_apr_constraint 0;set_option -resource_sharing 1; set_option -symbolic_fsm_compiler 1"
+
 VHDLOPTSYNFILES= \
 	mig_37/user_design/rtl/controller/arb_mux.vhd \
 	mig_37/user_design/rtl/controller/arb_row_col.vhd \
@@ -69,65 +70,12 @@ VHDLOPTSYNFILES= \
 	pcie/v6_pcie_v1_7/source/*.vhd \
 	$(GRLIB)/lib/gaisler/pcie/pcie.vhd
 
-ifeq ("$(CONFIG_PCIEXP_MASTER_TARGET)","y")
-  ifeq ("$(CONFIG_LANE_WIDTH1)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane1.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane1.ucf
-  endif
-  ifeq ("$(CONFIG_LANE_WIDTH2)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane2.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane2.ucf
-  endif
-  ifeq ("$(CONFIG_LANE_WIDTH4)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane4.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane4.ucf
-  endif
-  ifeq ("$(CONFIG_LANE_WIDTH8)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane8.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane8.ucf
-  endif
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pcie_master_target_virtex.vhd
-endif
-ifeq ("$(CONFIG_PCIEXP_MASTER_FIFO)","y")
-  ifeq ("$(CONFIG_PCIEXP_MASTER_FIFO_DMA)","y")
-    ifeq ("$(CONFIG_LANE_WIDTH1)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_dma_lane1.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_dma_lane1.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH2)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_dma_lane2.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_dma_lane2.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH4)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_dma_lane4.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_dma_lane4.ucf
-    endif
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pcie_master_fifo_virtex.vhd
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pciedma.vhd
-  endif
-  ifneq ("$(CONFIG_PCIEXP_MASTER_FIFO_DMA)","y")
-    ifeq ("$(CONFIG_LANE_WIDTH1)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_lane1.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_lane1.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH2)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_lane2.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_lane2.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH4)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_lane4.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_lane4.ucf
-    endif
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pcie_master_fifo_virtex.vhd
-  endif
-endif
 
 VERILOGOPTSYNFILES= \
 	mig/user_design/rtl/controller/*.v \
 	mig/user_design/rtl/ecc/*.v \
 	mig/user_design/rtl/ip_top/*.v \
 	mig/user_design/rtl/phy/*.v \
-	mig/user_design/rtl/phy/*.v \
 	mig/user_design/rtl/ui/*.v \
 	$$XILINX/verilog/src/glbl.v
 VHDLSYNFILES= \
@@ -136,29 +84,18 @@ VHDLSYNFILES= \
 
 VHDLSIMFILES=testbench.vhd
 
-ifeq ("$(CONFIG_PCIEXP_MASTER_TARGET)","y")
-VHDLSIMFILES+=$(GRLIB)/lib/tech/unisim/ise/GTPA1_DUAL.vhd $(GRLIB)/lib/tech/unisim/ise/GTP_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/GTXE1.vhd $(GRLIB)/lib/tech/unisim/ise/GTX_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/PCIE_2_0.vhd $(GRLIB)/lib/tech/unisim/ise/PCIE_A1.vhd
-else 
-ifeq ("$(CONFIG_PCIEXP_MASTER_FIFO)","y")
-VHDLSIMFILES+=$(GRLIB)/lib/tech/unisim/ise/GTPA1_DUAL.vhd $(GRLIB)/lib/tech/unisim/ise/GTP_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/GTXE1.vhd $(GRLIB)/lib/tech/unisim/ise/GTX_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/PCIE_2_0.vhd $(GRLIB)/lib/tech/unisim/ise/PCIE_A1.vhd
-endif
-endif
-
 SIMTOP=testbench
 SDCFILE=default.sdc
 BITGEN=$(GRLIB)/boards/$(BOARD)/default.ut
 CLEAN=soft-clean migclean pcieclean
 TECHLIBS = secureip unisim
+EXTRALIBS=../../../lib
 VLOGOPT= -O0
-VCOMOPT= -explicit -O0 
+VCOMOPT= -explicit -O0
 ifeq ("$(GRLIB_SIMULATOR)","ALDEC")
 VSIMOPT= +access +w -t ps -novopt +notimingchecks -L secureip_ver -L xilinxcorelib_ver -L unisims_ver glbl $(SIMTOP)
 else
-VSIMOPT= -t ps -novopt +notimingchecks -L secureip_ver -L xilinxcorelib_ver -L unisims_ver glbl $(SIMTOP)
+VSIMOPT= -t ps -do ../phy.do -novopt +notimingchecks -L secureip_ver -L xilinxcorelib_ver -L unisims_ver glbl $(SIMTOP)
 endif
 
 LIBSKIP = core1553bbc core1553brm core1553brt gr1553 corePCIF \
@@ -175,6 +112,9 @@ include $(GRLIB)/software/leon3/Makefile
 
 ##################  project specific targets ##########################
 
+# Stop deleting logs!
+.SECONDARY:
+
 mig_37 mig:
 	cp grlib_mig/mig.* .
 	coregen -b mig.xco -p mig.cgp
diff -rupN '--exclude=ram.srec' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/testbench.vhd work/testbench.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/testbench.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/testbench.vhd	2015-02-20 18:44:53.207526654 +0100
@@ -210,7 +210,7 @@ begin
       ddr3_ck_n     => ddr3_ck_n,
       
       -- Debug Unit
-      dsubre    => dsubre,
+      --dsubre    => dsubre,
 
       -- AHB Uart
       dsutx     => dsutx,
