diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/ahb2mig_ml605.vhd work/ahb2mig_ml605.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/ahb2mig_ml605.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/ahb2mig_ml605.vhd	2017-02-02 13:18:09.978630391 +0100
@@ -39,9 +39,9 @@ package ml605 is
   constant DM_WIDTH  : integer := 8;
   constant DQ_WIDTH  : integer := 64;
   constant DQS_WIDTH : integer := 8;
-  constant ROW_WIDTH : integer := 13;
+  constant ROW_WIDTH : integer := 14;
   constant PAYLOAD_WIDTH : integer := 64;
-  constant ADDR_WIDTH    : integer := 27;
+  constant ADDR_WIDTH    : integer := 28;
 
   type mig_app_in_type is record
       app_wdf_wren  : std_logic;
@@ -314,7 +314,7 @@ begin
    ahbso.hresp   <= ra.hresp;
    ahbso.hrdata <= ahbdrivedata(ra.hrdata);
 
-   migi.app_addr  <= '0' & ra.acc.haddr(28 downto 6) & "000";
+   migi.app_addr  <= "00" & ra.acc.haddr(28 downto 6) & "000";
 
    ddr_ctrl : process(rst, r, ra, migo)
    variable v        : ddr_reg_type;   -- local variables for registers
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/config.vhd work/config.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/config.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/config.vhd	2017-02-02 13:18:09.982630355 +0100
@@ -13,6 +13,15 @@
 library techmap;
 use techmap.gencomp.all;
 
+library ieee;
+use ieee.std_logic_1164.all;
+
+library rvex;
+use rvex.common_pkg.all;
+use rvex.core_pkg.all;
+use rvex.cache_pkg.all;
+use rvex.rvsys_grlib_pkg.all;
+
 package config is
 -- Technology and synthesis options
   constant CFG_FABTECH : integer := virtex6;
@@ -21,62 +30,38 @@ package config is
   constant CFG_NOASYNC : integer := 0;
   constant CFG_SCAN : integer := 0;
 -- LEON3 processor core
-  constant CFG_LEON3 : integer := 1;
-  constant CFG_NCPU : integer := (1);
-  constant CFG_NWIN : integer := (8);
-  constant CFG_V8 : integer := 16#32# + 4*0;
-  constant CFG_MAC : integer := 0;
-  constant CFG_BP : integer := 1;
-  constant CFG_SVT : integer := 1;
-  constant CFG_RSTADDR : integer := 16#00000#;
-  constant CFG_LDDEL : integer := (1);
-  constant CFG_NOTAG : integer := 0;
-  constant CFG_NWP : integer := (2);
-  constant CFG_PWD : integer := 1*2;
-  constant CFG_FPU : integer := 0 + 16*0 + 32*0;
-  constant CFG_GRFPUSH : integer := 0;
-  constant CFG_ICEN : integer := 1;
-  constant CFG_ISETS : integer := 2;
-  constant CFG_ISETSZ : integer := 8;
-  constant CFG_ILINE : integer := 8;
-  constant CFG_IREPL : integer := 0;
-  constant CFG_ILOCK : integer := 0;
-  constant CFG_ILRAMEN : integer := 0;
-  constant CFG_ILRAMADDR: integer := 16#8E#;
-  constant CFG_ILRAMSZ : integer := 1;
-  constant CFG_DCEN : integer := 1;
-  constant CFG_DSETS : integer := 2;
-  constant CFG_DSETSZ : integer := 4;
-  constant CFG_DLINE : integer := 4;
-  constant CFG_DREPL : integer := 0;
-  constant CFG_DLOCK : integer := 0;
-  constant CFG_DSNOOP : integer := 1*2 + 4*1;
-  constant CFG_DFIXED : integer := 16#0#;
-  constant CFG_DLRAMEN : integer := 0;
-  constant CFG_DLRAMADDR: integer := 16#8F#;
-  constant CFG_DLRAMSZ : integer := 1;
-  constant CFG_MMUEN : integer := 1;
-  constant CFG_ITLBNUM : integer := 8;
-  constant CFG_DTLBNUM : integer := 2;
-  constant CFG_TLB_TYPE : integer := 1 + 0*2;
-  constant CFG_TLB_REP : integer := 1;
-  constant CFG_MMU_PAGE : integer := 0;
-  constant CFG_DSU : integer := 1;
-  constant CFG_ITBSZ : integer := 4;
-  constant CFG_ATBSZ : integer := 4;
-  constant CFG_LEON3FT_EN : integer := 0;
-  constant CFG_IUFT_EN : integer := 0;
-  constant CFG_FPUFT_EN : integer := 0;
-  constant CFG_RF_ERRINJ : integer := 0;
-  constant CFG_CACHE_FT_EN : integer := 0;
-  constant CFG_CACHE_ERRINJ : integer := 0;
-  constant CFG_LEON3_NETLIST: integer := 0;
   constant CFG_DISAS : integer := 0 + 0;
   constant CFG_PCLOW : integer := 2;
+-- r-VEX processor core
+  constant CFG_RVEX : integer := 1;
+  constant CFG_NRVEX : integer := 1;
+  constant CFG_RVEX_CFG : rvex_grlib_generic_config_array(0 to CFG_NRVEX-1) := (
+    
+    -- Core 0 configuration
+    0 => rvex_grlib_cfg(
+      core => rvex_cfg(
+        numLanesLog2          => 3,
+        numLaneGroupsLog2     => 2,
+        numContextsLog2       => 2,
+        bundleAlignLog2       => 0,
+        limmhFromPreviousPair => 0,
+        traceEnable           => 1,
+        perfCountSize         => 4,
+        cachePerfCountEnable  => 7
+      ), core_valid => true,
+    
+      -- Cache configuration
+      cache => cache_cfg(
+        --instrCacheLinesLog2 => 10, -- 1024*32 = 32 kiB per block, 128 kiB total
+        --dataCacheLinesLog2  => 11  -- 2048*4 = 8 kiB per block, 32 kiB total
+        instrCacheLinesLog2 => 9,  -- 512*32 = 16 kiB per block, 64 kiB total
+        dataCacheLinesLog2  => 10  -- 1024*4 = 4 kiB per block, 16 kiB total
+      ), cache_valid => true)
+    
+  );
+-- Total number of processors
+  constant CFG_NCPU : integer := rvex_grlib_num_lane_groups(CFG_RVEX_CFG);
 -- AMBA settings
-  constant CFG_DEFMST : integer := (0);
-  constant CFG_RROBIN : integer := 1;
-  constant CFG_SPLIT : integer := 1;
   constant CFG_FPNPEN : integer := 0;
   constant CFG_AHBIO : integer := 16#FFF#;
   constant CFG_APBADDR : integer := 16#800#;
@@ -85,83 +70,20 @@ package config is
   constant CFG_AHB_MONWAR : integer := 0;
   constant CFG_AHB_DTRACE : integer := 0;
 -- DSU UART
-  constant CFG_AHB_UART : integer := 0;
--- JTAG based DSU interface
-  constant CFG_AHB_JTAG : integer := 1;
--- Ethernet DSU
-  constant CFG_DSU_ETH : integer := 1 + 0 + 0;
-  constant CFG_ETH_BUF : integer := 16;
-  constant CFG_ETH_IPM : integer := 16#C0A8#;
-  constant CFG_ETH_IPL : integer := 16#0033#;
-  constant CFG_ETH_ENM : integer := 16#020789#;
-  constant CFG_ETH_ENL : integer := 16#000123#;
--- LEON2 memory controller
-  constant CFG_MCTRL_LEON2 : integer := 1;
-  constant CFG_MCTRL_RAM8BIT : integer := 1;
-  constant CFG_MCTRL_RAM16BIT : integer := 1;
-  constant CFG_MCTRL_5CS : integer := 0;
-  constant CFG_MCTRL_SDEN : integer := 0;
-  constant CFG_MCTRL_SEPBUS : integer := 0;
-  constant CFG_MCTRL_INVCLK : integer := 0;
-  constant CFG_MCTRL_SD64 : integer := 0;
-  constant CFG_MCTRL_PAGE : integer := 0 + 0;
--- AHB ROM
-  constant CFG_AHBROMEN : integer := 0;
-  constant CFG_AHBROPIP : integer := 0;
-  constant CFG_AHBRODDR : integer := 16#000#;
-  constant CFG_ROMADDR : integer := 16#000#;
-  constant CFG_ROMMASK : integer := 16#E00# + 16#000#;
--- AHB RAM
-  constant CFG_AHBRAMEN : integer := 0;
-  constant CFG_AHBRSZ : integer := 1;
-  constant CFG_AHBRADDR : integer := 16#A00#;
-  constant CFG_AHBRPIPE : integer := 0;
--- Gaisler Ethernet core
-  constant CFG_GRETH : integer := 1;
-  constant CFG_GRETH1G : integer := 0;
-  constant CFG_ETH_FIFO : integer := 16;
-  constant CFG_GRETH_FT : integer := 0;
-  constant CFG_GRETH_EDCLFT : integer := 0;
--- UART 1
-  constant CFG_UART1_ENABLE : integer := 1;
-  constant CFG_UART1_FIFO : integer := 8;
+  constant CFG_AHB_UART : integer := 1;
+  constant CFG_AHB_UART_RVEX : integer := 1; -- Use rvex debug UART instead of grlib UART
 -- LEON3 interrupt controller
-  constant CFG_IRQ3_ENABLE : integer := 1;
   constant CFG_IRQ3_NSEC : integer := 0;
--- Modular timer
-  constant CFG_GPT_ENABLE : integer := 1;
-  constant CFG_GPT_NTIM : integer := (2);
-  constant CFG_GPT_SW : integer := (16);
-  constant CFG_GPT_TW : integer := (32);
-  constant CFG_GPT_IRQ : integer := (8);
-  constant CFG_GPT_SEPIRQ : integer := 1;
-  constant CFG_GPT_WDOGEN : integer := 0;
-  constant CFG_GPT_WDOG : integer := 16#0#;
--- GPIO port
-  constant CFG_GRGPIO_ENABLE : integer := 1;
-  constant CFG_GRGPIO_IMASK : integer := 16#0000#;
-  constant CFG_GRGPIO_WIDTH : integer := (8);
--- I2C master
-  constant CFG_I2C_ENABLE : integer := 1;
-
--- VGA and PS2/ interface
-  constant CFG_KBD_ENABLE : integer := 0;
-  constant CFG_VGA_ENABLE : integer := 0;
-  constant CFG_SVGA_ENABLE : integer := 1;
 
--- AMBA System ACE Interface Controller
-  constant CFG_GRACECTRL : integer := 1;
-
--- PCIEXP interface
- constant CFG_PCIEXP : integer := 0;
- constant CFG_PCIE_TYPE : integer := 0;
- constant CFG_PCIE_SIM_MAS : integer := 0;
- constant CFG_PCIEXPVID : integer := 16#0#;
- constant CFG_PCIEXPDID : integer := 16#0#;
-  constant CFG_NO_OF_LANES : integer := 1;
 -- GRLIB debugging
   constant CFG_DUART : integer := 0;
 -- Xilinx MIG DDR2 controller
   constant CFG_MIG_DDR2 : integer := 1;
-  constant CFG_MIG_CLK4 : integer := 16;
+  --constant CFG_MIG_CLK4 : integer := 30; -- 40 MHz     (5.0ns sync with 200MHz DDR)
+  --constant CFG_MIG_CLK4 : integer := 32; -- 37.5 MHz   (1.6ns sync with 200MHz DDR)
+  --constant CFG_MIG_CLK4 : integer := 33; -- 36.36 MHz  (2.5ns sync with 200MHz DDR)
+    constant CFG_MIG_CLK4 : integer := 36; -- 33.33 MHz  (5.0ns sync with 200MHz DDR)
+  --constant CFG_MIG_CLK4 : integer := 40; -- 30 MHz     (1.6ns sync with 200MHz DDR)
+  --constant CFG_MIG_CLK4 : integer := 60; -- 20 MHz     (5.0ns sync with 200MHz DDR)
+
 end;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/gracectrl.vhd work/gracectrl.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/gracectrl.vhd	1970-01-01 01:00:00.000000000 +0100
+++ work/gracectrl.vhd	2017-02-02 13:18:09.982630355 +0100
@@ -0,0 +1,421 @@
+------------------------------------------------------------------------------
+--  This file is a part of the GRLIB VHDL IP LIBRARY
+--  Copyright (C) 2003 - 2008, Gaisler Research
+--  Copyright (C) 2008 - 2014, Aeroflex Gaisler
+--
+--  This program is free software; you can redistribute it and/or modify
+--  it under the terms of the GNU General Public License as published by
+--  the Free Software Foundation; either version 2 of the License, or
+--  (at your option) any later version.
+--
+--  This program is distributed in the hope that it will be useful,
+--  but WITHOUT ANY WARRANTY; without even the implied warranty of
+--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+--  GNU General Public License for more details.
+--
+--  You should have received a copy of the GNU General Public License
+--  along with this program; if not, write to the Free Software
+--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
+-------------------------------------------------------------------------------
+-- Entity:      gracectrl
+-- File:        gracectrl.vhd
+-- Author:      Jan Andersson - Gaisler Research AB
+-- Contact:     support@gaisler.com
+-- Description: Provides a GRLIB AMBA AHB slave interface to Xilinx System ACE
+-------------------------------------------------------------------------------
+
+-- NOTE: this gracectrl is modified to work with 32-bit accesses, as the r-VEX
+-- bus bridge cannot do 16-bit or 8-bit accesses.
+
+library ieee;
+use ieee.std_logic_1164.all;
+
+library grlib, gaisler;
+use grlib.amba.all;
+use grlib.devices.all;
+use grlib.stdlib.all;
+use gaisler.misc.all;
+
+entity gracectrl is
+  generic (
+    hindex  : integer := 0;               -- AHB slave index
+    hirq    : integer := 0;               -- Interrupt line
+    haddr   : integer := 16#000#;         -- Base address
+    hmask   : integer := 16#fff#;         -- Area mask
+    split   : integer range 0 to 1 := 0;  -- Enable AMBA SPLIT support
+    swap    : integer range 0 to 1 := 0;
+    oepol   : integer range 0 to 1 := 0;  -- Output enable polarity
+    mode    : integer range 0 to 2 := 0   -- 0: 16-bit mode only
+                                          -- 1: 8-bit mode only
+                                          -- 2: 8-bit, emulate 16-bit 
+    );
+  port (
+    rstn    : in  std_ulogic;
+    clk     : in  std_ulogic;             -- System (AMBA) clock
+    clkace  : in  std_ulogic;             -- System ACE clock
+    ahbsi   : in  ahb_slv_in_type;
+    ahbso   : out ahb_slv_out_type;
+    acei    : in  gracectrl_in_type;
+    aceo    : out gracectrl_out_type
+  );  
+end gracectrl;
+
+architecture rtl of gracectrl is
+
+  -----------------------------------------------------------------------------
+  -- Constants
+  -----------------------------------------------------------------------------
+  constant REVISION : amba_version_type := 0;
+
+  constant HCONFIG : ahb_config_type := (
+    0 => ahb_device_reg(VENDOR_GAISLER, GAISLER_GRACECTRL, 0, REVISION, hirq),
+--    1 => conv_std_logic_vector(swap*4 + mode, 32),
+    4 => ahb_iobar(haddr, hmask), others => zero32);
+
+  constant OUTPUT : std_ulogic := conv_std_logic(oepol = 1);
+  constant INPUT  : std_ulogic := not conv_std_logic(oepol = 1);
+
+  constant ACEDW : integer := 16-8*(mode mod 2);
+  
+  -----------------------------------------------------------------------------
+  -- Functions
+  -----------------------------------------------------------------------------
+  -- purpose: swaps a hword if 'swap' is non-zero and mode is zero,
+  --          otherwise just propagate data
+  function condhswap (d : std_logic_vector)
+    return std_logic_vector is
+    variable dx : std_logic_vector(15 downto 0);
+  begin  -- hswap
+    dx(ACEDW-1 downto 0) := d;
+    if swap /= 0 and mode = 0 then
+      return dx(7 downto 0) & dx(15 downto 8);
+    end if;
+    return dx;
+  end condhswap;
+
+  -----------------------------------------------------------------------------
+  -- Types
+  -----------------------------------------------------------------------------
+
+  type sys_sync_type is record
+     accdone   : std_logic_vector(1 downto 0);
+     irq       : std_logic_vector(2 downto 0);
+  end record;
+  
+  type sys_reg_type is record
+     acc       : std_ulogic;     -- Perform access
+     active    : std_ulogic;     -- Access active
+     sync      : sys_sync_type;
+     -- AHB
+     insplit   : std_ulogic;     -- SPLIT response issued
+     unsplit   : std_ulogic;     -- SPLIT complete not issued
+     irq       : std_ulogic;     -- Interrupt request
+     hwrite    : std_ulogic;
+     hsel      : std_ulogic;
+     hmbsel    : std_logic_vector(0 to 1);
+     haddr     : std_logic_vector(8 downto 0);
+     hready    : std_ulogic;
+     wdata     : std_logic_vector(ACEDW-1 downto 0);
+     hresp     : std_logic_vector(1 downto 0);
+     splmst    : std_logic_vector(log2(NAHBMST)-1 downto 0);   -- SPLIT:ed master
+     hsplit    : std_logic_vector(NAHBMST-1 downto 0);  -- Other SPLIT:ed masters
+     ahbcancel : std_ulogic;     -- Locked access cancels ongoing SPLIT
+                                 -- response
+  end record;
+
+
+  type ace_state_type is (idle, en, rd, done);
+
+  type ace_sync_type is record
+     acc     : std_logic_vector(1 downto 0);
+     rstn    : std_logic_vector(1 downto 0);
+     hwrite  : std_logic_vector(1 downto 0);
+     dummy   : std_logic_vector(1 downto 0);
+  end record;
+  
+  type ace_reg_type is record
+     state     : ace_state_type;
+     sync      : ace_sync_type;
+     accdone   : std_ulogic;
+     rdata     : std_logic_vector(ACEDW-1 downto 0);
+     edone     : std_ulogic;
+     aceo      : gracectrl_out_type;
+  end record;
+    
+  -----------------------------------------------------------------------------
+  -- Signals
+  -----------------------------------------------------------------------------
+  signal r, rin : sys_reg_type;
+  signal s, sin : ace_reg_type;
+    
+begin  -- rtl
+
+  -----------------------------------------------------------------------------
+  -- System clock domain
+  -----------------------------------------------------------------------------
+  combsys: process (r, s, rstn, ahbsi, acei.irq)
+    variable v       : sys_reg_type;
+    variable irq     : std_logic_vector((NAHBIRQ-1) downto 0);
+    variable hsplit  : std_logic_vector(NAHBMST-1 downto 0);
+    variable hwdata  : std_logic_vector(31 downto 0);
+  begin  -- process comb
+    v := r; v.irq := '0'; irq := (others => '0'); irq(hirq) := r.irq;
+    v.hresp := HRESP_OKAY; v.hready := '1'; hsplit := (others => '0');
+    hwdata := ahbreadword(ahbsi.hwdata, r.haddr(4 downto 2)); 
+    
+    -- Sync
+    v.sync.accdone := r.sync.accdone(0) & s.accdone;
+    v.sync.irq     := r.sync.irq(1 downto 0) & acei.irq;
+    
+    -- AHB communication
+    if ahbsi.hready = '1' then
+      if (ahbsi.hsel(hindex) and ahbsi.htrans(1)) = '1' then
+        v.hmbsel := ahbsi.hmbsel(r.hmbsel'range);
+        if split = 0 or (not (r.active or r.acc) or ahbsi.hmastlock) = '1' then
+          v.hready := '0';
+          v.hwrite := ahbsi.hwrite;
+          v.haddr := ahbsi.haddr(8 downto 0);
+          v.hsel := '1';
+          if r.insplit = '0' then
+            v.acc := '1';
+          end if;
+          if split /= 0 then
+            if ahbsi.hmastlock = '0' then
+              v.hresp := HRESP_SPLIT;
+              v.splmst := ahbsi.hmaster;
+              v.unsplit := '1';
+            else
+              v.ahbcancel := r.insplit;
+            end if;
+            v.insplit := not ahbsi.hmastlock;
+          end if;
+        else
+          -- Core is busy, transfer is not locked respond with SPLIT
+          v.hready := '0';
+          if split /= 0 then
+            v.hresp := HRESP_SPLIT;
+            v.hsplit(conv_integer(ahbsi.hmaster)) := '1';
+          end if;
+        end if;
+      else
+        v.hsel := '0';
+      end if;
+    end if;
+
+    if (r.hready = '0') then
+      if (r.hresp = HRESP_OKAY) then v.hready := '0';
+      else v.hresp := r.hresp; end if;
+    end if;    
+
+    if r.acc = '1' then
+      -- Propagate data
+      if r.active = '0' then
+        if mode /= 1 then
+          if r.haddr(1) = '0' then v.wdata := hwdata(ACEDW+15 downto 16);
+          else v.wdata := hwdata(ACEDW-1 downto 0); end if;
+        else
+          case r.haddr(1 downto 0) is
+            when "00" => v.wdata(7 downto 0) := hwdata(31 downto 24);
+            when "01" => v.wdata(7 downto 0) := hwdata(23 downto 16);
+            when "10" => v.wdata(7 downto 0) := hwdata(15 downto 8);
+            when others => v.wdata(7 downto 0) := hwdata(7 downto 0);
+          end case;
+        end if;
+        if mode = 2 then
+          -- Override writes to busmode register
+          if r.haddr(6 downto 1) = zero32(6 downto 1) then
+            v.wdata := (others => '0');  -- Byte
+          end if;
+        end if;
+      end if;
+      -- Remove access signal when access is done
+      if r.sync.accdone(1) = '1' then
+        v.acc := '0';
+      end if;
+      v.active := '1';
+    end if;
+
+    -- AMBA response when access is complete
+    if r.acc = '0' and r.sync.accdone(1) = '0' and r.active = '1' then
+      if split /= 0 and r.unsplit = '1' then
+        hsplit(conv_integer(r.splmst)) := '1';
+        v.unsplit := '0';
+      end if;
+      if ((split = 0 or v.ahbcancel = '0') and
+          (split = 0 or ahbsi.hmaster = r.splmst or r.insplit = '0') and
+          (((ahbsi.hsel(hindex) and ahbsi.hready and ahbsi.htrans(1)) = '1') or
+           ((split = 0 or r.insplit = '0') and r.hready = '0' and r.hresp = HRESP_OKAY))) then
+        v.hresp := HRESP_OKAY;
+        if split /= 0 then
+          v.insplit := '0';
+          v.hsplit := r.hsplit;
+        end if;
+        v.hready := '1';
+        v.hsel := '0';
+        v.active := '0';
+      elsif split /= 0 and v.ahbcancel = '1' then
+        v.acc := '1';
+        v.ahbcancel := '0';
+      end if;
+    end if;
+
+    -- Interrupt request, not filtered, pulsed
+    if (not r.sync.irq(2) and r.sync.irq(1)) = '1' then
+      v.irq := '1';
+    end if;
+    
+    -- Reset
+    if rstn = '0' then
+      v.acc        := '0';
+      v.active     := '0';
+      --
+      v.insplit    := '0';
+      v.unsplit    := '0';
+      v.hready     := '1';
+      v.hwrite     := '0';
+      v.hsel       := '0';
+      v.hmbsel     := (others => '0');
+      v.ahbcancel  := '0';
+    end if;
+    if split = 0 then
+      v.insplit   := '0';
+      v.unsplit   := '0';
+      v.splmst    := (others => '0');
+      v.hsplit    := (others => '0');
+      v.ahbcancel := '0';
+    end if;
+
+    -- Update registers
+    rin <= v;
+
+    -- AHB slave output
+    ahbso.hready  <= r.hready;
+    ahbso.hresp   <= r.hresp;
+    ahbso.hrdata  <= ahbdrivedata(s.rdata); -- Bad, but does not toggle much
+    ahbso.hconfig <= HCONFIG;
+    ahbso.hirq    <= irq;
+    ahbso.hindex  <= hindex;
+    ahbso.hsplit  <= hsplit;
+    
+  end process combsys;
+  
+  regsys: process (clk)
+  begin  -- process reg
+    if rising_edge(clk) then
+      r <= rin;
+    end if;
+  end process regsys;
+
+  -----------------------------------------------------------------------------
+  -- System ACE clock domain
+  -----------------------------------------------------------------------------
+  combace: process (r, s, rstn, acei)
+    variable v       : ace_reg_type;
+  begin  -- process comb
+    v := s;
+    
+    -- Synchronize inputs
+    v.sync.acc := s.sync.acc(0) & r.acc;
+    v.sync.rstn := s.sync.rstn(0) & rstn;
+    v.sync.hwrite := s.sync.hwrite(0) & r.hwrite;
+    if mode = 2 then
+      -- Fake reads from BUSMODE register?
+      v.sync.dummy := s.sync.dummy(0) & not orv(r.haddr(8 downto 3));
+    else
+      v.sync.dummy := (others => '0');
+    end if;
+    
+    case s.state is
+      when idle =>
+        v.aceo.addr := r.haddr(8 downto 2);
+        if mode = 2 then v.aceo.do(7 downto 0) := r.wdata(7 downto 0);
+        else v.aceo.do(r.wdata'range) := condhswap(r.wdata); end if;
+        if s.sync.acc(1) = '1' then
+          v.aceo.cen := '0';
+          v.aceo.doen := INPUT xor r.hwrite;
+          v.state := en;
+        end if;
+        if mode = 2 then v.edone := '0'; end if;
+        
+      when en =>
+        v.aceo.wen := not r.hwrite;
+        if s.sync.hwrite(1) = '1' then
+          v.state := done;
+        else
+          v.state := rd;
+        end if;
+
+      when rd => 
+        v.aceo.oen := '0';
+        v.state := done;
+        
+      when done =>
+        v.aceo.oen := '1';
+        v.aceo.wen := '1';
+        if mode = 2 and s.edone = '0' then
+          -- Keep 16-bit address map
+          v.aceo.addr(0) := '1';
+          v.aceo.do(7 downto 0) := r.wdata(ACEDW-1 downto ACEDW-8);
+          v.rdata(7 downto 0) := acei.di(7 downto 0);
+          v.edone := '1';
+          v.state := en;
+        else
+          v.aceo.cen := '1';
+          if s.accdone = '0' then
+            if mode = 2 then
+              v.rdata(ACEDW-1 downto ACEDW-8) := acei.di(7 downto 0);
+              if s.sync.dummy(1) = '1' then -- Fake read
+                v.rdata := (others => '0'); v.rdata(0) := '1';
+              end if;
+            else
+              v.rdata := condhswap(acei.di)(s.rdata'range);
+            end if;
+            v.accdone := '1';
+          else
+            v.aceo.doen := INPUT;
+          end if;
+          if s.sync.acc(1) = '0' then
+            v.state := idle;
+            v.accdone := '0';
+          end if;
+        end if;
+    end case;
+
+    -- Reset
+    if s.sync.rstn(1) = '0' then
+      v.state     := idle;
+      v.accdone   := '0';
+      v.aceo.cen  := '1';
+      v.aceo.wen  := '1';
+      v.aceo.oen  := '1';
+      v.aceo.doen := INPUT;
+    end if;
+    if mode = 1 then v.aceo.do(15 downto 8) := (others => '0'); end if;
+    if mode /= 2 then v.edone := '0'; end if;
+    
+    -- Update registers
+    sin <= v;
+
+    -- Assign outputs to System ACE
+    aceo <= s.aceo;
+    
+  end process combace;
+    
+  regace: process (clkace)
+  begin  -- process reg
+    if rising_edge(clkace) then
+      s <= sin;
+    end if;
+  end process regace;
+  
+  -- Boot message
+  -- pragma translate_off
+  bootmsg : report_version 
+    generic map (
+      "gracectrl" & tost(hindex) & ": System ACE I/F Controller, rev " &
+      tost(REVISION) & ", irq " & tost(hirq));
+  -- pragma translate_on
+
+end rtl;
+
+
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/grlib_config.vhd work/grlib_config.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/grlib_config.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/grlib_config.vhd	2017-02-02 13:18:09.982630355 +0100
@@ -38,7 +38,7 @@ package config is
 -- The value here sets the width of the AMBA AHB data vectors for all
 -- cores in the library.
 --
-constant CFG_AHBDW     : integer := 64;
+constant CFG_AHBDW     : integer := 128;
 
 
 -- CORE_ACDM - Enable AMBA Compliant Data Muxing in cores
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/grlib_mig/mig39.prj work/grlib_mig/mig39.prj
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/grlib_mig/mig39.prj	2014-04-16 16:50:08.000000000 +0200
+++ work/grlib_mig/mig39.prj	2017-02-02 13:18:09.982630355 +0100
@@ -11,14 +11,14 @@
     <IODelayHighPerformanceMode>HIGH</IODelayHighPerformanceMode>
     <InternalVref>0</InternalVref>
     <Controller number="0" >
-        <MemoryDevice>DDR3_SDRAM/SODIMMs/MT4JSF6464HY-1G1</MemoryDevice>
+        <MemoryDevice>DDR3_SDRAM/SODIMMs/MT4JSF12864HZ-1G4</MemoryDevice>
         <TimePeriod>2500</TimePeriod>
         <DataWidth>64</DataWidth>
         <DeepMemory>1</DeepMemory>
         <DataMask>1</DataMask>
         <CustomPart>FALSE</CustomPart>
         <NewPartName></NewPartName>
-        <RowAddress>13</RowAddress>
+        <RowAddress>14</RowAddress>
         <ColAddress>10</ColAddress>
         <BankAddress>3</BankAddress>
         <MasterBanks>25</MasterBanks>
@@ -47,6 +47,7 @@
             <Pin SignalName="ddr3_addr[10]" PINNumber="M16" SignalGroup="Address" Bank="36" />
             <Pin SignalName="ddr3_addr[11]" PINNumber="M15" SignalGroup="Address" Bank="36" />
             <Pin SignalName="ddr3_addr[12]" PINNumber="H15" SignalGroup="Address" Bank="36" />
+            <Pin SignalName="ddr3_addr[13]" PINNumber="J15" SignalGroup="Address" Bank="36" />
             <Pin SignalName="ddr3_addr[1]" PINNumber="A16" SignalGroup="Address" Bank="36" />
             <Pin SignalName="ddr3_addr[2]" PINNumber="B16" SignalGroup="Address" Bank="36" />
             <Pin SignalName="ddr3_addr[3]" PINNumber="E16" SignalGroup="Address" Bank="36" />
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp_mig39.ucf work/leon3mp_mig39.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp_mig39.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/leon3mp_mig39.ucf	2017-02-02 13:18:09.982630355 +0100
@@ -1,160 +1,256 @@
-
-NET "clk_ref_p" TNM_NET = TNM_clk_ref;
-TIMESPEC "TS_clk_ref" = PERIOD "TNM_clk_ref" 5 ns ;
-
-NET "reset" IOSTANDARD = SSTL15;
-NET "reset" LOC = "H10";
-NET "errorn" LOC = "AD24";
-
-NET "address(0)"                      LOC = "AL8";    ## 29 on U4, A1 on U27
-NET "address(1)"                      LOC = "AK8";    ## 25 on U4, B1 on U27
-NET "address(2)"                      LOC = "AC9";    ## 24 on U4, C1 on U27
-NET "address(3)"                      LOC = "AD10";   ## 23 on U4, D1 on U27
-NET "address(4)"                      LOC = "C8";     ## 22 on U4, D2 on U27
-NET "address(5)"                      LOC = "B8";     ## 21 on U4, A2 on U27
-NET "address(6)"                      LOC = "E9";     ## 20 on U4, C2 on U27
-NET "address(7)"                      LOC = "E8";     ## 19 on U4, A3 on U27
-NET "address(8)"                      LOC = "A8";     ## 8  on U4, B3 on U27
-NET "address(9)"                      LOC = "A9";     ## 7  on U4, C3 on U27
-NET "address(10)"                     LOC = "D9";     ## 6  on U4, D3 on U27
-NET "address(11)"                     LOC = "C9";     ## 5  on U4, C4 on U27
-NET "address(12)"                     LOC = "D10";    ## 4  on U4, A5 on U27
-NET "address(13)"                     LOC = "C10";    ## 3  on U4, B5 on U27
-NET "address(14)"                     LOC = "F10";    ## 2  on U4, C5 on U27
-NET "address(15)"                     LOC = "F9";     ## 1  on U4, D7 on U27
-NET "address(16)"                     LOC = "AH8";    ## 55 on U4, D8 on U27
-NET "address(17)"                     LOC = "AG8";    ## 18 on U4, A7 on U27
-NET "address(18)"                     LOC = "AP9";    ## 17 on U4, B7 on U27
-NET "address(19)"                     LOC = "AN9";    ## 16 on U4, C7 on U27
-NET "address(20)"                     LOC = "AF10";   ## 11 on U4, C8 on U27
-NET "address(21)"                     LOC = "AF9";    ## 10 on U4, A8 on U27
-NET "address(22)"                     LOC = "AL9";    ## 9  on U4, G1 on U27
-NET "address(23)"                     LOC = "AA23";   ## 26 on U4
-NET "data(0)"                      LOC = "AF24";   ## 34 on U4, F2 on U27
-NET "data(1)"                      LOC = "AF25";   ## 36 on U4, E2 on U27
-NET "data(2)"                      LOC = "W24";    ## 39 on U4, G3 on U27
-NET "data(3)"                      LOC = "V24";    ## 41 on U4, E4 on U27
-NET "data(4)"                      LOC = "H24";    ## 47 on U4, E5 on U27
-NET "data(5)"                      LOC = "H25";    ## 49 on U4, G5 on U27
-NET "data(6)"                      LOC = "P24";    ## 51 on U4, G6 on U27
-NET "data(7)"                      LOC = "R24";    ## 53 on U4, H7 on U27
-NET "data(8)"                      LOC = "G23";    ## 35 on U4, E1 on U27
-NET "data(9)"                      LOC = "H23";    ## 37 on U4, E3 on U27
-NET "data(10)"                     LOC = "N24";    ## 40 on U4, F3 on U27
-NET "data(11)"                     LOC = "N23";    ## 42 on U4, F4 on U27
-NET "data(12)"                     LOC = "F23";    ## 48 on U4, F5 on U27
-NET "data(13)"                     LOC = "F24";    ## 50 on U4, H5 on U27
-NET "data(14)"                     LOC = "L24";    ## 52 on U4, G7 on U27
-NET "data(15)"                     LOC = "M23";    ## 54 on U4, E7 on U27
-#NET "FLASH_WAIT"                    LOC = "J26";    ## 56 on U4
-NET "writen"                    LOC = "AF23";   ## 14 on U4, G8 on U27
-NET "oen"                    LOC = "AA24";   ## 32 on U4, F8 on U27
-#NET "FPGA_CCLK"                     LOC = "K8";     ##           F1 on U27
-NET "alatch"                 LOC = "AC23";   ##           H1 on U27
-NET "romsn"                    LOC = "Y24";    ## 30 on U4, B4 on U27 (U10 and switch S2.2 setting select either U4 or U27)
-##
-
-NET "erx_col"                       LOC = "AK13";   ## 114 on U80
-NET "erx_crs"                       LOC = "AL13";   ## 115 on U80
-NET "emdint"                       LOC = "AH14";   ## 32  on U80
-NET "emdc"                       LOC = "AP14";   ## 35  on U80
-NET "emdio"                      LOC = "AN14";   ## 33  on U80
-NET "erstn"                     LOC = "AH13";   ## 36  on U80
-NET "erx_clk"                     LOC = "AP11";   ## 7   on U80
-NET "erx_dv"                LOC = "AM13";   ## 4   on U80
-NET "erxd(0)"                      LOC = "AN13";   ## 3   on U80
-NET "erxd(1)"                      LOC = "AF14";   ## 128 on U80
-NET "erxd(2)"                      LOC = "AE14";   ## 126 on U80
-NET "erxd(3)"                      LOC = "AN12";   ## 125 on U80
-NET "erxd(4)"                      LOC = "AM12";   ## 124 on U80
-NET "erxd(5)"                      LOC = "AD11";   ## 123 on U80
-NET "erxd(6)"                      LOC = "AC12";   ## 121 on U80
-NET "erxd(7)"                      LOC = "AC13";   ## 120 on U80
-NET "erx_er"                      LOC = "AG12";   ## 9   on U80
-NET "etx_clk"                     LOC = "AD12";   ## 10  on U80
-NET "etx_en"                LOC = "AJ10";   ## 16  on U80
-NET "egtx_clk"                LOC = "AH12";   ## 14  on U80
-NET "etxd(0)"                      LOC = "AM11";   ## 18  on U80
-NET "etxd(1)"                      LOC = "AL11";   ## 19  on U80
-NET "etxd(2)"                      LOC = "AG10";   ## 20  on U80
-NET "etxd(3)"                      LOC = "AG11";   ## 24  on U80
-NET "etxd(4)"                      LOC = "AL10";   ## 25  on U80
-NET "etxd(5)"                      LOC = "AM10";   ## 26  on U80
-NET "etxd(6)"                      LOC = "AE11";   ## 28  on U80
-NET "etxd(7)"                      LOC = "AF11";   ## 29  on U80
-NET "etx_er"                      LOC = "AH10";   ## 13  on U80
-
-NET "dsurx"                      LOC = "J24";    ## 24  on U34
-NET "dsutx"                      LOC = "J25";    ## 25  on U34
-
-#NET "GPIO_DIP_SW1"                  LOC = "D22";    ## 1   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW2"                  LOC = "C22";    ## 2   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW3"                  LOC = "L21";    ## 3   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW4"                  LOC = "L20";    ## 4   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW5"                  LOC = "C18";    ## 5   on SW1 DIP switch (active-high)
-NET "dsubre"                  LOC = "B18";    ## 6   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW7"                  LOC = "K22";    ## 7   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW8"                  LOC = "K21";    ## 8   on SW1 DIP switch (active-high)
-##
-
-NET "led(0)"                    LOC = "AC22";   ## 2   on LED DS12, 1 on J62
-NET "led(1)"                    LOC = "AC24";   ## 2   on LED DS11, 2 on J62
-NET "led(2)"                    LOC = "AE22";   ## 2   on LED DS9,  3 on J62
-NET "led(3)"                    LOC = "AE23";   ## 2   on LED DS10, 4 on J62
-NET "led(4)"                    LOC = "AB23";   ## 2   on LED DS15, 5 on J62
-NET "led(5)"                    LOC = "AG23";   ## 2   on LED DS14, 6 on J62
-NET "led(6)"                    LOC = "AE24";   ## 2   on LED DS22, 7 on J62
-#NET "led(7)"                    LOC = "AD24";   ## 2   on LED DS21, 8 on J62
-
-NET "dvi_iic_scl"                   LOC = "AN10";   ## 2   on Q5, 15 on U38
-NET "iic_scl_main"               LOC = "AK9";    ## 2   on Q19
-#NET "IIC_SCL_SFP"                   LOC = "AA34";   ## 2   on Q23
-NET "dvi_iic_sda"                   LOC = "AP10";   ## 2   on Q6, 14 on U38
-NET "iic_sda_main"               LOC = "AE9";    ## 2   on Q20
-#NET "IIC_SDA_SFP"                   LOC = "AA33";   ## 2   on Q21
-
-NET "tft_lcd_data(0)"                        LOC = "AJ19";   ## 63 on U38 (thru series R111 47.5 ohm)
-NET "tft_lcd_data(1)"                        LOC = "AH19";   ## 62 on U38 (thru series R110 47.5 ohm)
-NET "tft_lcd_data(2)"                        LOC = "AM17";   ## 61 on U38 (thru series R109 47.5 ohm)
-NET "tft_lcd_data(3)"                        LOC = "AM16";   ## 60 on U38 (thru series R108 47.5 ohm)
-NET "tft_lcd_data(4)"                        LOC = "AD17";   ## 59 on U38 (thru series R107 47.5 ohm)
-NET "tft_lcd_data(5)"                        LOC = "AE17";   ## 58 on U38 (thru series R106 47.5 ohm)
-NET "tft_lcd_data(6)"                        LOC = "AK18";   ## 55 on U38 (thru series R105 47.5 ohm)
-NET "tft_lcd_data(7)"                        LOC = "AK17";   ## 54 on U38 (thru series R104 47.5 ohm)
-NET "tft_lcd_data(8)"                        LOC = "AE18";   ## 53 on U38 (thru series R103 47.5 ohm)
-NET "tft_lcd_data(9)"                        LOC = "AF18";   ## 52 on U38 (thru series R102 47.5 ohm)
-NET "tft_lcd_data(10)"                       LOC = "AL16";   ## 51 on U38 (thru series R101 47.5 ohm)
-NET "tft_lcd_data(11)"                       LOC = "AK16";   ## 50 on U38 (thru series R100 47.5 ohm)
-NET "tft_lcd_de"                        LOC = "AD16";   ## 2  on U38 (thru series R112 47.5 ohm)
-#NET "DVI_GPIO1_FMC_C2M_PG_LS"       LOC = "K9";     ## 18 on U32 (not wired to U38)
-NET "tft_lcd_hsync"                         LOC = "AN17";   ## 4  on U38 (thru series R113 47.5 ohm)
-NET "tft_lcd_reset_b"                LOC = "AP17";   ## 2  on U32 (DVI_RESET_B pin 13 on U38)
-NET "tft_lcd_vsync"                         LOC = "AD15";   ## 5  on U38 (thru series R114 47.5 ohm)
-NET "tft_lcd_clk_n"                    LOC = "AC17";   ## 56 on U38
-NET "tft_lcd_clk_p"                    LOC = "AC18";   ## 57 on U38
-
-#NET "SYSACE_CFGTDI"                 LOC = "AC8";    ## 81  on U19
-NET "sysace_d(0)"                     LOC = "AM15";   ## 66  on U19
-NET "sysace_d(1)"                     LOC = "AJ17";   ## 65  on U19
-NET "sysace_d(2)"                     LOC = "AJ16";   ## 63  on U19
-NET "sysace_d(3)"                     LOC = "AP16";   ## 62  on U19
-NET "sysace_d(4)"                     LOC = "AG16";   ## 61  on U19
-NET "sysace_d(5)"                     LOC = "AH15";   ## 60  on U19
-NET "sysace_d(6)"                     LOC = "AF16";   ## 59  on U19
-NET "sysace_d(7)"                     LOC = "AN15";   ## 58  on U19
-NET "sysace_mpa(0)"                  LOC = "AC15";   ## 70  on U19
-NET "sysace_mpa(1)"                  LOC = "AP15";   ## 69  on U19
-NET "sysace_mpa(2)"                  LOC = "AG17";   ## 68  on U19
-NET "sysace_mpa(3)"                  LOC = "AH17";   ## 67  on U19
-NET "sysace_mpa(4)"                  LOC = "AG15";   ## 45  on U19
-NET "sysace_mpa(5)"                  LOC = "AF15";   ## 44  on U19
-NET "sysace_mpa(6)"                  LOC = "AK14";   ## 43  on U19
-#NET "SYSACE_MPBRDY"                 LOC = "AJ15";   ## 39  on U19
-NET "sysace_mpce"                   LOC = "AJ14";   ## 42  on U19
-NET "sysace_mpirq"                  LOC = "L9";     ## 41  on U19
-NET "sysace_mpoe"                   LOC = "AL15";   ## 77  on U19
-NET "sysace_mpwe"                   LOC = "AL14";   ## 76  on U19
-NET "clk_33"              LOC = "AE16";   ## 93  on U19
+######################################################################################
+## PCI-express signals (copied from reference project)                              ##
+######################################################################################
+#------------------------
+# Clock and Reset Pinout
+#------------------------
+NET "pcie_dma_block.pcie_dma/pcie_ref_clk" TNM_NET = "SYSCLK" ;
+NET "*/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
+NET "*/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
+
+TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 250.00 MHz HIGH 50 % ;
+TIMESPEC "TS_CLK_125" = PERIOD "CLK_125" TS_SYSCLK*0.5 HIGH 50 %; # PRIORITY 100 ;
+TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 250 MHz HIGH 50 %; # PRIORITY 100 ;
+
+NET "sys_reset_n" TIG;
+PIN "*/trn_reset_n_int_i.CLR" TIG ;
+PIN "*/trn_reset_n_i.CLR" TIG ;
+PIN "*/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
+
+#TIMESPEC "TS_TRNLNKUPN" = FROM FFS(*) TO FFS(trn_lnk_up_n_int_i) 4 ns;
+#TIMESPEC "TS_RESETN" = FROM FFS(*) TO FFS(trn_reset_n_i) 4 ns;
+TIMESPEC "TS_RESETN" = FROM FFS(*) TO FFS("pcie_dma_block.pcie_dma/user_reset") 8 ns;
+
+
+#-----------------------------------
+# PCIe Transceiver & Core Locations
+#-----------------------------------
+
+# PCIe Block Placement
+INST "*/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
+
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[0].GTX" LOC = GTXE1_X0Y15;
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[1].GTX" LOC = GTXE1_X0Y14;
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[2].GTX" LOC = GTXE1_X0Y13;
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[3].GTX" LOC = GTXE1_X0Y12;
+
+#------------------------
+# Clock and Reset Pinout
+#------------------------
+
+NET  sys_reset_n           LOC  = AE13 | IOSTANDARD = LVCMOS25 | NODELAY;
+
+# 250 MHz Reference Clock
+INST "pcie_dma_block.pcie_dma/pcie_refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y4; # Implies pinout
+
+# MMCM Placment. This constraint selects the MMCM Placement
+INST "*/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
+
+######################################################################################
+## Other definitions                                                                ##
+######################################################################################
+
+
+NET "clk_ref_p" TNM_NET = TNM_clk_ref;
+TIMESPEC "TS_clk_ref" = PERIOD "TNM_clk_ref" 5 ns ;
+
+NET "reset" IOSTANDARD = SSTL15;
+NET "reset" LOC = "H10";
+#NET "errorn" LOC = "AD24";
+
+NET "address(0)"                      LOC = "AL8";    ## 29 on U4, A1 on U27
+NET "address(1)"                      LOC = "AK8";    ## 25 on U4, B1 on U27
+NET "address(2)"                      LOC = "AC9";    ## 24 on U4, C1 on U27
+NET "address(3)"                      LOC = "AD10";   ## 23 on U4, D1 on U27
+NET "address(4)"                      LOC = "C8";     ## 22 on U4, D2 on U27
+NET "address(5)"                      LOC = "B8";     ## 21 on U4, A2 on U27
+NET "address(6)"                      LOC = "E9";     ## 20 on U4, C2 on U27
+NET "address(7)"                      LOC = "E8";     ## 19 on U4, A3 on U27
+NET "address(8)"                      LOC = "A8";     ## 8  on U4, B3 on U27
+NET "address(9)"                      LOC = "A9";     ## 7  on U4, C3 on U27
+NET "address(10)"                     LOC = "D9";     ## 6  on U4, D3 on U27
+NET "address(11)"                     LOC = "C9";     ## 5  on U4, C4 on U27
+NET "address(12)"                     LOC = "D10";    ## 4  on U4, A5 on U27
+NET "address(13)"                     LOC = "C10";    ## 3  on U4, B5 on U27
+NET "address(14)"                     LOC = "F10";    ## 2  on U4, C5 on U27
+NET "address(15)"                     LOC = "F9";     ## 1  on U4, D7 on U27
+NET "address(16)"                     LOC = "AH8";    ## 55 on U4, D8 on U27
+NET "address(17)"                     LOC = "AG8";    ## 18 on U4, A7 on U27
+NET "address(18)"                     LOC = "AP9";    ## 17 on U4, B7 on U27
+NET "address(19)"                     LOC = "AN9";    ## 16 on U4, C7 on U27
+NET "address(20)"                     LOC = "AF10";   ## 11 on U4, C8 on U27
+NET "address(21)"                     LOC = "AF9";    ## 10 on U4, A8 on U27
+NET "address(22)"                     LOC = "AL9";    ## 9  on U4, G1 on U27
+NET "address(23)"                     LOC = "AA23";   ## 26 on U4
+NET "data(0)"                      LOC = "AF24";   ## 34 on U4, F2 on U27
+NET "data(1)"                      LOC = "AF25";   ## 36 on U4, E2 on U27
+NET "data(2)"                      LOC = "W24";    ## 39 on U4, G3 on U27
+NET "data(3)"                      LOC = "V24";    ## 41 on U4, E4 on U27
+NET "data(4)"                      LOC = "H24";    ## 47 on U4, E5 on U27
+NET "data(5)"                      LOC = "H25";    ## 49 on U4, G5 on U27
+NET "data(6)"                      LOC = "P24";    ## 51 on U4, G6 on U27
+NET "data(7)"                      LOC = "R24";    ## 53 on U4, H7 on U27
+NET "data(8)"                      LOC = "G23";    ## 35 on U4, E1 on U27
+NET "data(9)"                      LOC = "H23";    ## 37 on U4, E3 on U27
+NET "data(10)"                     LOC = "N24";    ## 40 on U4, F3 on U27
+NET "data(11)"                     LOC = "N23";    ## 42 on U4, F4 on U27
+NET "data(12)"                     LOC = "F23";    ## 48 on U4, F5 on U27
+NET "data(13)"                     LOC = "F24";    ## 50 on U4, H5 on U27
+NET "data(14)"                     LOC = "L24";    ## 52 on U4, G7 on U27
+NET "data(15)"                     LOC = "M23";    ## 54 on U4, E7 on U27
+#NET "FLASH_WAIT"                    LOC = "J26";    ## 56 on U4
+NET "writen"                    LOC = "AF23";   ## 14 on U4, G8 on U27
+NET "oen"                    LOC = "AA24";   ## 32 on U4, F8 on U27
+#NET "FPGA_CCLK"                     LOC = "K8";     ##           F1 on U27
+NET "alatch"                 LOC = "AC23";   ##           H1 on U27
+NET "romsn"                    LOC = "Y24";    ## 30 on U4, B4 on U27 (U10 and switch S2.2 setting select either U4 or U27)
+##
+
+NET "erx_col"                       LOC = "AK13";   ## 114 on U80
+NET "erx_crs"                       LOC = "AL13";   ## 115 on U80
+NET "emdint"                       LOC = "AH14";   ## 32  on U80
+NET "emdc"                       LOC = "AP14";   ## 35  on U80
+NET "emdio"                      LOC = "AN14";   ## 33  on U80
+NET "erstn"                     LOC = "AH13";   ## 36  on U80
+NET "erx_clk"                     LOC = "AP11";   ## 7   on U80
+NET "erx_dv"                LOC = "AM13";   ## 4   on U80
+NET "erxd(0)"                      LOC = "AN13";   ## 3   on U80
+NET "erxd(1)"                      LOC = "AF14";   ## 128 on U80
+NET "erxd(2)"                      LOC = "AE14";   ## 126 on U80
+NET "erxd(3)"                      LOC = "AN12";   ## 125 on U80
+NET "erxd(4)"                      LOC = "AM12";   ## 124 on U80
+NET "erxd(5)"                      LOC = "AD11";   ## 123 on U80
+NET "erxd(6)"                      LOC = "AC12";   ## 121 on U80
+NET "erxd(7)"                      LOC = "AC13";   ## 120 on U80
+NET "erx_er"                      LOC = "AG12";   ## 9   on U80
+NET "etx_clk"                     LOC = "AD12";   ## 10  on U80
+NET "etx_en"                LOC = "AJ10";   ## 16  on U80
+NET "egtx_clk"                LOC = "AH12";   ## 14  on U80
+NET "etxd(0)"                      LOC = "AM11";   ## 18  on U80
+NET "etxd(1)"                      LOC = "AL11";   ## 19  on U80
+NET "etxd(2)"                      LOC = "AG10";   ## 20  on U80
+NET "etxd(3)"                      LOC = "AG11";   ## 24  on U80
+NET "etxd(4)"                      LOC = "AL10";   ## 25  on U80
+NET "etxd(5)"                      LOC = "AM10";   ## 26  on U80
+NET "etxd(6)"                      LOC = "AE11";   ## 28  on U80
+NET "etxd(7)"                      LOC = "AF11";   ## 29  on U80
+NET "etx_er"                      LOC = "AH10";   ## 13  on U80
+
+NET "dsurx"                      LOC = "J24";    ## 24  on U34
+NET "dsutx"                      LOC = "J25";    ## 25  on U34
+
+#NET "GPIO_DIP_SW1"                  LOC = "D22";    ## 1   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW2"                  LOC = "C22";    ## 2   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW3"                  LOC = "L21";    ## 3   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW4"                  LOC = "L20";    ## 4   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW5"                  LOC = "C18";    ## 5   on SW1 DIP switch (active-high)
+NET "dsubre"                  LOC = "B18";    ## 6   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW7"                  LOC = "K22";    ## 7   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW8"                  LOC = "K21";    ## 8   on SW1 DIP switch (active-high)
+##
+
+# LCD display connector abused as GPIO.
+NET "gpio(0)"                    LOC = "T28";   ## RS
+NET "gpio(1)"                    LOC = "AC14";  ## RW
+NET "gpio(2)"                    LOC = "AK12";  ## E
+NET "gpio(3)"                    LOC = "AD14";  ## DB4
+NET "gpio(4)"                    LOC = "AK11";  ## DB5
+NET "gpio(5)"                    LOC = "AJ11";  ## DB6
+NET "gpio(6)"                    LOC = "AE12";  ## DB7
+NET "gpio(*)"                    IOSTANDARD = LVCMOS25;
+
+# LEDs.
+NET "led(0)"                    LOC = "AC22";   ## 1
+NET "led(1)"                    LOC = "AC24";   ## 2
+NET "led(2)"                    LOC = "AE22";   ## 3
+NET "led(3)"                    LOC = "AE23";   ## 4
+NET "led(4)"                    LOC = "AB23";   ## 5
+NET "led(5)"                    LOC = "AG23";   ## 6
+NET "led(6)"                    LOC = "AE24";   ## 7
+NET "led(7)"                    LOC = "AD24";   ## 8
+NET "led(8)"                    LOC = "AP24";   ## C
+NET "led(9)"                    LOC = "AD21";   ## W
+NET "led(10)"                   LOC = "AE21";   ## E
+NET "led(11)"                   LOC = "AH28";   ## S
+NET "led(12)"                   LOC = "AH27";   ## N
+NET "led(*)"                    IOSTANDARD = LVCMOS25;
+
+# GPIO switches.
+NET "dipsw(0)"                   LOC = "D22";   ## 1
+NET "dipsw(1)"                   LOC = "C22";   ## 2
+NET "dipsw(2)"                   LOC = "L21";   ## 3
+NET "dipsw(3)"                   LOC = "L20";   ## 4
+NET "dipsw(4)"                   LOC = "C18";   ## 5
+NET "dipsw(5)"                   LOC = "B18";   ## 6
+NET "dipsw(6)"                   LOC = "K22";   ## 7
+NET "dipsw(7)"                   LOC = "K21";   ## 8
+NET "dipsw(*)"                   IOSTANDARD = LVCMOS15;
+
+# Pushbuttons (except reset).
+NET "pbtn(0)"                    LOC = "G26";   ## C
+NET "pbtn(1)"                    LOC = "H17";   ## W
+NET "pbtn(2)"                    LOC = "G17";   ## E
+NET "pbtn(3)"                    LOC = "A18";   ## S
+NET "pbtn(4)"                    LOC = "A19";   ## N
+NET "pbtn(*)"                    IOSTANDARD = LVCMOS15;
+
+NET "dvi_iic_scl"                   LOC = "AN10";   ## 2   on Q5, 15 on U38
+NET "iic_scl_main"               LOC = "AK9";    ## 2   on Q19
+#NET "IIC_SCL_SFP"                   LOC = "AA34";   ## 2   on Q23
+NET "dvi_iic_sda"                   LOC = "AP10";   ## 2   on Q6, 14 on U38
+NET "iic_sda_main"               LOC = "AE9";    ## 2   on Q20
+#NET "IIC_SDA_SFP"                   LOC = "AA33";   ## 2   on Q21
+
+# PMBUS IIC interface
+NET pmbus_sda LOC=AB10;
+NET pmbus_sda SLEW = SLOW;
+NET pmbus_sda DRIVE = 6;
+NET pmbus_scl LOC=AC10;
+NET pmbus_scl SLEW = SLOW;
+NET pmbus_scl DRIVE = 6;
+
+NET "tft_lcd_data(0)"                        LOC = "AJ19";   ## 63 on U38 (thru series R111 47.5 ohm)
+NET "tft_lcd_data(1)"                        LOC = "AH19";   ## 62 on U38 (thru series R110 47.5 ohm)
+NET "tft_lcd_data(2)"                        LOC = "AM17";   ## 61 on U38 (thru series R109 47.5 ohm)
+NET "tft_lcd_data(3)"                        LOC = "AM16";   ## 60 on U38 (thru series R108 47.5 ohm)
+NET "tft_lcd_data(4)"                        LOC = "AD17";   ## 59 on U38 (thru series R107 47.5 ohm)
+NET "tft_lcd_data(5)"                        LOC = "AE17";   ## 58 on U38 (thru series R106 47.5 ohm)
+NET "tft_lcd_data(6)"                        LOC = "AK18";   ## 55 on U38 (thru series R105 47.5 ohm)
+NET "tft_lcd_data(7)"                        LOC = "AK17";   ## 54 on U38 (thru series R104 47.5 ohm)
+NET "tft_lcd_data(8)"                        LOC = "AE18";   ## 53 on U38 (thru series R103 47.5 ohm)
+NET "tft_lcd_data(9)"                        LOC = "AF18";   ## 52 on U38 (thru series R102 47.5 ohm)
+NET "tft_lcd_data(10)"                       LOC = "AL16";   ## 51 on U38 (thru series R101 47.5 ohm)
+NET "tft_lcd_data(11)"                       LOC = "AK16";   ## 50 on U38 (thru series R100 47.5 ohm)
+NET "tft_lcd_de"                        LOC = "AD16";   ## 2  on U38 (thru series R112 47.5 ohm)
+#NET "DVI_GPIO1_FMC_C2M_PG_LS"       LOC = "K9";     ## 18 on U32 (not wired to U38)
+NET "tft_lcd_hsync"                         LOC = "AN17";   ## 4  on U38 (thru series R113 47.5 ohm)
+NET "tft_lcd_reset_b"                LOC = "AP17";   ## 2  on U32 (DVI_RESET_B pin 13 on U38)
+NET "tft_lcd_vsync"                         LOC = "AD15";   ## 5  on U38 (thru series R114 47.5 ohm)
+NET "tft_lcd_clk_n"                    LOC = "AC17";   ## 56 on U38
+NET "tft_lcd_clk_p"                    LOC = "AC18";   ## 57 on U38
+
+#NET "SYSACE_CFGTDI"                 LOC = "AC8";    ## 81  on U19
+NET "sysace_d(0)"                     LOC = "AM15";   ## 66  on U19
+NET "sysace_d(1)"                     LOC = "AJ17";   ## 65  on U19
+NET "sysace_d(2)"                     LOC = "AJ16";   ## 63  on U19
+NET "sysace_d(3)"                     LOC = "AP16";   ## 62  on U19
+NET "sysace_d(4)"                     LOC = "AG16";   ## 61  on U19
+NET "sysace_d(5)"                     LOC = "AH15";   ## 60  on U19
+NET "sysace_d(6)"                     LOC = "AF16";   ## 59  on U19
+NET "sysace_d(7)"                     LOC = "AN15";   ## 58  on U19
+NET "sysace_mpa(0)"                  LOC = "AC15";   ## 70  on U19
+NET "sysace_mpa(1)"                  LOC = "AP15";   ## 69  on U19
+NET "sysace_mpa(2)"                  LOC = "AG17";   ## 68  on U19
+NET "sysace_mpa(3)"                  LOC = "AH17";   ## 67  on U19
+NET "sysace_mpa(4)"                  LOC = "AG15";   ## 45  on U19
+NET "sysace_mpa(5)"                  LOC = "AF15";   ## 44  on U19
+NET "sysace_mpa(6)"                  LOC = "AK14";   ## 43  on U19
+#NET "SYSACE_MPBRDY"                 LOC = "AJ15";   ## 39  on U19
+NET "sysace_mpce"                   LOC = "AJ14";   ## 42  on U19
+NET "sysace_mpirq"                  LOC = "L9";     ## 41  on U19
+NET "sysace_mpoe"                   LOC = "AL15";   ## 77  on U19
+NET "sysace_mpwe"                   LOC = "AL14";   ## 76  on U19
+NET "clk_33"              LOC = "AE16";   ## 93  on U19
 NET "clk_33" PERIOD = 30.000 ;
 OFFSET = IN : 20.000 : BEFORE clk_33 ;
 OFFSET = OUT : 20.000 : AFTER clk_33 ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.ucf work/leon3mp.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/leon3mp.ucf	2017-02-02 13:18:09.986630320 +0100
@@ -1,544 +1,579 @@
-############################################################################
-## 
-##  Xilinx, Inc. 2006            www.xilinx.com 
-##  Mon Aug 30 10:34:47 2010
-##  Generated by MIG Version 3.6
-##  
-############################################################################
-##  File name :       example_top.ucf
-## 
-##  Details :     Constraints file
-##                    FPGA family:       virtex6
-##                    FPGA:              xc6vlx240t-ff1156
-##                    Speedgrade:        -1
-##                    Design Entry:      VERILOG
-##                    Design:            with Test bench
-##                    No.Of Controllers: 1
-##
-############################################################################ 
-##  Modifications for ML605 with LX240T FPGA
-##  Start with UCF file generated by MIG 3.4 (ISE 12.1 build M.53.d)
-##     
-##  1. Majority of ML605 board specific pin assignments entered via MIG3.4 GUI!
-##     A. Add LOC and IOSTANDARD for LED indicator "heartbeat" 
-##     B. Add LOC and IOSTANDARD for LED indicator "pll_lock" 
-##     C. Comment out "sda" and "scl" signals 
-##     D. ML605 DCI_CASCADE is correct as defined in MIG3.4 GUI.
-##        BANK 26 = left column I/O master; BANK 36 = right column I/O master 
-##  2. Change IOSTANDARD for sys_rst to SSTL15 
-##  3. Board specific clocking definitions
-##     A. Default MIG 3.5 example design assumes 2 clock inputs to design:
-##        1. clk_ref to IDELAY_CTRL element (200 MHz)
-##        2. sys_clk to PLL circuit (SMA inputs)
-##     B. ML605 single clock source, modify constraint file to use 200 MHz 
-##        LVDS clock "clk_ref" input for DDR3 SODIMM design @800 Mbps data rate. 
-##        - Delete sys_clk_p and sys_clk_n inputs (HDL and LOC constraints)
-##        - Comment out sys_clk timing specification
-##        - Modify TS_MC_PHY_INIT_SEL to use value "2.5 ns" in multiplication 
-##  4. Optional: comment out CONFIG_PROHIBIT lines (pins reserved for MIG)
-##     Since this design has LOC'ed I/O don't need to reserve these pins.
-##  5. ML605 MIG3.4 BUFIO pin assignments
-##         BUFIO:0 pin C13 => X2Y137
-##         BUFIO:1 pin L13 => X2Y141
-##         BUFIO:2 pin K14 => X2Y143
-##         BUFIO:3 pin F21 => X1Y179
-##         BUFIO:4 pin B20 => X1Y181
-##         BUFIO:5 pin F25 => X1Y137
-##         BUFIO:6 pin C28 => X1Y141
-##         BUFIO:7 pin D24 => X1Y143
-##  6. ML605 MIG3.4 BUFR pin assignments
-##         BUFR:0 pin M12 => X2Y139
-##         BUFR:1 pin C29 => X1Y139
-##
-############################################################################
-# Timing constraints                                                        #
-############################################################################
-## ML605 comment out the following 2 lines for single 200MHz input clock
-## NET "sys_clk_p" TNM_NET = TNM_sys_clk;
-## TIMESPEC "TS_sys_clk" = PERIOD "TNM_sys_clk" 2.5 ns;
-
-NET "clk_ref_p" TNM_NET = TNM_clk_ref;
-TIMESPEC "TS_clk_ref" = PERIOD "TNM_clk_ref" 5 ns ;
-
-# Constrain BUFR clocks used to synchronize data from IOB to fabric logic
-# Note that ISE cannot infer this from other PERIOD constraints because
-# of the use of OSERDES blocks in the BUFR clock generation path
-NET "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/clk_rsync(?)" TNM_NET = TNM_clk_rsync;
-TIMESPEC "TS_clk_rsync" = PERIOD "TNM_clk_rsync" 5 ns;
-
-# Paths between DQ/DQS ISERDES.Q outputs and CLB flops clocked by falling 
-# edge of BUFR will by design only be used if DYNCLKDIVSEL is asserted for 
-# that particular flop. Mark this path as being a full-cycle, rather than 
-# a half cycle path for timing purposes. NOTE: This constraint forces full-
-# cycle timing to be applied globally for all rising->falling edge paths 
-# in all resynchronizaton clock domains. If the user had modified the logic
-# in the resync clock domain such that other rising->falling edge paths 
-# exist, then constraint below should be modified to utilize pattern 
-# matching to specific affect only the DQ/DQS ISERDES.Q outputs
-TIMEGRP "TG_clk_rsync_rise" = RISING  "TNM_clk_rsync";
-TIMEGRP "TG_clk_rsync_fall" = FALLING "TNM_clk_rsync";
-TIMESPEC "TS_clk_rsync_rise_to_fall" = 
-  FROM "TG_clk_rsync_rise" TO "TG_clk_rsync_fall" "TS_sys_clk" * 2;
-
-# Signal to select between controller and physical layer signals. Four divided by two clock
-# cycles (8 memory clock cycles) are provided by design for the signal to settle down.
-# Used only by the phy modules.
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
-TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = 10 ns;  ## = "2.5ns * 4" ML605 single clock
-
-disable = reg_sr_o;
-disable = reg_sr_r;
-############################################################################
-########################################################################
-# Controller 0
-# Memory Device: DDR3_SDRAM->SODIMMs->MT4JSF6464HY-1G1
-# Data Width:     64
-# Frequency:      400
-# Time Period:      2500
-# Data Mask:     1
-########################################################################
-
-
-################################################################################
-# I/O STANDARDS
-################################################################################
-
-NET  "ddr3_dq(*)"                               IOSTANDARD = SSTL15_T_DCI;
-NET  "ddr3_addr(*)"                             IOSTANDARD = SSTL15;
-NET  "ddr3_ba(*)"                               IOSTANDARD = SSTL15;
-NET  "ddr3_ras_n"                               IOSTANDARD = SSTL15;
-NET  "ddr3_cas_n"                               IOSTANDARD = SSTL15;
-NET  "ddr3_we_n"                                IOSTANDARD = SSTL15;
-NET  "ddr3_reset_n"                             IOSTANDARD = SSTL15;
-NET  "ddr3_cke(*)"                              IOSTANDARD = SSTL15;
-NET  "ddr3_odt(*)"                              IOSTANDARD = SSTL15;
-NET  "ddr3_cs_n(*)"                             IOSTANDARD = SSTL15;
-NET  "ddr3_dm(*)"                               IOSTANDARD = SSTL15;
-## NET  "sys_clk_p"                                IOSTANDARD = LVDS_25;
-## NET  "sys_clk_n"                                IOSTANDARD = LVDS_25;
-NET  "clk_ref_p"                                IOSTANDARD = LVDS_25;
-NET  "clk_ref_n"                                IOSTANDARD = LVDS_25;
-## NET  "sda"                                      IOSTANDARD = LVCMOS25;
-## NET  "scl"                                      IOSTANDARD = LVCMOS25;
-NET  "reset"                                  IOSTANDARD = SSTL15;      ## ML605 
-#NET  "phy_init_done"                            IOSTANDARD = LVCMOS25;
-NET  "errorn"                                    IOSTANDARD = LVCMOS25;
-NET  "ddr3_dqs_p(*)"                            IOSTANDARD = DIFF_SSTL15_T_DCI;
-NET  "ddr3_dqs_n(*)"                            IOSTANDARD = DIFF_SSTL15_T_DCI;
-NET  "ddr3_ck_p(*)"                             IOSTANDARD = DIFF_SSTL15;
-NET  "ddr3_ck_n(*)"                             IOSTANDARD = DIFF_SSTL15;
-
-################################################################################
-##SAVE attributes to reserve the pins
-################################################################################
-## NET  "sda"                                      S;
-## NET  "scl"                                      S;
-
-###############################################################################
-#DCI_CASCADING
-#Syntax : CONFIG DCI_CASCADE = "<master> <slave1> <slave2> ..";
-###############################################################################
-CONFIG DCI_CASCADE = "26 25";
-CONFIG DCI_CASCADE = "36 35";
-
-
-##################################################################################
-# Location Constraints
-##################################################################################
-NET  "ddr3_dq(0)"                                LOC = "J11" ;          #Bank 35
-NET  "ddr3_dq(1)"                                LOC = "E13" ;          #Bank 35
-NET  "ddr3_dq(2)"                                LOC = "F13" ;          #Bank 35
-NET  "ddr3_dq(3)"                                LOC = "K11" ;          #Bank 35
-NET  "ddr3_dq(4)"                                LOC = "L11" ;          #Bank 35
-NET  "ddr3_dq(5)"                                LOC = "K13" ;          #Bank 35
-NET  "ddr3_dq(6)"                                LOC = "K12" ;          #Bank 35
-NET  "ddr3_dq(7)"                                LOC = "D11" ;          #Bank 35
-NET  "ddr3_dq(8)"                                LOC = "M13" ;          #Bank 35
-NET  "ddr3_dq(9)"                                LOC = "J14" ;          #Bank 35
-NET  "ddr3_dq(10)"                               LOC = "B13" ;          #Bank 35
-NET  "ddr3_dq(11)"                               LOC = "B12" ;          #Bank 35
-NET  "ddr3_dq(12)"                               LOC = "G10" ;          #Bank 35
-NET  "ddr3_dq(13)"                               LOC = "M11" ;          #Bank 35
-NET  "ddr3_dq(14)"                               LOC = "C12" ;          #Bank 35
-NET  "ddr3_dq(15)"                               LOC = "A11" ;          #Bank 35
-NET  "ddr3_dq(16)"                               LOC = "G11" ;          #Bank 35
-NET  "ddr3_dq(17)"                               LOC = "F11" ;          #Bank 35
-NET  "ddr3_dq(18)"                               LOC = "D14" ;          #Bank 35
-NET  "ddr3_dq(19)"                               LOC = "C14" ;          #Bank 35
-NET  "ddr3_dq(20)"                               LOC = "G12" ;          #Bank 35
-NET  "ddr3_dq(21)"                               LOC = "G13" ;          #Bank 35
-NET  "ddr3_dq(22)"                               LOC = "F14" ;          #Bank 35
-NET  "ddr3_dq(23)"                               LOC = "H14" ;          #Bank 35
-NET  "ddr3_dq(24)"                               LOC = "C19" ;          #Bank 26
-NET  "ddr3_dq(25)"                               LOC = "G20" ;          #Bank 26
-NET  "ddr3_dq(26)"                               LOC = "E19" ;          #Bank 26
-NET  "ddr3_dq(27)"                               LOC = "F20" ;          #Bank 26
-NET  "ddr3_dq(28)"                               LOC = "A20" ;          #Bank 26
-NET  "ddr3_dq(29)"                               LOC = "A21" ;          #Bank 26
-NET  "ddr3_dq(30)"                               LOC = "E22" ;          #Bank 26
-NET  "ddr3_dq(31)"                               LOC = "E23" ;          #Bank 26
-NET  "ddr3_dq(32)"                               LOC = "G21" ;          #Bank 26
-NET  "ddr3_dq(33)"                               LOC = "B21" ;          #Bank 26
-NET  "ddr3_dq(34)"                               LOC = "A23" ;          #Bank 26
-NET  "ddr3_dq(35)"                               LOC = "A24" ;          #Bank 26
-NET  "ddr3_dq(36)"                               LOC = "C20" ;          #Bank 26
-NET  "ddr3_dq(37)"                               LOC = "D20" ;          #Bank 26
-NET  "ddr3_dq(38)"                               LOC = "J20" ;          #Bank 26
-NET  "ddr3_dq(39)"                               LOC = "G22" ;          #Bank 26
-NET  "ddr3_dq(40)"                               LOC = "D26" ;          #Bank 25
-NET  "ddr3_dq(41)"                               LOC = "F26" ;          #Bank 25
-NET  "ddr3_dq(42)"                               LOC = "B26" ;          #Bank 25
-NET  "ddr3_dq(43)"                               LOC = "E26" ;          #Bank 25
-NET  "ddr3_dq(44)"                               LOC = "C24" ;          #Bank 25
-NET  "ddr3_dq(45)"                               LOC = "D25" ;          #Bank 25
-NET  "ddr3_dq(46)"                               LOC = "D27" ;          #Bank 25
-NET  "ddr3_dq(47)"                               LOC = "C25" ;          #Bank 25
-NET  "ddr3_dq(48)"                               LOC = "C27" ;          #Bank 25
-NET  "ddr3_dq(49)"                               LOC = "B28" ;          #Bank 25
-NET  "ddr3_dq(50)"                               LOC = "D29" ;          #Bank 25
-NET  "ddr3_dq(51)"                               LOC = "B27" ;          #Bank 25
-NET  "ddr3_dq(52)"                               LOC = "G27" ;          #Bank 25
-NET  "ddr3_dq(53)"                               LOC = "A28" ;          #Bank 25
-NET  "ddr3_dq(54)"                               LOC = "E24" ;          #Bank 25
-NET  "ddr3_dq(55)"                               LOC = "G25" ;          #Bank 25
-NET  "ddr3_dq(56)"                               LOC = "F28" ;          #Bank 25
-NET  "ddr3_dq(57)"                               LOC = "B31" ;          #Bank 25
-NET  "ddr3_dq(58)"                               LOC = "H29" ;          #Bank 25
-NET  "ddr3_dq(59)"                               LOC = "H28" ;          #Bank 25
-NET  "ddr3_dq(60)"                               LOC = "B30" ;          #Bank 25
-NET  "ddr3_dq(61)"                               LOC = "A30" ;          #Bank 25
-NET  "ddr3_dq(62)"                               LOC = "E29" ;          #Bank 25
-NET  "ddr3_dq(63)"                               LOC = "F29" ;          #Bank 25
-NET  "ddr3_addr(12)"                             LOC = "H15" ;          #Bank 36
-NET  "ddr3_addr(11)"                             LOC = "M15" ;          #Bank 36
-NET  "ddr3_addr(10)"                             LOC = "M16" ;          #Bank 36
-NET  "ddr3_addr(9)"                              LOC = "F15" ;          #Bank 36
-NET  "ddr3_addr(8)"                              LOC = "G15" ;          #Bank 36
-NET  "ddr3_addr(7)"                              LOC = "B15" ;          #Bank 36
-NET  "ddr3_addr(6)"                              LOC = "A15" ;          #Bank 36
-NET  "ddr3_addr(5)"                              LOC = "J17" ;          #Bank 36
-NET  "ddr3_addr(4)"                              LOC = "D16" ;          #Bank 36
-NET  "ddr3_addr(3)"                              LOC = "E16" ;          #Bank 36
-NET  "ddr3_addr(2)"                              LOC = "B16" ;          #Bank 36
-NET  "ddr3_addr(1)"                              LOC = "A16" ;          #Bank 36
-NET  "ddr3_addr(0)"                              LOC = "L14" ;          #Bank 36
-NET  "ddr3_ba(2)"                                LOC = "L15" ;          #Bank 36
-NET  "ddr3_ba(1)"                                LOC = "J19" ;          #Bank 36
-NET  "ddr3_ba(0)"                                LOC = "K19" ;          #Bank 36
-NET  "ddr3_ras_n"                                LOC = "L19" ;          #Bank 36
-NET  "ddr3_cas_n"                                LOC = "C17" ;          #Bank 36
-NET  "ddr3_we_n"                                 LOC = "B17" ;          #Bank 36
-NET  "ddr3_reset_n"                              LOC = "E18" ;          #Bank 36
-NET  "ddr3_cke(0)"                               LOC = "M18" ;          #Bank 36
-NET  "ddr3_odt(0)"                               LOC = "F18" ;          #Bank 36
-NET  "ddr3_cs_n(0)"                              LOC = "K18" ;          #Bank 36
-NET  "ddr3_dm(0)"                                LOC = "E11" ;          #Bank 35
-NET  "ddr3_dm(1)"                                LOC = "B11" ;          #Bank 35
-NET  "ddr3_dm(2)"                                LOC = "E14" ;          #Bank 35
-NET  "ddr3_dm(3)"                                LOC = "D19" ;          #Bank 26
-NET  "ddr3_dm(4)"                                LOC = "B22" ;          #Bank 26
-NET  "ddr3_dm(5)"                                LOC = "A26" ;          #Bank 25
-NET  "ddr3_dm(6)"                                LOC = "A29" ;          #Bank 25
-NET  "ddr3_dm(7)"                                LOC = "A31" ;          #Bank 25
-## NET  "sys_clk_p"                                 LOC = "J9" ;          #Bank 34
-## NET  "sys_clk_n"                                 LOC = "H9" ;          #Bank 34
-NET  "clk_ref_p"                                 LOC = "J9" ;          #Bank 34
-NET  "clk_ref_n"                                 LOC = "H9" ;          #Bank 34
-## NET  "sda"                                       LOC = "F9" ;          #Bank 34
-## NET  "scl"                                       LOC = "F10" ;          #Bank 34
-NET  "reset"                                   LOC = "H10" ;          #ML605 CPU_RESET switch
-#NET  "phy_init_done"                             LOC = "AE23" ;         #ML605 GPIO LED 3
-NET  "errorn"                                     LOC = "AD24" ;         #ML605 GPIO LED 2
-NET  "ddr3_dqs_p(0)"                             LOC = "D12" ;          #Bank 35
-NET  "ddr3_dqs_n(0)"                             LOC = "E12" ;          #Bank 35
-NET  "ddr3_dqs_p(1)"                             LOC = "H12" ;          #Bank 35
-NET  "ddr3_dqs_n(1)"                             LOC = "J12" ;          #Bank 35
-NET  "ddr3_dqs_p(2)"                             LOC = "A13" ;          #Bank 35
-NET  "ddr3_dqs_n(2)"                             LOC = "A14" ;          #Bank 35
-NET  "ddr3_dqs_p(3)"                             LOC = "H19" ;          #Bank 26
-NET  "ddr3_dqs_n(3)"                             LOC = "H20" ;          #Bank 26
-NET  "ddr3_dqs_p(4)"                             LOC = "B23" ;          #Bank 26
-NET  "ddr3_dqs_n(4)"                             LOC = "C23" ;          #Bank 26
-NET  "ddr3_dqs_p(5)"                             LOC = "B25" ;          #Bank 25
-NET  "ddr3_dqs_n(5)"                             LOC = "A25" ;          #Bank 25
-NET  "ddr3_dqs_p(6)"                             LOC = "H27" ;          #Bank 25
-NET  "ddr3_dqs_n(6)"                             LOC = "G28" ;          #Bank 25
-NET  "ddr3_dqs_p(7)"                             LOC = "C30" ;          #Bank 25
-NET  "ddr3_dqs_n(7)"                             LOC = "D30" ;          #Bank 25
-NET  "ddr3_ck_p(0)"                              LOC = "G18" ;          #Bank 36
-NET  "ddr3_ck_n(0)"                              LOC = "H18" ;          #Bank 36
-
-
-##################################################################################################
-##The following locations must be reserved and cannot be used for external I/O because          ##
-##the I/O elements associated with these sites (IODELAY, OSERDES, and associated routing)       ##
-##are used to generate and route the clocks necessary for read data capture and synchronization ##
-##to the core clock domain. These pins should not be routed out on the user's PCB               ##
-##################################################################################################
-
-##################################################################################################
-##The logic of this pin is used internally to drive a BUFR in the column. This chosen pin must  ##
-##be a clock pin capable of spanning to all of the banks containing data bytes in the particular##
-##column. That is, all byte groups must be within +/- 1 bank of this pin. This pin cannot be    ##
-##used for other functions and should not be connected externally. If a different pin is chosen,##
-##he corresponding LOC constraint must also be changed.                                         ##
-##################################################################################################
-
-CONFIG PROHIBIT = C29,M12;
-
-######################################################################################
-##Place RSYNC OSERDES and IODELAY:                                                  ##
-######################################################################################
-
-##Site: C29 -- Bank 25
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_oserdes_rsync"
-  LOC = "OLOGIC_X1Y139";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_odelay_rsync"
-  LOC = "IODELAY_X1Y139";
-
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_bufr_rsync"
-  LOC = "BUFR_X1Y6";
-
-##Site: M12 -- Bank 35
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_oserdes_rsync"
-  LOC = "OLOGIC_X2Y139";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_odelay_rsync"
-  LOC = "IODELAY_X2Y139";
-
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_bufr_rsync"
-  LOC = "BUFR_X2Y6";
-
-##################################################################################################
-##The logic of this pin is used internally to drive a BUFIO for the byte group. Any clock       ##
-##capable pin in the same bank as the data byte group (DQS, DQ, DM if used) can be used for     ##
-##this pin. This pin cannot be used for other functions and should not be connected externally. ##
-##If a different pin is chosen, the corresponding LOC constraint must also be changed.          ##
-##################################################################################################
-
-CONFIG PROHIBIT = B20,C13,C28,D24,F21,F25,K14,L13;
-
-######################################################################################
-##Place CPT OSERDES and IODELAY:                                                    ##
-######################################################################################
-
-##Site: C13 -- Bank 35
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*0*u_oserdes_cpt"
-  LOC = "OLOGIC_X2Y137";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*0*u_odelay_cpt"
-  LOC = "IODELAY_X2Y137";
-
-##Site: L13 -- Bank 35
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*1*u_oserdes_cpt"
-  LOC = "OLOGIC_X2Y141";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*1*u_odelay_cpt"
-  LOC = "IODELAY_X2Y141";
-
-##Site: K14 -- Bank 35
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*2*u_oserdes_cpt"
-  LOC = "OLOGIC_X2Y143";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*2*u_odelay_cpt"
-  LOC = "IODELAY_X2Y143";
-
-##Site: F21 -- Bank 26
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*3*u_oserdes_cpt"
-  LOC = "OLOGIC_X1Y179";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*3*u_odelay_cpt"
-  LOC = "IODELAY_X1Y179";
-
-##Site: B20 -- Bank 26
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*4*u_oserdes_cpt"
-  LOC = "OLOGIC_X1Y181";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*4*u_odelay_cpt"
-  LOC = "IODELAY_X1Y181";
-
-##Site: F25 -- Bank 25
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*5*u_oserdes_cpt"
-  LOC = "OLOGIC_X1Y137";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*5*u_odelay_cpt"
-  LOC = "IODELAY_X1Y137";
-
-##Site: C28 -- Bank 25
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*6*u_oserdes_cpt"
-  LOC = "OLOGIC_X1Y141";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*6*u_odelay_cpt"
-  LOC = "IODELAY_X1Y141";
-
-##Site: D24 -- Bank 25
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*7*u_oserdes_cpt"
-  LOC = "OLOGIC_X1Y143";
-INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*7*u_odelay_cpt"
-  LOC = "IODELAY_X1Y143";
-
-
-######################################################################################
-## MMCM_ADV CONSTRAINTS                                                             ##
-######################################################################################
-
-INST "ddr3ctrl/u_infrastructure/u_mmcm_adv"      LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36
-
-
-
-###########################################################################
-##  ML605 additions
-###########################################################################
-#NET  "pll_lock"                 IOSTANDARD = LVCMOS25;
-#NET  "heartbeat"                IOSTANDARD = LVCMOS25;
-
-#NET  "heartbeat"                LOC = "AC24";   # ML605 GPIO LED 1
-#NET  "pll_lock"                 LOC = "AC22" ;  # ML605 GPIO LED 0
-
-
-NET "address(0)"                      LOC = "AL8";    ## 29 on U4, A1 on U27
-NET "address(1)"                      LOC = "AK8";    ## 25 on U4, B1 on U27
-NET "address(2)"                      LOC = "AC9";    ## 24 on U4, C1 on U27
-NET "address(3)"                      LOC = "AD10";   ## 23 on U4, D1 on U27
-NET "address(4)"                      LOC = "C8";     ## 22 on U4, D2 on U27
-NET "address(5)"                      LOC = "B8";     ## 21 on U4, A2 on U27
-NET "address(6)"                      LOC = "E9";     ## 20 on U4, C2 on U27
-NET "address(7)"                      LOC = "E8";     ## 19 on U4, A3 on U27
-NET "address(8)"                      LOC = "A8";     ## 8  on U4, B3 on U27
-NET "address(9)"                      LOC = "A9";     ## 7  on U4, C3 on U27
-NET "address(10)"                     LOC = "D9";     ## 6  on U4, D3 on U27
-NET "address(11)"                     LOC = "C9";     ## 5  on U4, C4 on U27
-NET "address(12)"                     LOC = "D10";    ## 4  on U4, A5 on U27
-NET "address(13)"                     LOC = "C10";    ## 3  on U4, B5 on U27
-NET "address(14)"                     LOC = "F10";    ## 2  on U4, C5 on U27
-NET "address(15)"                     LOC = "F9";     ## 1  on U4, D7 on U27
-NET "address(16)"                     LOC = "AH8";    ## 55 on U4, D8 on U27
-NET "address(17)"                     LOC = "AG8";    ## 18 on U4, A7 on U27
-NET "address(18)"                     LOC = "AP9";    ## 17 on U4, B7 on U27
-NET "address(19)"                     LOC = "AN9";    ## 16 on U4, C7 on U27
-NET "address(20)"                     LOC = "AF10";   ## 11 on U4, C8 on U27
-NET "address(21)"                     LOC = "AF9";    ## 10 on U4, A8 on U27
-NET "address(22)"                     LOC = "AL9";    ## 9  on U4, G1 on U27
-NET "address(23)"                     LOC = "AA23";   ## 26 on U4
-NET "data(0)"                      LOC = "AF24";   ## 34 on U4, F2 on U27
-NET "data(1)"                      LOC = "AF25";   ## 36 on U4, E2 on U27
-NET "data(2)"                      LOC = "W24";    ## 39 on U4, G3 on U27
-NET "data(3)"                      LOC = "V24";    ## 41 on U4, E4 on U27
-NET "data(4)"                      LOC = "H24";    ## 47 on U4, E5 on U27
-NET "data(5)"                      LOC = "H25";    ## 49 on U4, G5 on U27
-NET "data(6)"                      LOC = "P24";    ## 51 on U4, G6 on U27
-NET "data(7)"                      LOC = "R24";    ## 53 on U4, H7 on U27
-NET "data(8)"                      LOC = "G23";    ## 35 on U4, E1 on U27
-NET "data(9)"                      LOC = "H23";    ## 37 on U4, E3 on U27
-NET "data(10)"                     LOC = "N24";    ## 40 on U4, F3 on U27
-NET "data(11)"                     LOC = "N23";    ## 42 on U4, F4 on U27
-NET "data(12)"                     LOC = "F23";    ## 48 on U4, F5 on U27
-NET "data(13)"                     LOC = "F24";    ## 50 on U4, H5 on U27
-NET "data(14)"                     LOC = "L24";    ## 52 on U4, G7 on U27
-NET "data(15)"                     LOC = "M23";    ## 54 on U4, E7 on U27
-#NET "FLASH_WAIT"                    LOC = "J26";    ## 56 on U4
-NET "writen"                    LOC = "AF23";   ## 14 on U4, G8 on U27
-NET "oen"                    LOC = "AA24";   ## 32 on U4, F8 on U27
-#NET "FPGA_CCLK"                     LOC = "K8";     ##           F1 on U27
-NET "alatch"                 LOC = "AC23";   ##           H1 on U27
-NET "romsn"                    LOC = "Y24";    ## 30 on U4, B4 on U27 (U10 and switch S2.2 setting select either U4 or U27)
-##
-
-NET "erx_col"                       LOC = "AK13";   ## 114 on U80
-NET "erx_crs"                       LOC = "AL13";   ## 115 on U80
-NET "emdint"                       LOC = "AH14";   ## 32  on U80
-NET "emdc"                       LOC = "AP14";   ## 35  on U80
-NET "emdio"                      LOC = "AN14";   ## 33  on U80
-NET "erstn"                     LOC = "AH13";   ## 36  on U80
-NET "erx_clk"                     LOC = "AP11";   ## 7   on U80
-NET "erx_dv"                LOC = "AM13";   ## 4   on U80
-NET "erxd(0)"                      LOC = "AN13";   ## 3   on U80
-NET "erxd(1)"                      LOC = "AF14";   ## 128 on U80
-NET "erxd(2)"                      LOC = "AE14";   ## 126 on U80
-NET "erxd(3)"                      LOC = "AN12";   ## 125 on U80
-NET "erxd(4)"                      LOC = "AM12";   ## 124 on U80
-NET "erxd(5)"                      LOC = "AD11";   ## 123 on U80
-NET "erxd(6)"                      LOC = "AC12";   ## 121 on U80
-NET "erxd(7)"                      LOC = "AC13";   ## 120 on U80
-NET "erx_er"                      LOC = "AG12";   ## 9   on U80
-NET "etx_clk"                     LOC = "AD12";   ## 10  on U80
-NET "etx_en"                LOC = "AJ10";   ## 16  on U80
-NET "egtx_clk"                LOC = "AH12";   ## 14  on U80
-NET "etxd(0)"                      LOC = "AM11";   ## 18  on U80
-NET "etxd(1)"                      LOC = "AL11";   ## 19  on U80
-NET "etxd(2)"                      LOC = "AG10";   ## 20  on U80
-NET "etxd(3)"                      LOC = "AG11";   ## 24  on U80
-NET "etxd(4)"                      LOC = "AL10";   ## 25  on U80
-NET "etxd(5)"                      LOC = "AM10";   ## 26  on U80
-NET "etxd(6)"                      LOC = "AE11";   ## 28  on U80
-NET "etxd(7)"                      LOC = "AF11";   ## 29  on U80
-NET "etx_er"                      LOC = "AH10";   ## 13  on U80
-
-NET "dsurx"                      LOC = "J24";    ## 24  on U34
-NET "dsutx"                      LOC = "J25";    ## 25  on U34
-
-#NET "GPIO_DIP_SW1"                  LOC = "D22";    ## 1   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW2"                  LOC = "C22";    ## 2   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW3"                  LOC = "L21";    ## 3   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW4"                  LOC = "L20";    ## 4   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW5"                  LOC = "C18";    ## 5   on SW1 DIP switch (active-high)
-NET "dsubre"                  LOC = "B18";    ## 6   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW7"                  LOC = "K22";    ## 7   on SW1 DIP switch (active-high)
-#NET "GPIO_DIP_SW8"                  LOC = "K21";    ## 8   on SW1 DIP switch (active-high)
-##
-
-NET "led(0)"                    LOC = "AC22";   ## 2   on LED DS12, 1 on J62
-NET "led(1)"                    LOC = "AC24";   ## 2   on LED DS11, 2 on J62
-NET "led(2)"                    LOC = "AE22";   ## 2   on LED DS9,  3 on J62
-NET "led(3)"                    LOC = "AE23";   ## 2   on LED DS10, 4 on J62
-NET "led(4)"                    LOC = "AB23";   ## 2   on LED DS15, 5 on J62
-NET "led(4)"                    LOC = "AB23";   ## 2   on LED DS15, 5 on J62
-NET "led(5)"                    LOC = "AG23";   ## 2   on LED DS14, 6 on J62
-#NET "GPIO_LED_5"                    LOC = "AG23";   ## 2   on LED DS14, 6 on J62
-#NET "GPIO_LED_6"                    LOC = "AE24";   ## 2   on LED DS22, 7 on J62
-#NET "GPIO_LED_7"                    LOC = "AD24";   ## 2   on LED DS21, 8 on J62
-
-NET "dvi_iic_scl"                   LOC = "AN10";   ## 2   on Q5, 15 on U38
-NET "iic_scl_main"               LOC = "AK9";    ## 2   on Q19
-#NET "IIC_SCL_SFP"                   LOC = "AA34";   ## 2   on Q23
-NET "dvi_iic_sda"                   LOC = "AP10";   ## 2   on Q6, 14 on U38
-NET "iic_sda_main"               LOC = "AE9";    ## 2   on Q20
-#NET "IIC_SDA_SFP"                   LOC = "AA33";   ## 2   on Q21
-
-NET "tft_lcd_data(0)"                        LOC = "AJ19";   ## 63 on U38 (thru series R111 47.5 ohm)
-NET "tft_lcd_data(1)"                        LOC = "AH19";   ## 62 on U38 (thru series R110 47.5 ohm)
-NET "tft_lcd_data(2)"                        LOC = "AM17";   ## 61 on U38 (thru series R109 47.5 ohm)
-NET "tft_lcd_data(3)"                        LOC = "AM16";   ## 60 on U38 (thru series R108 47.5 ohm)
-NET "tft_lcd_data(4)"                        LOC = "AD17";   ## 59 on U38 (thru series R107 47.5 ohm)
-NET "tft_lcd_data(5)"                        LOC = "AE17";   ## 58 on U38 (thru series R106 47.5 ohm)
-NET "tft_lcd_data(6)"                        LOC = "AK18";   ## 55 on U38 (thru series R105 47.5 ohm)
-NET "tft_lcd_data(7)"                        LOC = "AK17";   ## 54 on U38 (thru series R104 47.5 ohm)
-NET "tft_lcd_data(8)"                        LOC = "AE18";   ## 53 on U38 (thru series R103 47.5 ohm)
-NET "tft_lcd_data(9)"                        LOC = "AF18";   ## 52 on U38 (thru series R102 47.5 ohm)
-NET "tft_lcd_data(10)"                       LOC = "AL16";   ## 51 on U38 (thru series R101 47.5 ohm)
-NET "tft_lcd_data(11)"                       LOC = "AK16";   ## 50 on U38 (thru series R100 47.5 ohm)
-NET "tft_lcd_de"                        LOC = "AD16";   ## 2  on U38 (thru series R112 47.5 ohm)
-#NET "DVI_GPIO1_FMC_C2M_PG_LS"       LOC = "K9";     ## 18 on U32 (not wired to U38)
-NET "tft_lcd_hsync"                         LOC = "AN17";   ## 4  on U38 (thru series R113 47.5 ohm)
-NET "tft_lcd_reset_b"                LOC = "AP17";   ## 2  on U32 (DVI_RESET_B pin 13 on U38)
-NET "tft_lcd_vsync"                         LOC = "AD15";   ## 5  on U38 (thru series R114 47.5 ohm)
-NET "tft_lcd_clk_n"                    LOC = "AC17";   ## 56 on U38
-NET "tft_lcd_clk_p"                    LOC = "AC18";   ## 57 on U38
-
-#NET "SYSACE_CFGTDI"                 LOC = "AC8";    ## 81  on U19
-NET "sysace_d(0)"                     LOC = "AM15";   ## 66  on U19
-NET "sysace_d(1)"                     LOC = "AJ17";   ## 65  on U19
-NET "sysace_d(2)"                     LOC = "AJ16";   ## 63  on U19
-NET "sysace_d(3)"                     LOC = "AP16";   ## 62  on U19
-NET "sysace_d(4)"                     LOC = "AG16";   ## 61  on U19
-NET "sysace_d(5)"                     LOC = "AH15";   ## 60  on U19
-NET "sysace_d(6)"                     LOC = "AF16";   ## 59  on U19
-NET "sysace_d(7)"                     LOC = "AN15";   ## 58  on U19
-NET "sysace_mpa(0)"                  LOC = "AC15";   ## 70  on U19
-NET "sysace_mpa(1)"                  LOC = "AP15";   ## 69  on U19
-NET "sysace_mpa(2)"                  LOC = "AG17";   ## 68  on U19
-NET "sysace_mpa(3)"                  LOC = "AH17";   ## 67  on U19
-NET "sysace_mpa(4)"                  LOC = "AG15";   ## 45  on U19
-NET "sysace_mpa(5)"                  LOC = "AF15";   ## 44  on U19
-NET "sysace_mpa(6)"                  LOC = "AK14";   ## 43  on U19
-#NET "SYSACE_MPBRDY"                 LOC = "AJ15";   ## 39  on U19
-NET "sysace_mpce"                   LOC = "AJ14";   ## 42  on U19
-NET "sysace_mpirq"                  LOC = "L9";     ## 41  on U19
-NET "sysace_mpoe"                   LOC = "AL15";   ## 77  on U19
-NET "sysace_mpwe"                   LOC = "AL14";   ## 76  on U19
-NET "clk_33"              LOC = "AE16";   ## 93  on U19
+############################################################################
+## 
+##  Xilinx, Inc. 2006            www.xilinx.com 
+##  Mon Aug 30 10:34:47 2010
+##  Generated by MIG Version 3.6
+##  
+############################################################################
+##  File name :       example_top.ucf
+## 
+##  Details :     Constraints file
+##                    FPGA family:       virtex6
+##                    FPGA:              xc6vlx240t-ff1156
+##                    Speedgrade:        -1
+##                    Design Entry:      VERILOG
+##                    Design:            with Test bench
+##                    No.Of Controllers: 1
+##
+############################################################################ 
+##  Modifications for ML605 with LX240T FPGA
+##  Start with UCF file generated by MIG 3.4 (ISE 12.1 build M.53.d)
+##     
+##  1. Majority of ML605 board specific pin assignments entered via MIG3.4 GUI!
+##     A. Add LOC and IOSTANDARD for LED indicator "heartbeat" 
+##     B. Add LOC and IOSTANDARD for LED indicator "pll_lock" 
+##     C. Comment out "sda" and "scl" signals 
+##     D. ML605 DCI_CASCADE is correct as defined in MIG3.4 GUI.
+##        BANK 26 = left column I/O master; BANK 36 = right column I/O master 
+##  2. Change IOSTANDARD for sys_rst to SSTL15 
+##  3. Board specific clocking definitions
+##     A. Default MIG 3.5 example design assumes 2 clock inputs to design:
+##        1. clk_ref to IDELAY_CTRL element (200 MHz)
+##        2. sys_clk to PLL circuit (SMA inputs)
+##     B. ML605 single clock source, modify constraint file to use 200 MHz 
+##        LVDS clock "clk_ref" input for DDR3 SODIMM design @800 Mbps data rate. 
+##        - Delete sys_clk_p and sys_clk_n inputs (HDL and LOC constraints)
+##        - Comment out sys_clk timing specification
+##        - Modify TS_MC_PHY_INIT_SEL to use value "2.5 ns" in multiplication 
+##  4. Optional: comment out CONFIG_PROHIBIT lines (pins reserved for MIG)
+##     Since this design has LOC'ed I/O don't need to reserve these pins.
+##  5. ML605 MIG3.4 BUFIO pin assignments
+##         BUFIO:0 pin C13 => X2Y137
+##         BUFIO:1 pin L13 => X2Y141
+##         BUFIO:2 pin K14 => X2Y143
+##         BUFIO:3 pin F21 => X1Y179
+##         BUFIO:4 pin B20 => X1Y181
+##         BUFIO:5 pin F25 => X1Y137
+##         BUFIO:6 pin C28 => X1Y141
+##         BUFIO:7 pin D24 => X1Y143
+##  6. ML605 MIG3.4 BUFR pin assignments
+##         BUFR:0 pin M12 => X2Y139
+##         BUFR:1 pin C29 => X1Y139
+##
+############################################################################
+# Timing constraints                                                        #
+############################################################################
+## ML605 comment out the following 2 lines for single 200MHz input clock
+## NET "sys_clk_p" TNM_NET = TNM_sys_clk;
+## TIMESPEC "TS_sys_clk" = PERIOD "TNM_sys_clk" 2.5 ns;
+
+NET "clk_ref_p" TNM_NET = TNM_clk_ref;
+TIMESPEC "TS_clk_ref" = PERIOD "TNM_clk_ref" 5 ns ;
+
+# Constrain BUFR clocks used to synchronize data from IOB to fabric logic
+# Note that ISE cannot infer this from other PERIOD constraints because
+# of the use of OSERDES blocks in the BUFR clock generation path
+NET "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/clk_rsync(?)" TNM_NET = TNM_clk_rsync;
+TIMESPEC "TS_clk_rsync" = PERIOD "TNM_clk_rsync" 5 ns;
+
+# Paths between DQ/DQS ISERDES.Q outputs and CLB flops clocked by falling 
+# edge of BUFR will by design only be used if DYNCLKDIVSEL is asserted for 
+# that particular flop. Mark this path as being a full-cycle, rather than 
+# a half cycle path for timing purposes. NOTE: This constraint forces full-
+# cycle timing to be applied globally for all rising->falling edge paths 
+# in all resynchronizaton clock domains. If the user had modified the logic
+# in the resync clock domain such that other rising->falling edge paths 
+# exist, then constraint below should be modified to utilize pattern 
+# matching to specific affect only the DQ/DQS ISERDES.Q outputs
+TIMEGRP "TG_clk_rsync_rise" = RISING  "TNM_clk_rsync";
+TIMEGRP "TG_clk_rsync_fall" = FALLING "TNM_clk_rsync";
+TIMESPEC "TS_clk_rsync_rise_to_fall" = 
+  FROM "TG_clk_rsync_rise" TO "TG_clk_rsync_fall" "TS_sys_clk" * 2;
+
+# Signal to select between controller and physical layer signals. Four divided by two clock
+# cycles (8 memory clock cycles) are provided by design for the signal to settle down.
+# Used only by the phy modules.
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
+TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = 10 ns;  ## = "2.5ns * 4" ML605 single clock
+
+disable = reg_sr_o;
+disable = reg_sr_r;
+############################################################################
+########################################################################
+# Controller 0
+# Memory Device: DDR3_SDRAM->SODIMMs->MT4JSF6464HY-1G1
+# Data Width:     64
+# Frequency:      400
+# Time Period:      2500
+# Data Mask:     1
+########################################################################
+
+
+################################################################################
+# I/O STANDARDS
+################################################################################
+
+NET  "ddr3_dq(*)"                               IOSTANDARD = SSTL15_T_DCI;
+NET  "ddr3_addr(*)"                             IOSTANDARD = SSTL15;
+NET  "ddr3_ba(*)"                               IOSTANDARD = SSTL15;
+NET  "ddr3_ras_n"                               IOSTANDARD = SSTL15;
+NET  "ddr3_cas_n"                               IOSTANDARD = SSTL15;
+NET  "ddr3_we_n"                                IOSTANDARD = SSTL15;
+NET  "ddr3_reset_n"                             IOSTANDARD = SSTL15;
+NET  "ddr3_cke(*)"                              IOSTANDARD = SSTL15;
+NET  "ddr3_odt(*)"                              IOSTANDARD = SSTL15;
+NET  "ddr3_cs_n(*)"                             IOSTANDARD = SSTL15;
+NET  "ddr3_dm(*)"                               IOSTANDARD = SSTL15;
+## NET  "sys_clk_p"                                IOSTANDARD = LVDS_25;
+## NET  "sys_clk_n"                                IOSTANDARD = LVDS_25;
+NET  "clk_ref_p"                                IOSTANDARD = LVDS_25;
+NET  "clk_ref_n"                                IOSTANDARD = LVDS_25;
+## NET  "sda"                                      IOSTANDARD = LVCMOS25;
+## NET  "scl"                                      IOSTANDARD = LVCMOS25;
+NET  "reset"                                  IOSTANDARD = SSTL15;      ## ML605 
+#NET  "phy_init_done"                            IOSTANDARD = LVCMOS25;
+NET  "errorn"                                    IOSTANDARD = LVCMOS25;
+NET  "ddr3_dqs_p(*)"                            IOSTANDARD = DIFF_SSTL15_T_DCI;
+NET  "ddr3_dqs_n(*)"                            IOSTANDARD = DIFF_SSTL15_T_DCI;
+NET  "ddr3_ck_p(*)"                             IOSTANDARD = DIFF_SSTL15;
+NET  "ddr3_ck_n(*)"                             IOSTANDARD = DIFF_SSTL15;
+
+################################################################################
+##SAVE attributes to reserve the pins
+################################################################################
+## NET  "sda"                                      S;
+## NET  "scl"                                      S;
+
+###############################################################################
+#DCI_CASCADING
+#Syntax : CONFIG DCI_CASCADE = "<master> <slave1> <slave2> ..";
+###############################################################################
+CONFIG DCI_CASCADE = "26 25";
+CONFIG DCI_CASCADE = "36 35";
+
+
+##################################################################################
+# Location Constraints
+##################################################################################
+NET  "ddr3_dq(0)"                                LOC = "J11" ;          #Bank 35
+NET  "ddr3_dq(1)"                                LOC = "E13" ;          #Bank 35
+NET  "ddr3_dq(2)"                                LOC = "F13" ;          #Bank 35
+NET  "ddr3_dq(3)"                                LOC = "K11" ;          #Bank 35
+NET  "ddr3_dq(4)"                                LOC = "L11" ;          #Bank 35
+NET  "ddr3_dq(5)"                                LOC = "K13" ;          #Bank 35
+NET  "ddr3_dq(6)"                                LOC = "K12" ;          #Bank 35
+NET  "ddr3_dq(7)"                                LOC = "D11" ;          #Bank 35
+NET  "ddr3_dq(8)"                                LOC = "M13" ;          #Bank 35
+NET  "ddr3_dq(9)"                                LOC = "J14" ;          #Bank 35
+NET  "ddr3_dq(10)"                               LOC = "B13" ;          #Bank 35
+NET  "ddr3_dq(11)"                               LOC = "B12" ;          #Bank 35
+NET  "ddr3_dq(12)"                               LOC = "G10" ;          #Bank 35
+NET  "ddr3_dq(13)"                               LOC = "M11" ;          #Bank 35
+NET  "ddr3_dq(14)"                               LOC = "C12" ;          #Bank 35
+NET  "ddr3_dq(15)"                               LOC = "A11" ;          #Bank 35
+NET  "ddr3_dq(16)"                               LOC = "G11" ;          #Bank 35
+NET  "ddr3_dq(17)"                               LOC = "F11" ;          #Bank 35
+NET  "ddr3_dq(18)"                               LOC = "D14" ;          #Bank 35
+NET  "ddr3_dq(19)"                               LOC = "C14" ;          #Bank 35
+NET  "ddr3_dq(20)"                               LOC = "G12" ;          #Bank 35
+NET  "ddr3_dq(21)"                               LOC = "G13" ;          #Bank 35
+NET  "ddr3_dq(22)"                               LOC = "F14" ;          #Bank 35
+NET  "ddr3_dq(23)"                               LOC = "H14" ;          #Bank 35
+NET  "ddr3_dq(24)"                               LOC = "C19" ;          #Bank 26
+NET  "ddr3_dq(25)"                               LOC = "G20" ;          #Bank 26
+NET  "ddr3_dq(26)"                               LOC = "E19" ;          #Bank 26
+NET  "ddr3_dq(27)"                               LOC = "F20" ;          #Bank 26
+NET  "ddr3_dq(28)"                               LOC = "A20" ;          #Bank 26
+NET  "ddr3_dq(29)"                               LOC = "A21" ;          #Bank 26
+NET  "ddr3_dq(30)"                               LOC = "E22" ;          #Bank 26
+NET  "ddr3_dq(31)"                               LOC = "E23" ;          #Bank 26
+NET  "ddr3_dq(32)"                               LOC = "G21" ;          #Bank 26
+NET  "ddr3_dq(33)"                               LOC = "B21" ;          #Bank 26
+NET  "ddr3_dq(34)"                               LOC = "A23" ;          #Bank 26
+NET  "ddr3_dq(35)"                               LOC = "A24" ;          #Bank 26
+NET  "ddr3_dq(36)"                               LOC = "C20" ;          #Bank 26
+NET  "ddr3_dq(37)"                               LOC = "D20" ;          #Bank 26
+NET  "ddr3_dq(38)"                               LOC = "J20" ;          #Bank 26
+NET  "ddr3_dq(39)"                               LOC = "G22" ;          #Bank 26
+NET  "ddr3_dq(40)"                               LOC = "D26" ;          #Bank 25
+NET  "ddr3_dq(41)"                               LOC = "F26" ;          #Bank 25
+NET  "ddr3_dq(42)"                               LOC = "B26" ;          #Bank 25
+NET  "ddr3_dq(43)"                               LOC = "E26" ;          #Bank 25
+NET  "ddr3_dq(44)"                               LOC = "C24" ;          #Bank 25
+NET  "ddr3_dq(45)"                               LOC = "D25" ;          #Bank 25
+NET  "ddr3_dq(46)"                               LOC = "D27" ;          #Bank 25
+NET  "ddr3_dq(47)"                               LOC = "C25" ;          #Bank 25
+NET  "ddr3_dq(48)"                               LOC = "C27" ;          #Bank 25
+NET  "ddr3_dq(49)"                               LOC = "B28" ;          #Bank 25
+NET  "ddr3_dq(50)"                               LOC = "D29" ;          #Bank 25
+NET  "ddr3_dq(51)"                               LOC = "B27" ;          #Bank 25
+NET  "ddr3_dq(52)"                               LOC = "G27" ;          #Bank 25
+NET  "ddr3_dq(53)"                               LOC = "A28" ;          #Bank 25
+NET  "ddr3_dq(54)"                               LOC = "E24" ;          #Bank 25
+NET  "ddr3_dq(55)"                               LOC = "G25" ;          #Bank 25
+NET  "ddr3_dq(56)"                               LOC = "F28" ;          #Bank 25
+NET  "ddr3_dq(57)"                               LOC = "B31" ;          #Bank 25
+NET  "ddr3_dq(58)"                               LOC = "H29" ;          #Bank 25
+NET  "ddr3_dq(59)"                               LOC = "H28" ;          #Bank 25
+NET  "ddr3_dq(60)"                               LOC = "B30" ;          #Bank 25
+NET  "ddr3_dq(61)"                               LOC = "A30" ;          #Bank 25
+NET  "ddr3_dq(62)"                               LOC = "E29" ;          #Bank 25
+NET  "ddr3_dq(63)"                               LOC = "F29" ;          #Bank 25
+NET  "ddr3_addr(13)"                             LOC = "J15" ;          #Bank 36
+NET  "ddr3_addr(12)"                             LOC = "H15" ;          #Bank 36
+NET  "ddr3_addr(11)"                             LOC = "M15" ;          #Bank 36
+NET  "ddr3_addr(10)"                             LOC = "M16" ;          #Bank 36
+NET  "ddr3_addr(9)"                              LOC = "F15" ;          #Bank 36
+NET  "ddr3_addr(8)"                              LOC = "G15" ;          #Bank 36
+NET  "ddr3_addr(7)"                              LOC = "B15" ;          #Bank 36
+NET  "ddr3_addr(6)"                              LOC = "A15" ;          #Bank 36
+NET  "ddr3_addr(5)"                              LOC = "J17" ;          #Bank 36
+NET  "ddr3_addr(4)"                              LOC = "D16" ;          #Bank 36
+NET  "ddr3_addr(3)"                              LOC = "E16" ;          #Bank 36
+NET  "ddr3_addr(2)"                              LOC = "B16" ;          #Bank 36
+NET  "ddr3_addr(1)"                              LOC = "A16" ;          #Bank 36
+NET  "ddr3_addr(0)"                              LOC = "L14" ;          #Bank 36
+NET  "ddr3_ba(2)"                                LOC = "L15" ;          #Bank 36
+NET  "ddr3_ba(1)"                                LOC = "J19" ;          #Bank 36
+NET  "ddr3_ba(0)"                                LOC = "K19" ;          #Bank 36
+NET  "ddr3_ras_n"                                LOC = "L19" ;          #Bank 36
+NET  "ddr3_cas_n"                                LOC = "C17" ;          #Bank 36
+NET  "ddr3_we_n"                                 LOC = "B17" ;          #Bank 36
+NET  "ddr3_reset_n"                              LOC = "E18" ;          #Bank 36
+NET  "ddr3_cke(0)"                               LOC = "M18" ;          #Bank 36
+NET  "ddr3_odt(0)"                               LOC = "F18" ;          #Bank 36
+NET  "ddr3_cs_n(0)"                              LOC = "K18" ;          #Bank 36
+NET  "ddr3_dm(0)"                                LOC = "E11" ;          #Bank 35
+NET  "ddr3_dm(1)"                                LOC = "B11" ;          #Bank 35
+NET  "ddr3_dm(2)"                                LOC = "E14" ;          #Bank 35
+NET  "ddr3_dm(3)"                                LOC = "D19" ;          #Bank 26
+NET  "ddr3_dm(4)"                                LOC = "B22" ;          #Bank 26
+NET  "ddr3_dm(5)"                                LOC = "A26" ;          #Bank 25
+NET  "ddr3_dm(6)"                                LOC = "A29" ;          #Bank 25
+NET  "ddr3_dm(7)"                                LOC = "A31" ;          #Bank 25
+## NET  "sys_clk_p"                                 LOC = "J9" ;          #Bank 34
+## NET  "sys_clk_n"                                 LOC = "H9" ;          #Bank 34
+NET  "clk_ref_p"                                 LOC = "J9" ;          #Bank 34
+NET  "clk_ref_n"                                 LOC = "H9" ;          #Bank 34
+## NET  "sda"                                       LOC = "F9" ;          #Bank 34
+## NET  "scl"                                       LOC = "F10" ;          #Bank 34
+NET  "reset"                                   LOC = "H10" ;          #ML605 CPU_RESET switch
+#NET  "phy_init_done"                             LOC = "AE23" ;         #ML605 GPIO LED 3
+NET  "errorn"                                     LOC = "AD24" ;         #ML605 GPIO LED 2
+NET  "ddr3_dqs_p(0)"                             LOC = "D12" ;          #Bank 35
+NET  "ddr3_dqs_n(0)"                             LOC = "E12" ;          #Bank 35
+NET  "ddr3_dqs_p(1)"                             LOC = "H12" ;          #Bank 35
+NET  "ddr3_dqs_n(1)"                             LOC = "J12" ;          #Bank 35
+NET  "ddr3_dqs_p(2)"                             LOC = "A13" ;          #Bank 35
+NET  "ddr3_dqs_n(2)"                             LOC = "A14" ;          #Bank 35
+NET  "ddr3_dqs_p(3)"                             LOC = "H19" ;          #Bank 26
+NET  "ddr3_dqs_n(3)"                             LOC = "H20" ;          #Bank 26
+NET  "ddr3_dqs_p(4)"                             LOC = "B23" ;          #Bank 26
+NET  "ddr3_dqs_n(4)"                             LOC = "C23" ;          #Bank 26
+NET  "ddr3_dqs_p(5)"                             LOC = "B25" ;          #Bank 25
+NET  "ddr3_dqs_n(5)"                             LOC = "A25" ;          #Bank 25
+NET  "ddr3_dqs_p(6)"                             LOC = "H27" ;          #Bank 25
+NET  "ddr3_dqs_n(6)"                             LOC = "G28" ;          #Bank 25
+NET  "ddr3_dqs_p(7)"                             LOC = "C30" ;          #Bank 25
+NET  "ddr3_dqs_n(7)"                             LOC = "D30" ;          #Bank 25
+NET  "ddr3_ck_p(0)"                              LOC = "G18" ;          #Bank 36
+NET  "ddr3_ck_n(0)"                              LOC = "H18" ;          #Bank 36
+
+
+##################################################################################################
+##The following locations must be reserved and cannot be used for external I/O because          ##
+##the I/O elements associated with these sites (IODELAY, OSERDES, and associated routing)       ##
+##are used to generate and route the clocks necessary for read data capture and synchronization ##
+##to the core clock domain. These pins should not be routed out on the user's PCB               ##
+##################################################################################################
+
+##################################################################################################
+##The logic of this pin is used internally to drive a BUFR in the column. This chosen pin must  ##
+##be a clock pin capable of spanning to all of the banks containing data bytes in the particular##
+##column. That is, all byte groups must be within +/- 1 bank of this pin. This pin cannot be    ##
+##used for other functions and should not be connected externally. If a different pin is chosen,##
+##he corresponding LOC constraint must also be changed.                                         ##
+##################################################################################################
+
+CONFIG PROHIBIT = C29,M12;
+
+######################################################################################
+##Place RSYNC OSERDES and IODELAY:                                                  ##
+######################################################################################
+
+##Site: C29 -- Bank 25
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_oserdes_rsync"
+  LOC = "OLOGIC_X1Y139";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_odelay_rsync"
+  LOC = "IODELAY_X1Y139";
+
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_bufr_rsync"
+  LOC = "BUFR_X1Y6";
+
+##Site: M12 -- Bank 35
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_oserdes_rsync"
+  LOC = "OLOGIC_X2Y139";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_odelay_rsync"
+  LOC = "IODELAY_X2Y139";
+
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_bufr_rsync"
+  LOC = "BUFR_X2Y6";
+
+##################################################################################################
+##The logic of this pin is used internally to drive a BUFIO for the byte group. Any clock       ##
+##capable pin in the same bank as the data byte group (DQS, DQ, DM if used) can be used for     ##
+##this pin. This pin cannot be used for other functions and should not be connected externally. ##
+##If a different pin is chosen, the corresponding LOC constraint must also be changed.          ##
+##################################################################################################
+
+CONFIG PROHIBIT = B20,C13,C28,D24,F21,F25,K14,L13;
+
+######################################################################################
+##Place CPT OSERDES and IODELAY:                                                    ##
+######################################################################################
+
+##Site: C13 -- Bank 35
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*0*u_oserdes_cpt"
+  LOC = "OLOGIC_X2Y137";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*0*u_odelay_cpt"
+  LOC = "IODELAY_X2Y137";
+
+##Site: L13 -- Bank 35
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*1*u_oserdes_cpt"
+  LOC = "OLOGIC_X2Y141";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*1*u_odelay_cpt"
+  LOC = "IODELAY_X2Y141";
+
+##Site: K14 -- Bank 35
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*2*u_oserdes_cpt"
+  LOC = "OLOGIC_X2Y143";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*2*u_odelay_cpt"
+  LOC = "IODELAY_X2Y143";
+
+##Site: F21 -- Bank 26
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*3*u_oserdes_cpt"
+  LOC = "OLOGIC_X1Y179";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*3*u_odelay_cpt"
+  LOC = "IODELAY_X1Y179";
+
+##Site: B20 -- Bank 26
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*4*u_oserdes_cpt"
+  LOC = "OLOGIC_X1Y181";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*4*u_odelay_cpt"
+  LOC = "IODELAY_X1Y181";
+
+##Site: F25 -- Bank 25
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*5*u_oserdes_cpt"
+  LOC = "OLOGIC_X1Y137";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*5*u_odelay_cpt"
+  LOC = "IODELAY_X1Y137";
+
+##Site: C28 -- Bank 25
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*6*u_oserdes_cpt"
+  LOC = "OLOGIC_X1Y141";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*6*u_odelay_cpt"
+  LOC = "IODELAY_X1Y141";
+
+##Site: D24 -- Bank 25
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*7*u_oserdes_cpt"
+  LOC = "OLOGIC_X1Y143";
+INST "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt*7*u_odelay_cpt"
+  LOC = "IODELAY_X1Y143";
+
+
+######################################################################################
+## MMCM_ADV CONSTRAINTS                                                             ##
+######################################################################################
+
+INST "ddr3ctrl/u_infrastructure/u_mmcm_adv"      LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36
+
+
+
+###########################################################################
+##  ML605 additions
+###########################################################################
+#NET  "pll_lock"                 IOSTANDARD = LVCMOS25;
+#NET  "heartbeat"                IOSTANDARD = LVCMOS25;
+
+#NET  "heartbeat"                LOC = "AC24";   # ML605 GPIO LED 1
+#NET  "pll_lock"                 LOC = "AC22" ;  # ML605 GPIO LED 0
+
+
+NET "address(0)"                      LOC = "AL8";    ## 29 on U4, A1 on U27
+NET "address(1)"                      LOC = "AK8";    ## 25 on U4, B1 on U27
+NET "address(2)"                      LOC = "AC9";    ## 24 on U4, C1 on U27
+NET "address(3)"                      LOC = "AD10";   ## 23 on U4, D1 on U27
+NET "address(4)"                      LOC = "C8";     ## 22 on U4, D2 on U27
+NET "address(5)"                      LOC = "B8";     ## 21 on U4, A2 on U27
+NET "address(6)"                      LOC = "E9";     ## 20 on U4, C2 on U27
+NET "address(7)"                      LOC = "E8";     ## 19 on U4, A3 on U27
+NET "address(8)"                      LOC = "A8";     ## 8  on U4, B3 on U27
+NET "address(9)"                      LOC = "A9";     ## 7  on U4, C3 on U27
+NET "address(10)"                     LOC = "D9";     ## 6  on U4, D3 on U27
+NET "address(11)"                     LOC = "C9";     ## 5  on U4, C4 on U27
+NET "address(12)"                     LOC = "D10";    ## 4  on U4, A5 on U27
+NET "address(13)"                     LOC = "C10";    ## 3  on U4, B5 on U27
+NET "address(14)"                     LOC = "F10";    ## 2  on U4, C5 on U27
+NET "address(15)"                     LOC = "F9";     ## 1  on U4, D7 on U27
+NET "address(16)"                     LOC = "AH8";    ## 55 on U4, D8 on U27
+NET "address(17)"                     LOC = "AG8";    ## 18 on U4, A7 on U27
+NET "address(18)"                     LOC = "AP9";    ## 17 on U4, B7 on U27
+NET "address(19)"                     LOC = "AN9";    ## 16 on U4, C7 on U27
+NET "address(20)"                     LOC = "AF10";   ## 11 on U4, C8 on U27
+NET "address(21)"                     LOC = "AF9";    ## 10 on U4, A8 on U27
+NET "address(22)"                     LOC = "AL9";    ## 9  on U4, G1 on U27
+NET "address(23)"                     LOC = "AA23";   ## 26 on U4
+NET "data(0)"                      LOC = "AF24";   ## 34 on U4, F2 on U27
+NET "data(1)"                      LOC = "AF25";   ## 36 on U4, E2 on U27
+NET "data(2)"                      LOC = "W24";    ## 39 on U4, G3 on U27
+NET "data(3)"                      LOC = "V24";    ## 41 on U4, E4 on U27
+NET "data(4)"                      LOC = "H24";    ## 47 on U4, E5 on U27
+NET "data(5)"                      LOC = "H25";    ## 49 on U4, G5 on U27
+NET "data(6)"                      LOC = "P24";    ## 51 on U4, G6 on U27
+NET "data(7)"                      LOC = "R24";    ## 53 on U4, H7 on U27
+NET "data(8)"                      LOC = "G23";    ## 35 on U4, E1 on U27
+NET "data(9)"                      LOC = "H23";    ## 37 on U4, E3 on U27
+NET "data(10)"                     LOC = "N24";    ## 40 on U4, F3 on U27
+NET "data(11)"                     LOC = "N23";    ## 42 on U4, F4 on U27
+NET "data(12)"                     LOC = "F23";    ## 48 on U4, F5 on U27
+NET "data(13)"                     LOC = "F24";    ## 50 on U4, H5 on U27
+NET "data(14)"                     LOC = "L24";    ## 52 on U4, G7 on U27
+NET "data(15)"                     LOC = "M23";    ## 54 on U4, E7 on U27
+#NET "FLASH_WAIT"                    LOC = "J26";    ## 56 on U4
+NET "writen"                    LOC = "AF23";   ## 14 on U4, G8 on U27
+NET "oen"                    LOC = "AA24";   ## 32 on U4, F8 on U27
+#NET "FPGA_CCLK"                     LOC = "K8";     ##           F1 on U27
+NET "alatch"                 LOC = "AC23";   ##           H1 on U27
+NET "romsn"                    LOC = "Y24";    ## 30 on U4, B4 on U27 (U10 and switch S2.2 setting select either U4 or U27)
+##
+
+NET "erx_col"                       LOC = "AK13";   ## 114 on U80
+NET "erx_crs"                       LOC = "AL13";   ## 115 on U80
+NET "emdint"                       LOC = "AH14";   ## 32  on U80
+NET "emdc"                       LOC = "AP14";   ## 35  on U80
+NET "emdio"                      LOC = "AN14";   ## 33  on U80
+NET "erstn"                     LOC = "AH13";   ## 36  on U80
+NET "erx_clk"                     LOC = "AP11";   ## 7   on U80
+NET "erx_dv"                LOC = "AM13";   ## 4   on U80
+NET "erxd(0)"                      LOC = "AN13";   ## 3   on U80
+NET "erxd(1)"                      LOC = "AF14";   ## 128 on U80
+NET "erxd(2)"                      LOC = "AE14";   ## 126 on U80
+NET "erxd(3)"                      LOC = "AN12";   ## 125 on U80
+NET "erxd(4)"                      LOC = "AM12";   ## 124 on U80
+NET "erxd(5)"                      LOC = "AD11";   ## 123 on U80
+NET "erxd(6)"                      LOC = "AC12";   ## 121 on U80
+NET "erxd(7)"                      LOC = "AC13";   ## 120 on U80
+NET "erx_er"                      LOC = "AG12";   ## 9   on U80
+NET "etx_clk"                     LOC = "AD12";   ## 10  on U80
+NET "etx_en"                LOC = "AJ10";   ## 16  on U80
+NET "egtx_clk"                LOC = "AH12";   ## 14  on U80
+NET "etxd(0)"                      LOC = "AM11";   ## 18  on U80
+NET "etxd(1)"                      LOC = "AL11";   ## 19  on U80
+NET "etxd(2)"                      LOC = "AG10";   ## 20  on U80
+NET "etxd(3)"                      LOC = "AG11";   ## 24  on U80
+NET "etxd(4)"                      LOC = "AL10";   ## 25  on U80
+NET "etxd(5)"                      LOC = "AM10";   ## 26  on U80
+NET "etxd(6)"                      LOC = "AE11";   ## 28  on U80
+NET "etxd(7)"                      LOC = "AF11";   ## 29  on U80
+NET "etx_er"                      LOC = "AH10";   ## 13  on U80
+
+NET "dsurx"                      LOC = "J24";    ## 24  on U34
+NET "dsutx"                      LOC = "J25";    ## 25  on U34
+
+#NET "GPIO_DIP_SW1"                  LOC = "D22";    ## 1   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW2"                  LOC = "C22";    ## 2   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW3"                  LOC = "L21";    ## 3   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW4"                  LOC = "L20";    ## 4   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW5"                  LOC = "C18";    ## 5   on SW1 DIP switch (active-high)
+#NET "dsubre"                  LOC = "B18";    ## 6   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW7"                  LOC = "K22";    ## 7   on SW1 DIP switch (active-high)
+#NET "GPIO_DIP_SW8"                  LOC = "K21";    ## 8   on SW1 DIP switch (active-high)
+##
+
+# LCD display connector abused as GPIO.
+NET "gpio(0)"                    LOC = "T28";   ## RS
+NET "gpio(1)"                    LOC = "AC14";  ## RW
+NET "gpio(2)"                    LOC = "AK12";  ## E
+NET "gpio(3)"                    LOC = "AD14";  ## DB4
+NET "gpio(4)"                    LOC = "AK11";  ## DB5
+NET "gpio(5)"                    LOC = "AJ11";  ## DB6
+NET "gpio(6)"                    LOC = "AE12";  ## DB7
+NET "gpio(*)"                    IOSTANDARD = LVCMOS25;
+
+# LEDs.
+NET "led(0)"                    LOC = "AC22";   ## 1
+NET "led(1)"                    LOC = "AC24";   ## 2
+NET "led(2)"                    LOC = "AE22";   ## 3
+NET "led(3)"                    LOC = "AE23";   ## 4
+NET "led(4)"                    LOC = "AB23";   ## 5
+NET "led(5)"                    LOC = "AG23";   ## 6
+NET "led(6)"                    LOC = "AE24";   ## 7
+NET "led(7)"                    LOC = "AD24";   ## 8
+NET "led(8)"                    LOC = "AP24";   ## C
+NET "led(9)"                    LOC = "AD21";   ## W
+NET "led(10)"                   LOC = "AE21";   ## E
+NET "led(11)"                   LOC = "AH28";   ## S
+NET "led(12)"                   LOC = "AH27";   ## N
+NET "led(*)"                    IOSTANDARD = LVCMOS25;
+
+# GPIO switches.
+NET "dipsw(0)"                   LOC = "D22";   ## 1
+NET "dipsw(1)"                   LOC = "C22";   ## 2
+NET "dipsw(2)"                   LOC = "L21";   ## 3
+NET "dipsw(3)"                   LOC = "L20";   ## 4
+NET "dipsw(4)"                   LOC = "C18";   ## 5
+NET "dipsw(5)"                   LOC = "B18";   ## 6
+NET "dipsw(7)"                   LOC = "K22";   ## 7
+NET "dipsw(8)"                   LOC = "K21";   ## 8
+NET "dipsw(*)"                   IOSTANDARD = LVCMOS15;
+
+# Pushbuttons (except reset).
+NET "pbtn(0)"                    LOC = "G26";   ## C
+NET "pbtn(1)"                    LOC = "H17";   ## W
+NET "pbtn(2)"                    LOC = "G17";   ## E
+NET "pbtn(3)"                    LOC = "A18";   ## S
+NET "pbtn(4)"                    LOC = "A19";   ## N
+NET "pbtn(*)"                    IOSTANDARD = LVCMOS15;
+
+NET "dvi_iic_scl"                   LOC = "AN10";   ## 2   on Q5, 15 on U38
+NET "iic_scl_main"               LOC = "AK9";    ## 2   on Q19
+#NET "IIC_SCL_SFP"                   LOC = "AA34";   ## 2   on Q23
+NET "dvi_iic_sda"                   LOC = "AP10";   ## 2   on Q6, 14 on U38
+NET "iic_sda_main"               LOC = "AE9";    ## 2   on Q20
+#NET "IIC_SDA_SFP"                   LOC = "AA33";   ## 2   on Q21
+
+NET "tft_lcd_data(0)"                        LOC = "AJ19";   ## 63 on U38 (thru series R111 47.5 ohm)
+NET "tft_lcd_data(1)"                        LOC = "AH19";   ## 62 on U38 (thru series R110 47.5 ohm)
+NET "tft_lcd_data(2)"                        LOC = "AM17";   ## 61 on U38 (thru series R109 47.5 ohm)
+NET "tft_lcd_data(3)"                        LOC = "AM16";   ## 60 on U38 (thru series R108 47.5 ohm)
+NET "tft_lcd_data(4)"                        LOC = "AD17";   ## 59 on U38 (thru series R107 47.5 ohm)
+NET "tft_lcd_data(5)"                        LOC = "AE17";   ## 58 on U38 (thru series R106 47.5 ohm)
+NET "tft_lcd_data(6)"                        LOC = "AK18";   ## 55 on U38 (thru series R105 47.5 ohm)
+NET "tft_lcd_data(7)"                        LOC = "AK17";   ## 54 on U38 (thru series R104 47.5 ohm)
+NET "tft_lcd_data(8)"                        LOC = "AE18";   ## 53 on U38 (thru series R103 47.5 ohm)
+NET "tft_lcd_data(9)"                        LOC = "AF18";   ## 52 on U38 (thru series R102 47.5 ohm)
+NET "tft_lcd_data(10)"                       LOC = "AL16";   ## 51 on U38 (thru series R101 47.5 ohm)
+NET "tft_lcd_data(11)"                       LOC = "AK16";   ## 50 on U38 (thru series R100 47.5 ohm)
+NET "tft_lcd_de"                        LOC = "AD16";   ## 2  on U38 (thru series R112 47.5 ohm)
+#NET "DVI_GPIO1_FMC_C2M_PG_LS"       LOC = "K9";     ## 18 on U32 (not wired to U38)
+NET "tft_lcd_hsync"                         LOC = "AN17";   ## 4  on U38 (thru series R113 47.5 ohm)
+NET "tft_lcd_reset_b"                LOC = "AP17";   ## 2  on U32 (DVI_RESET_B pin 13 on U38)
+NET "tft_lcd_vsync"                         LOC = "AD15";   ## 5  on U38 (thru series R114 47.5 ohm)
+NET "tft_lcd_clk_n"                    LOC = "AC17";   ## 56 on U38
+NET "tft_lcd_clk_p"                    LOC = "AC18";   ## 57 on U38
+
+#NET "SYSACE_CFGTDI"                 LOC = "AC8";    ## 81  on U19
+NET "sysace_d(0)"                     LOC = "AM15";   ## 66  on U19
+NET "sysace_d(1)"                     LOC = "AJ17";   ## 65  on U19
+NET "sysace_d(2)"                     LOC = "AJ16";   ## 63  on U19
+NET "sysace_d(3)"                     LOC = "AP16";   ## 62  on U19
+NET "sysace_d(4)"                     LOC = "AG16";   ## 61  on U19
+NET "sysace_d(5)"                     LOC = "AH15";   ## 60  on U19
+NET "sysace_d(6)"                     LOC = "AF16";   ## 59  on U19
+NET "sysace_d(7)"                     LOC = "AN15";   ## 58  on U19
+NET "sysace_mpa(0)"                  LOC = "AC15";   ## 70  on U19
+NET "sysace_mpa(1)"                  LOC = "AP15";   ## 69  on U19
+NET "sysace_mpa(2)"                  LOC = "AG17";   ## 68  on U19
+NET "sysace_mpa(3)"                  LOC = "AH17";   ## 67  on U19
+NET "sysace_mpa(4)"                  LOC = "AG15";   ## 45  on U19
+NET "sysace_mpa(5)"                  LOC = "AF15";   ## 44  on U19
+NET "sysace_mpa(6)"                  LOC = "AK14";   ## 43  on U19
+#NET "SYSACE_MPBRDY"                 LOC = "AJ15";   ## 39  on U19
+NET "sysace_mpce"                   LOC = "AJ14";   ## 42  on U19
+NET "sysace_mpirq"                  LOC = "L9";     ## 41  on U19
+NET "sysace_mpoe"                   LOC = "AL15";   ## 77  on U19
+NET "sysace_mpwe"                   LOC = "AL14";   ## 76  on U19
+NET "clk_33"              LOC = "AE16";   ## 93  on U19
 NET "clk_33" PERIOD = 30.000 ;
 OFFSET = IN : 20.000 : BEFORE clk_33 ;
 OFFSET = OUT : 20.000 : AFTER clk_33 ;
@@ -585,29 +620,89 @@ OFFSET = OUT : 12.000 : AFTER gmiiclk_p;
 
 INST "uddr3ctrl/_infrastructure/u_mmcm_adv"      LOC = "MMCM_ADV_X0Y8"; #Banks 16, 26, 36
 
-# Constrain BUFR clocks used to synchronize data from IOB to fabric logic
-# Note that ISE cannot infer this from other PERIOD constraints because
-# of the use of OSERDES blocks in the BUFR clock generation path
-NET "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/clk_rsync[?]" TNM_NET = TNM_clk_rsync_xst;
-TIMESPEC "TS_clk_rsync_xst" = PERIOD "TNM_clk_rsync_xst" 5 ns;
-
-# Paths between DQ/DQS ISERDES.Q outputs and CLB flops clocked by falling 
-# edge of BUFR will by design only be used if DYNCLKDIVSEL is asserted for 
-# that particular flop. Mark this path as being a full-cycle, rather than 
-# a half cycle path for timing purposes. NOTE: This constraint forces full-
-# cycle timing to be applied globally for all rising->falling edge paths 
-# in all resynchronizaton clock domains. If the user had modified the logic
-# in the resync clock domain such that other rising->falling edge paths 
-# exist, then constraint below should be modified to utilize pattern 
-# matching to specific affect only the DQ/DQS ISERDES.Q outputs
-TIMEGRP "TG_clk_rsync_rise_xst" = RISING  "TNM_clk_rsync_xst";
-TIMEGRP "TG_clk_rsync_fall_xst" = FALLING "TNM_clk_rsync_xst";
-TIMESPEC "TS_clk_rsync_rise_to_fall_xst" = 
-  FROM "TG_clk_rsync_rise_xst" TO "TG_clk_rsync_fall_xst" "TS_sys_clk" * 2;
-
-# Signal to select between controller and physical layer signals. Four divided by two clock
-# cycles (8 memory clock cycles) are provided by design for the signal to settle down.
-# Used only by the phy modules.
-#INST "u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
-#TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = 10 ns;  ## = "2.5ns * 4" ML605 single clock
+# Constrain BUFR clocks used to synchronize data from IOB to fabric logic
+# Note that ISE cannot infer this from other PERIOD constraints because
+# of the use of OSERDES blocks in the BUFR clock generation path
+NET "ddr3ctrl/u_memc_ui_top/u_mem_intfc/phy_top0/clk_rsync[?]" TNM_NET = TNM_clk_rsync_xst;
+TIMESPEC "TS_clk_rsync_xst" = PERIOD "TNM_clk_rsync_xst" 5 ns;
+
+# Paths between DQ/DQS ISERDES.Q outputs and CLB flops clocked by falling 
+# edge of BUFR will by design only be used if DYNCLKDIVSEL is asserted for 
+# that particular flop. Mark this path as being a full-cycle, rather than 
+# a half cycle path for timing purposes. NOTE: This constraint forces full-
+# cycle timing to be applied globally for all rising->falling edge paths 
+# in all resynchronizaton clock domains. If the user had modified the logic
+# in the resync clock domain such that other rising->falling edge paths 
+# exist, then constraint below should be modified to utilize pattern 
+# matching to specific affect only the DQ/DQS ISERDES.Q outputs
+TIMEGRP "TG_clk_rsync_rise_xst" = RISING  "TNM_clk_rsync_xst";
+TIMEGRP "TG_clk_rsync_fall_xst" = FALLING "TNM_clk_rsync_xst";
+TIMESPEC "TS_clk_rsync_rise_to_fall_xst" = 
+  FROM "TG_clk_rsync_rise_xst" TO "TG_clk_rsync_fall_xst" "TS_sys_clk" * 2;
+
+# Signal to select between controller and physical layer signals. Four divided by two clock
+# cycles (8 memory clock cycles) are provided by design for the signal to settle down.
+# Used only by the phy modules.
+#INST "u_memc_ui_top/u_mem_intfc/phy_top0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
+#TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = 10 ns;  ## = "2.5ns * 4" ML605 single clock
+
+
+
+######################################################################################
+## DDR-PHY TIMEOUT BLOCK CONSTRAINTS                                                ##
+######################################################################################
+
+# Ignore timing on the following two signals. They cross clock domains, but are
+# treated as "external" asynchronous signals, so their timing is irrelevant.
+NET "reset_block/lockTimeoutRst" TIG;
+NET "reset_block/lockTimeout" TIG;
+
+
+
+######################################################################################
+## PCI-express signals (copied from reference project)                              ##
+######################################################################################
+#------------------------
+# Clock and Reset Pinout
+#------------------------
+NET "pcie_ref_clk" TNM_NET = "SYSCLK" ;
+NET "*/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
+NET "*/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
+
+TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 250.00 MHz HIGH 50 % ;
+TIMESPEC "TS_CLK_125" = PERIOD "CLK_125" TS_SYSCLK*0.5 HIGH 50 %; # PRIORITY 100 ;
+TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 250 MHz HIGH 50 %; # PRIORITY 100 ;
+
+NET "sys_reset_n" TIG;
+PIN "*/trn_reset_n_int_i.CLR" TIG ;
+PIN "*/trn_reset_n_i.CLR" TIG ;
+PIN "*/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
+
+#TIMESPEC "TS_TRNLNKUPN" = FROM FFS(*) TO FFS(trn_lnk_up_n_int_i) 4 ns;
+#TIMESPEC "TS_RESETN" = FROM FFS(*) TO FFS(trn_reset_n_i) 4 ns;
+TIMESPEC "TS_RESETN" = FROM FFS(*) TO FFS(user_reset) 8 ns;
+
+
+#-----------------------------------
+# PCIe Transceiver & Core Locations
+#-----------------------------------
+
+# PCIe Block Placement
+INST "*/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
+
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[0].GTX" LOC = GTXE1_X0Y15;
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[1].GTX" LOC = GTXE1_X0Y14;
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[2].GTX" LOC = GTXE1_X0Y13;
+INST "*/pcie_2_0_i/pcie_gt_i/gtx_v6_i/no_of_lanes.GTXD[3].GTX" LOC = GTXE1_X0Y12;
+
+#------------------------
+# Clock and Reset Pinout
+#------------------------
+
+NET  sys_reset_n           LOC  = AE13 | IOSTANDARD = LVCMOS25 | NODELAY;
+
+# 250 MHz Reference Clock
+INST "pcie_refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y4; # Implies pinout
 
+# MMCM Placment. This constraint selects the MMCM Placement
+INST "*/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.vhd work/leon3mp.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/leon3mp.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/leon3mp.vhd	2017-02-02 13:54:08.711581986 +0100
@@ -18,7 +18,7 @@
 --
 --  You should have received a copy of the GNU General Public License
 --  along with this program; if not, write to the Free Software
---  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
+--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ------------------------------------------------------------------------------
 
 library ieee;
@@ -45,10 +45,25 @@ library esa;
 use esa.memoryctrl.all;
 use work.config.all;
 use work.ml605.all;
-use work.pcie.all;
 -- pragma translate_off
 use gaisler.sim.all;
 -- pragma translate_on
+library rvex;
+use rvex.common_pkg.all;
+use rvex.bus_pkg.all;
+use rvex.bus_addrConv_pkg.all;
+use rvex.core_pkg.all;
+use rvex.cache_pkg.all;
+use rvex.rvsys_grlib_pkg.all;
+-- pragma translate_off
+use rvex.utils_pkg.all;
+use rvex.simUtils_pkg.all;
+use rvex.simUtils_mem_pkg.all;
+-- pragma translate_on
+library unisim;
+use unisim.vcomponents.all;
+library work;
+use work.platform_version_pkg.all;
 
 entity leon3mp is
   generic (
@@ -58,795 +73,1466 @@ entity leon3mp is
     disas    : integer := CFG_DISAS;     -- Enable disassembly to console
     dbguart  : integer := CFG_DUART;     -- Print UART on console
     pclow    : integer := CFG_PCLOW;
-    SIM_BYPASS_INIT_CAL : string := "OFF"
+    SIM_BYPASS_INIT_CAL : string := "OFF";
+    DISABLE_DDR_SIM : boolean := false
     );
   port (
-    reset     : in    std_ulogic;
-    errorn    : out   std_ulogic;
-    clk_ref_p     : in    std_logic;
-    clk_ref_n     : in    std_logic;
-
-    -- PROM interface
-    address   : out   std_logic_vector(23 downto 0);
-    data      : inout std_logic_vector(15 downto 0);
-    romsn     : out   std_ulogic;
-    oen       : out   std_ulogic;
-    writen    : out   std_ulogic;
-    alatch    : out   std_ulogic;
-
-    -- DDR3 memory
-    ddr3_dq       : inout std_logic_vector(DQ_WIDTH-1 downto 0);
-    ddr3_dm       : out   std_logic_vector(DM_WIDTH-1 downto 0);
-    ddr3_addr     : out   std_logic_vector(ROW_WIDTH-1 downto 0);
-    ddr3_ba       : out   std_logic_vector(BANK_WIDTH-1 downto 0);
-    ddr3_ras_n    : out   std_logic;
-    ddr3_cas_n    : out   std_logic;
-    ddr3_we_n     : out   std_logic;
-    ddr3_reset_n  : out   std_logic;
-    ddr3_cs_n     : out   std_logic_vector((CS_WIDTH*nCS_PER_RANK)-1 downto 0);
-    ddr3_odt      : out   std_logic_vector((CS_WIDTH*nCS_PER_RANK)-1 downto 0);
-    ddr3_cke      : out   std_logic_vector(CKE_WIDTH-1 downto 0);
-    ddr3_dqs_p    : inout std_logic_vector(DQS_WIDTH-1 downto 0);
-    ddr3_dqs_n    : inout std_logic_vector(DQS_WIDTH-1 downto 0);
-    ddr3_ck_p     : out   std_logic_vector(CK_WIDTH-1 downto 0);
-    ddr3_ck_n     : out   std_logic_vector(CK_WIDTH-1 downto 0);
-
-    -- Debug support unit
-    dsubre    : in    std_ulogic;       -- Debug Unit break (connect to button)
-
-    -- AHB Uart
-    dsurx     : in    std_ulogic;
-    dsutx     : out   std_ulogic;
-
-    -- Ethernet signals
-    gmiiclk_p : in    std_ulogic;
-    gmiiclk_n : in    std_ulogic;
-    egtx_clk  : out   std_ulogic;
-    etx_clk   : in    std_ulogic;
-    erx_clk   : in    std_ulogic;
-    erxd      : in    std_logic_vector(7 downto 0);
-    erx_dv    : in    std_ulogic;
-    erx_er    : in    std_ulogic;
-    erx_col   : in    std_ulogic;
-    erx_crs   : in    std_ulogic;
-    emdint    : in std_ulogic;
-    etxd      : out   std_logic_vector(7 downto 0);
-    etx_en    : out   std_ulogic;
-    etx_er    : out   std_ulogic;
-    emdc      : out   std_ulogic;
-    emdio     : inout std_logic;
-    erstn     : out   std_ulogic;
-
-    iic_scl_main    : inout std_ulogic;
-    iic_sda_main    : inout std_ulogic;
-
-    dvi_iic_scl     : inout std_logic;
-    dvi_iic_sda     : inout std_logic;
-
-    tft_lcd_data    : out std_logic_vector(11 downto 0);
-    tft_lcd_clk_p   : out std_ulogic;
-    tft_lcd_clk_n   : out std_ulogic;
-    tft_lcd_hsync   : out std_ulogic;
-    tft_lcd_vsync   : out std_ulogic;
-    tft_lcd_de      : out std_ulogic;
-    tft_lcd_reset_b : out std_ulogic;
-
-    clk_33          : in  std_ulogic;	-- SYSACE clock
-    sysace_mpa      : out std_logic_vector(6 downto 0);
-    sysace_mpce     : out std_ulogic;
-    sysace_mpirq    : in  std_ulogic;
-    sysace_mpoe     : out std_ulogic;
-    sysace_mpwe     : out std_ulogic;
-    sysace_d        : inout std_logic_vector(7 downto 0);
-
-    pci_exp_txp : out std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-    pci_exp_txn : out std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-    pci_exp_rxp : in std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-    pci_exp_rxn : in std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-
-    sys_clk_p   : in  std_logic;
-    sys_clk_n   : in  std_logic;
-    sys_reset_n : in  std_logic;
-
-
-    -- Output signals to LEDs
-    led       : out   std_logic_vector(6 downto 0)
-    );
+    
+    -- System control.
+    reset                       : in    std_ulogic;
+    clk_ref_p                   : in    std_logic; -- 200 MHz.
+    clk_ref_n                   : in    std_logic;
+    gmiiclk_p                   : in    std_ulogic; -- 125 MHz.
+    gmiiclk_n                   : in    std_ulogic;
+    clk_33                      : in    std_ulogic; -- 33 MHz.
+    
+    -- DDR3 memory.
+    ddr3_dq                     : inout std_logic_vector(DQ_WIDTH-1 downto 0);
+    ddr3_dm                     : out   std_logic_vector(DM_WIDTH-1 downto 0);
+    ddr3_addr                   : out   std_logic_vector(ROW_WIDTH-1 downto 0);
+    ddr3_ba                     : out   std_logic_vector(BANK_WIDTH-1 downto 0);
+    ddr3_ras_n                  : out   std_logic;
+    ddr3_cas_n                  : out   std_logic;
+    ddr3_we_n                   : out   std_logic;
+    ddr3_reset_n                : out   std_logic;
+    ddr3_cs_n                   : out   std_logic_vector((CS_WIDTH*nCS_PER_RANK)-1 downto 0);
+    ddr3_odt                    : out   std_logic_vector((CS_WIDTH*nCS_PER_RANK)-1 downto 0);
+    ddr3_cke                    : out   std_logic_vector(CKE_WIDTH-1 downto 0);
+    ddr3_dqs_p                  : inout std_logic_vector(DQS_WIDTH-1 downto 0);
+    ddr3_dqs_n                  : inout std_logic_vector(DQS_WIDTH-1 downto 0);
+    ddr3_ck_p                   : out   std_logic_vector(CK_WIDTH-1 downto 0);
+    ddr3_ck_n                   : out   std_logic_vector(CK_WIDTH-1 downto 0);
+
+    -- System ACE (compact flash card)
+    sysace_mpa                  : out std_logic_vector(6 downto 0);
+    sysace_mpce                 : out std_ulogic;
+    sysace_mpirq                : in  std_ulogic;
+    sysace_mpoe                 : out std_ulogic;
+    sysace_mpwe                 : out std_ulogic;
+    sysace_d                    : inout std_logic_vector(7 downto 0);
+    
+    -- DVI/VGA interface.
+    tft_lcd_data                : out   std_logic_vector(11 downto 0);
+    tft_lcd_clk_p               : out   std_ulogic;
+    tft_lcd_clk_n               : out   std_ulogic;
+    tft_lcd_hsync               : out   std_ulogic;
+    tft_lcd_vsync               : out   std_ulogic;
+    tft_lcd_de                  : out   std_ulogic;
+    tft_lcd_reset_b             : out   std_ulogic;
+    
+    -- DVI I2C port.
+    dvi_iic_scl                 : inout std_logic;
+    dvi_iic_sda                 : inout std_logic;
+    
+    -- PMBus I2C port.
+    pmbus_scl                   : inout std_logic;
+    pmbus_sda                   : inout std_logic;
+    
+    -- Debug UART.
+    dsurx                       : in    std_ulogic;
+    dsutx                       : out   std_ulogic;
+    
+    -- GPIO.
+    gpio                        : inout std_logic_vector(6 downto 0)  := (others => 'Z'); -- LCD pins.
+    led                         : inout std_logic_vector(12 downto 0) := (others => '0'); -- LEDs (1..8, CWESN)
+    dipsw                       : in    std_logic_vector(7 downto 0)  := (others => '0'); -- DIP switches (1..8)
+    pbtn                        : in    std_logic_vector(4 downto 0)  := (others => '0')  -- Pushbuttons (CWESN)
+    
+  );
 end;
 
 architecture rtl of leon3mp is
-
-  signal vcc : std_logic;
-  signal gnd : std_logic;
-
-  signal memi : memory_in_type;
-  signal memo : memory_out_type;
-  signal wpo  : wprot_out_type;
-
-  signal gpioi : gpio_in_type;
-  signal gpioo : gpio_out_type;
-
-  signal apbi  : apb_slv_in_type;
-  signal apbo  : apb_slv_out_vector := (others => apb_none);
-  signal ahbsi : ahb_slv_in_type;
-  signal ahbso : ahb_slv_out_vector := (others => ahbs_none);
-  signal ahbmi : ahb_mst_in_type;
-  signal ahbmo : ahb_mst_out_vector := (others => ahbm_none);
-
-  signal u1i, dui : uart_in_type;
-  signal u1o, duo : uart_out_type;
-
-  signal irqi : irq_in_vector(0 to CFG_NCPU-1);
-  signal irqo : irq_out_vector(0 to CFG_NCPU-1);
-
-  signal dbgi : l3_debug_in_vector(0 to CFG_NCPU-1);
-  signal dbgo : l3_debug_out_vector(0 to CFG_NCPU-1);
-
-  signal dsui : dsu_in_type;
-  signal dsuo : dsu_out_type;
-
-  signal fpi : grfpu_in_vector_type;
-  signal fpo : grfpu_out_vector_type;
-
-  signal ethi : eth_in_type;
-  signal etho : eth_out_type;
-
-  signal gpti : gptimer_in_type;
-
-  signal lclk, clk_ddr, lclk200      : std_ulogic;
-  signal clkm, rstn, clkml  : std_ulogic;
-  signal tck, tms, tdi, tdo : std_ulogic;
-  signal rstraw             : std_logic;
-  signal lock               : std_logic;
-
-  signal tb_rst        : std_logic;
-  signal tb_clk        : std_logic;
-  signal phy_init_done : std_logic;
-  signal lerrorn        : std_logic;
-
-  -- RS232 APB Uart
-  signal rxd1 : std_logic;
-  signal txd1 : std_logic;
-
--- VGA
-  signal vgao  : apbvga_out_type;
-  signal lcd_datal : std_logic_vector(11 downto 0);
-  signal lcd_hsyncl, lcd_vsyncl, lcd_del, lcd_reset_bl : std_ulogic;
-  signal clk_sel : std_logic_vector(1 downto 0);
-  signal clk100 : std_ulogic;
-  signal clkvga, clkvga_p, clkvga_n : std_ulogic;
-
--- IIC
-
-  signal i2ci, dvi_i2ci : i2c_in_type;
-  signal i2co, dvi_i2co : i2c_out_type;
-
--- SYSACE
-  signal clkace : std_ulogic;
-  signal acei   : gracectrl_in_type;
-  signal aceo   : gracectrl_out_type;
-
-  -- Used for connecting input/output signals to the DDR3 controller
-  signal migi		: mig_app_in_type;
-  signal migo		: mig_app_out_type;
-
-  attribute keep                     : boolean;
-  attribute syn_keep                 : boolean;
-  attribute syn_preserve             : boolean;
-  attribute syn_keep of lock         : signal is true;
-  attribute syn_keep of clk_ddr        : signal is true;
-  attribute syn_keep of clkm         : signal is true;
-  attribute syn_preserve of clkm     : signal is true;
-  attribute syn_preserve of clk_ddr     : signal is true;
-  attribute keep of lock             : signal is true;
-  attribute keep of clkm             : signal is true;
-  attribute keep of clk_ddr             : signal is true;
-
-  constant VCO_FREQ  : integer := 1200000;                               -- MMCM VCO frequency in KHz
-  constant CPU_FREQ   : integer := VCO_FREQ / CFG_MIG_CLK4;  -- cpu frequency in KHz
-  constant I2C_FILTER : integer := (CPU_FREQ*5+50000)/100000+1;
+  
+  -- Attribute declarations.
+  attribute keep                  : boolean;
+  attribute syn_keep              : boolean;
+  attribute syn_preserve          : boolean;
+  
+  -- Clocks.
+  constant VCO_FREQ               : integer := 1200000; -- MMCM VCO frequency in KHz
+  
+  signal clk125                   : std_ulogic; -- 125 MHz from ethernet osc.
+  signal clk100                   : std_ulogic; -- 100 MHz clock generated by the MIG.
+  signal clk33                    : std_ulogic; -- 33 MHz from sysACE osc.
+  
+  signal clkm                     : std_ulogic;
+  attribute syn_keep       of clkm: signal is true;
+  attribute syn_preserve   of clkm: signal is true;
+  attribute keep           of clkm: signal is true;
+  constant CLKM_FREQ              : integer := VCO_FREQ / CFG_MIG_CLK4;
+  
+  -- PPL lock/reset bullshit.
+  signal rstn                     : std_ulogic;
+  signal rstraw                   : std_logic;
+  signal lock                     : std_logic;
+  attribute syn_keep       of lock: signal is true;
+  attribute keep           of lock: signal is true;
+  
+  -- Memory controller stuff.
+  signal migi		                  : mig_app_in_type;
+  signal migo		                  : mig_app_out_type;
+  signal clkddr                   : std_ulogic;
+  attribute syn_keep     of clkddr: signal is true;
+  attribute syn_preserve of clkddr: signal is true;
+  attribute keep         of clkddr: signal is true;
+  signal phy_init_done            : std_logic;
+
+  -- AHB/APB/r-VEX bus.
+  constant N_RVB_SLAVES           : integer := CFG_NRVEX + 3;
+  signal apbi                     : apb_slv_in_type;
+  signal apbo                     : apb_slv_out_vector := (others => apb_none);
+  signal ahbsi                    : ahb_slv_in_type;
+  signal ahbso                    : ahb_slv_out_vector := (others => ahbs_none);
+  signal ahbmi                    : ahb_mst_in_type;
+  signal ahbmo                    : ahb_mst_out_vector := (others => ahbm_none);
+  signal rvbmo                    : bus_mst2slv_type;
+  signal rvbmi                    : bus_slv2mst_type;
+  signal rvbsi                    : bus_mst2slv_array(0 to N_RVB_SLAVES - 1);
+  signal rvbso                    : bus_slv2mst_array(0 to N_RVB_SLAVES - 1);
+  
+  -- Interrupt controller interface signals.
+  signal irqi                     : irq_in_vector(0 to CFG_NCPU-1);
+  signal irqo                     : irq_out_vector(0 to CFG_NCPU-1);
+  
+  -- Audio output.
+  signal audio_next               : std_logic; -- Samplerate, controlled by gptim 3
+  signal audio_irq                : std_logic;
+  
+  -- Internal DIP switch state (i.e. after the IBUF).
+  signal dipsw_int                : std_logic_vector(7 downto 0)  := (others => '0');
 
 begin
+  
+  ------------------------------------------------------------------------------
+  -- Clocking stuff
+  ------------------------------------------------------------------------------
+  
+  -- 125 MHz clock from the Ethernet oscillator.
+  gtxclk0 : entity work.gtxclk
+    port map (
+      clk_p   => gmiiclk_p,
+      clk_n   => gmiiclk_n,
+      clkint  => clk125,
+      clkout  => open
+    );
+  
+  -- 33 MHz clock from the system ACE oscillator.
+  clk_33_pad : clkpad
+    generic map (
+      level   => cmos,
+      voltage => x25v,
+      tech    => padtech
+    )
+    port map (
+      pad     => clk_33,
+      o       => clk33
+    );
+  
+  -- PLL lock signal.
+  lock <= phy_init_done;
+  led(1) <= phy_init_done;
+  
+  
+  ------------------------------------------------------------------------------
+  -- Reset stuff
+  ------------------------------------------------------------------------------
+  
+  reset_block: block is
 
-----------------------------------------------------------------------
----  Reset and Clock generation  -------------------------------------
-----------------------------------------------------------------------
-
-  vcc <= '1';
-  gnd <= '0';
-  alatch <= '0';
-  erstn <= rstn;
-
-  -- Glitch free reset that can be used for the Eth Phy and flash memory
-
-  rst0 : rstgen generic map (acthigh => 1)
-    port map (reset, clkm, lock, rstn, rstraw);
-
-----------------------------------------------------------------------
----  AHB CONTROLLER --------------------------------------------------
-----------------------------------------------------------------------
-
-  ahb0 : ahbctrl
-    generic map (defmast => CFG_DEFMST, split => CFG_SPLIT,
-                 rrobin  => CFG_RROBIN, ioaddr => CFG_AHBIO, ioen => 1,
-                 nahbm => CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE+CFG_PCIEXP,
-                 nahbs => 9)
-    port map (rstn, clkm, ahbmi, ahbmo, ahbsi, ahbso);
-
-----------------------------------------------------------------------
----  LEON3 processor and DSU -----------------------------------------
-----------------------------------------------------------------------
-
-  -- LEON3 processor
-  nosh : if CFG_GRFPUSH = 0 generate
-    cpu : for i in 0 to CFG_NCPU-1 generate
-      l3ft : if CFG_LEON3FT_EN /= 0 generate
-        leon3ft0 : leon3ft		-- LEON3 processor
-        generic map (i, fabtech, memtech, CFG_NWIN, CFG_DSU, CFG_FPU*(1-CFG_GRFPUSH), CFG_V8,
-  	  0, CFG_MAC, pclow, CFG_NOTAG, CFG_NWP, CFG_ICEN, CFG_IREPL, CFG_ISETS, CFG_ILINE,
-	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
-	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
-          CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
-	  CFG_IUFT_EN, CFG_FPUFT_EN, CFG_CACHE_FT_EN, CFG_RF_ERRINJ,
-	  CFG_CACHE_ERRINJ, CFG_DFIXED, CFG_LEON3_NETLIST, CFG_SCAN, CFG_MMU_PAGE)
-        port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
-    		irqi(i), irqo(i), dbgi(i), dbgo(i), clkm);
-      end generate;
-
-      l3s : if CFG_LEON3FT_EN = 0 generate
-        u0 : leon3s 		-- LEON3 processor
-        generic map (i, fabtech, memtech, CFG_NWIN, CFG_DSU, CFG_FPU*(1-CFG_GRFPUSH), CFG_V8,
-	  0, CFG_MAC, pclow, CFG_NOTAG, CFG_NWP, CFG_ICEN, CFG_IREPL, CFG_ISETS, CFG_ILINE,
-	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
-	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
-          CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
-	  CFG_DFIXED, CFG_SCAN, CFG_MMU_PAGE)
-        port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
-    		irqi(i), irqo(i), dbgi(i), dbgo(i));
-      end generate;
-    end generate;
-  end generate;
-
-  sh : if CFG_GRFPUSH = 1 generate
-    cpu : for i in 0 to CFG_NCPU-1 generate
-      l3ft : if CFG_LEON3FT_EN /= 0 generate
-        leon3ft0 : leon3ftsh		-- LEON3 processor
-        generic map (i, fabtech, memtech, CFG_NWIN, CFG_DSU, CFG_FPU, CFG_V8,
-  	  0, CFG_MAC, pclow, CFG_NOTAG, CFG_NWP, CFG_ICEN, CFG_IREPL, CFG_ISETS, CFG_ILINE,
-	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
-	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
-          CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
-	  CFG_IUFT_EN, CFG_FPUFT_EN, CFG_CACHE_FT_EN, CFG_RF_ERRINJ,
-	  CFG_CACHE_ERRINJ, CFG_DFIXED, CFG_LEON3_NETLIST, CFG_SCAN, CFG_MMU_PAGE)
-        port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
-    		irqi(i), irqo(i), dbgi(i), dbgo(i), clkm,  fpi(i), fpo(i));
-
-      end generate;
-      l3s : if CFG_LEON3FT_EN = 0 generate
-        u0 : leon3sh 		-- LEON3 processor
-        generic map (i, fabtech, memtech, CFG_NWIN, CFG_DSU, CFG_FPU, CFG_V8,
-	  0, CFG_MAC, pclow, CFG_NOTAG, CFG_NWP, CFG_ICEN, CFG_IREPL, CFG_ISETS, CFG_ILINE,
-	  CFG_ISETSZ, CFG_ILOCK, CFG_DCEN, CFG_DREPL, CFG_DSETS, CFG_DLINE, CFG_DSETSZ,
-	  CFG_DLOCK, CFG_DSNOOP, CFG_ILRAMEN, CFG_ILRAMSZ, CFG_ILRAMADDR, CFG_DLRAMEN,
-          CFG_DLRAMSZ, CFG_DLRAMADDR, CFG_MMUEN, CFG_ITLBNUM, CFG_DTLBNUM, CFG_TLB_TYPE, CFG_TLB_REP,
-          CFG_LDDEL, disas, CFG_ITBSZ, CFG_PWD, CFG_SVT, CFG_RSTADDR, CFG_NCPU-1,
-	  CFG_DFIXED, CFG_SCAN, CFG_MMU_PAGE)
-        port map (clkm, rstn, ahbmi, ahbmo(i), ahbsi, ahbso,
-    		irqi(i), irqo(i), dbgi(i), dbgo(i), fpi(i), fpo(i));
-      end generate;
-    end generate;
-
-    grfpush0 : grfpushwx generic map ((CFG_FPU-1), CFG_NCPU, fabtech)
-    port map (clkm, rstn, fpi, fpo);
-
-  end generate;
-
-  lerrorn <= dbgo(0).error and rstn;
-  error_pad : odpad generic map (level => cmos, voltage => x25v, tech => padtech) port map (errorn, lerrorn);
-
-  dsugen : if CFG_DSU = 1 generate
-    -- LEON3 Debug Support Unit
-    dsugen : if CFG_DSU = 1 generate
-      dsu0 : dsu3
-        generic map (hindex => 2, haddr => 16#900#, hmask => 16#F00#,
-                     ncpu   => CFG_NCPU, tbits => 30, tech => memtech, irq => 0, kbytes => CFG_ATBSZ)
-        port map (rstn, clkm, ahbmi, ahbsi, ahbso(2), dbgo, dbgi, dsui, dsuo);
-
-      dsubre_pad : inpad generic map (level => cmos, voltage => x15v, tech  => padtech) port map (dsubre, dsui.break);
-
-      dsui.enable <= '1';
-      led(2) <= dsuo.active;
-    end generate;
-  end generate;
-  nodsu : if CFG_DSU = 0 generate
-    ahbso(2) <= ahbs_none; dsuo.tstop <= '0'; dsuo.active <= '0';
-  end generate;
-
-  -- Debug UART
-  dcomgen : if CFG_AHB_UART = 1 generate
-    dcom0 : ahbuart
-      generic map (hindex => CFG_NCPU, pindex => 4, paddr => 7)
-      port map (rstn, clkm, dui, duo, apbi, apbo(4), ahbmi, ahbmo(CFG_NCPU));
-    dsurx_pad : inpad generic map (level => cmos, voltage => x25v, tech  => padtech) port map (dsurx, dui.rxd);
-    dsutx_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech) port map (dsutx, duo.txd);
-    led(0) <= not dui.rxd;
-    led(1) <= not duo.txd;
-  end generate;
-  nouah : if CFG_AHB_UART = 0 generate apbo(4) <= apb_none; end generate;
-
-  ahbjtaggen0 :if CFG_AHB_JTAG = 1 generate
-    ahbjtag0 : ahbjtag generic map(tech => fabtech, hindex => CFG_NCPU+CFG_AHB_UART)
-      port map(rstn, clkm, tck, tms, tdi, tdo, ahbmi, ahbmo(CFG_NCPU+CFG_AHB_UART),
-               open, open, open, open, open, open, open, gnd);
-  end generate;
-
-----------------------------------------------------------------------
----  Memory controllers ----------------------------------------------
-----------------------------------------------------------------------
-
-  mg2 : if CFG_MCTRL_LEON2 = 1 generate        -- LEON2 memory controller
-    sr1 : mctrl generic map (hindex => 5, pindex => 0, paddr => 0,
-	ram8 => CFG_MCTRL_RAM8BIT, ram16 => CFG_MCTRL_RAM16BIT, iomask => 0, rammask => 0)
-      port map (rstn, clkm, memi, memo, ahbsi, ahbso(5), apbi, apbo(0), wpo, open);
-  end generate;
-
-  memi.brdyn  <= '1';
-  memi.bexcn  <= '1';
-  memi.writen <= '1';
-  memi.wrn    <= "1111";
-  memi.bwidth <= "01";
-
-  mg0 : if (CFG_MCTRL_LEON2 = 0) generate
-    apbo(0) <= apb_none;
-    ahbso(5) <= ahbs_none;
-    roms_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (romsn, vcc);
-    memo.bdrive(0) <= '1';
-  end generate;
-
-  mgpads : if (CFG_MCTRL_LEON2 /= 0) generate
-    addr_pad : outpadv generic map (level => cmos, voltage => x25v, tech => padtech, width => 24)
-      port map (address, memo.address(24 downto 1));
-    roms_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (romsn, memo.romsn(0));
-    oen_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (oen, memo.oen);
-    wri_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (writen, memo.writen);
-  end generate;
-
-  bdr : iopadvv generic map (level => cmos, voltage => x25v, tech => padtech, width => 16)
-    port map (data(15 downto 0), memo.data(31 downto 16),
-              memo.vbdrive(31 downto 16), memi.data(31 downto 16));
-
-----------------------------------------------------------------------
----  DDR3 memory controller ------------------------------------------
-----------------------------------------------------------------------
-
---  mig_gen : if (CFG_MIG_DDR2 = 1) generate
-
-    ahb2mig0 : ahb2mig_ml605
-      generic map ( hindex => 0, haddr => 16#400#, hmask => 16#E00#,
-    MHz => 400, Mbyte => 512, nosync => boolean'pos(CFG_MIG_CLK4=12)) --CFG_CLKDIV/12)
+    signal lockTimeoutRst   : std_logic;
+    signal lockTimeoutA     : unsigned(12 downto 0) := (others => '0');
+    signal lockTimeoutB     : unsigned(13 downto 0) := (others => '0');
+    signal lockTimeout      : std_logic;
+    signal resetOrTimeout   : std_logic;
+
+    -- lockTimeoutRst and lockTimeout cross two independent clock domains.
+    -- Their timing is completely irrelevant because they're treated as
+    -- asynchronous signals, so we need to disable timing checking for these
+    -- signals. To do that, we can't have them be optimized away, so we need
+    -- to attach the KEEP property to them. The actual TIG constraint has to
+    -- be placed in the UCF file.
+    attribute KEEP                    : string;
+    attribute KEEP of lockTimeoutRst  : signal is "TRUE";
+    attribute KEEP of lockTimeout     : signal is "TRUE";
+
+  begin
+
+    -- Generate reset signal for the clock lock/PHY init timeout.
+    lockTimeoutRst <= reset or lock;
+
+    -- Generate the lock/PHY timeout counters. Use the clkace 33 MHz clock
+    -- signal for this instead of clkm, because clkace always runs,
+    -- whereas clkm comes from an MMCM in the MIG, which is reset when
+    -- we generate a timeout.
+    lock_timeout_proc: process (clk33) is
+    begin
+      if rising_edge(clk33) then
+        if lockTimeoutRst = '1' then
+          lockTimeoutA  <= (others => '0');
+          lockTimeoutB  <= (others => '0');
+          lockTimeout   <= '0';
+        else
+          if lockTimeoutA(12) = '0' then
+            lockTimeoutA <= lockTimeoutA + 1;
+          else
+            lockTimeoutA <= (others => '0');
+            if lockTimeoutB(13) = '0' then
+              lockTimeoutB <= lockTimeoutB + 1;
+            else
+              lockTimeoutB <= (others => '0');
+            end if;
+          end if;
+          lockTimeout <= lockTimeoutB(12) and lockTimeoutB(11)
+                     and lockTimeoutB(10) and lockTimeoutB(9);
+        end if;
+      end if;
+    end process;
+
+    -- Combine the incoming reset signal with the lock timeout.
+    resetOrTimeout <= reset or lockTimeout;
+
+    -- Original reset generator.
+    rst0 : rstgen
+      generic map (
+        acthigh   => 1
+      )
       port map (
-    rst => rstn, clk_ahb => clkm, clk_ddr => clk_ddr,
-    ahbsi => ahbsi, ahbso => ahbso(0), migi => migi, migo => migo);
+        rstin     => resetOrTimeout,
+        clk       => clkm,
+        clklock   => lock,
+        rstout    => rstn,
+        rstoutraw => rstraw
+      );
 
-    ddr3ctrl : entity work.mig_37
-     generic map (SIM_BYPASS_INIT_CAL => SIM_BYPASS_INIT_CAL,CLKOUT_DIVIDE4 => work.config.CFG_MIG_CLK4)
-     port map(
-      clk_ref_p         =>   clk_ref_p,
-      clk_ref_n         =>   clk_ref_n,
-      ddr3_dq           =>   ddr3_dq,
-      ddr3_addr         =>   ddr3_addr,
-      ddr3_ba           =>   ddr3_ba,
-      ddr3_ras_n        =>   ddr3_ras_n,
-      ddr3_cas_n        =>   ddr3_cas_n,
-      ddr3_we_n         =>   ddr3_we_n,
-      ddr3_reset_n      =>   ddr3_reset_n,
-      ddr3_cs_n         =>   ddr3_cs_n,
-      ddr3_odt          =>   ddr3_odt,
-      ddr3_cke          =>   ddr3_cke,
-      ddr3_dm           =>   ddr3_dm,
-      ddr3_dqs_p        =>   ddr3_dqs_p,
-      ddr3_dqs_n        =>   ddr3_dqs_n,
-      ddr3_ck_p         =>   ddr3_ck_p,
-      ddr3_ck_n         =>   ddr3_ck_n,
-      app_wdf_wren      =>   migi.app_wdf_wren,
-      app_wdf_data      =>   migi.app_wdf_data,
-      app_wdf_mask      =>   migi.app_wdf_mask,
-      app_wdf_end       =>   migi.app_wdf_end,
-      app_addr          =>   migi.app_addr,
-      app_cmd           =>   migi.app_cmd,
-      app_en            =>   migi.app_en,
-      app_rdy           =>   migo.app_rdy,
-      app_wdf_rdy       =>   migo.app_wdf_rdy,
-      app_rd_data       =>   migo.app_rd_data,
-      app_rd_data_valid =>   migo.app_rd_data_valid,
-      tb_rst            =>   open,
-      tb_clk            =>   clk_ddr,
-      clk_ahb           =>   clkm,
-      clk100            =>   clk100,
-      phy_init_done     =>   phy_init_done,
-      sys_rst_13        =>   reset,
-      sys_rst_14        =>   rstraw
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- Bus control
+  ------------------------------------------------------------------------------
+  -- Masters:
+  --   0: r-VEX lane group 0
+  --   1: r-VEX lane group 1
+  --   2: r-VEX lane group 2
+  --   3: r-VEX lane group 3
+  --   4: monitor r-VEX
+  --   5: svgactrl (prioritized over all other masters)
+  --   6: ahbjtag
+  --   7: bus2ahb (debug UART)
+  --
+  -- AHB slaves:
+  --   0: ahb2mig     0x00000000..0x3FFFFFFF
+  --   1: apbctrl     0x80000000..0x8FFFFFFF
+  --   2: gracectrl   0xFFF90000..0xFFF9FFFF
+  --   3: ahb2bus     0xD0000000..0xDFFFFFFF
+  --
+  -- APB slaves:
+  --   0: apbps2      0x80000000..0x800000FF                IRQ 6
+  --   1: apbps2      0x80000100..0x800001FF                IRQ 7
+  --   2: irqmp       0x80000200..0x800002FF
+  --   3: gptimer     0x80000300..0x800003FF                IRQ 8, IRQ 9 (gettimeofday or general purpose)
+  --   4: gptimer     0x80000400..0x800004FF                IRQ 1 (tick and audio clock)
+  --   5: gpio        0x80000500..0x800005FF                IRQ 10
+  --   6: svgactrl    0x80000600..0x800006FF
+  --   7: i2cmst      0x80000700..0x800007FF                IRQ 11 (Chrontel DAC and DVI)
+  --   8: i2cmst      0x80000800..0x800008FF                IRQ 12 (PMBus)
+  --   9: i2cmst      0x80000900..0x800009FF                IRQ 13 (external)
+  --  10: only used for registering r-VEX bus interrupts
+  --
+  -- r-VEX bus slaves:
+  --   r-VEX          0xD0000000..0xD00FFFFF
+  --   debug UART     0xD1000000..0xD1000007                IRQ 2
+  --   audio buffer   0xD2000000..0xD2000003                IRQ 5
+  --   monitor r-VEX  0xD3000000..0xD3FFFFFF
+  --    |- IMEM       0xD3100000..0xD311FFFF
+  --    |- DMEM       0xD3200000..0xD321FFFF
+  --    |- IDMEM      0xD3300000..0xD331FFFF
+  --    |- trace      0xD3E00000..0xD3E01FFF
+  --    '- r-VEX      0xD3F00000..0xD3FFFFFF
+  --
+  -- Memory map:
+  --    .-----------.---------------.------------.-----.----------------------------------------------.
+  --    | Periph.   | Address space | Bw. compat.| IRQ | Description                                  |
+  --    |- - - - - -+- - - - - - - - `------. - -+- - -+- - - - - - - - - - - - - - - - - - - - - - - |
+  --    | ahbmig    | 0x00000000..0x3FFFFFFF | * |     | Main memory                                  |
+  --    | ---       | 0x40000000..0x7FFFFFFF |   |     | ---                                          |
+  --    | apbps2    | 0x80000000..0x800000FF |   | 6   | Bottom PS/2 connector                        |
+  --    | apbps2    | 0x80000100..0x800001FF |   | 7   | Top PS/2 connector                           |
+  --    | irqmp     | 0x80000200..0x800002FF | * |     | Interrupt controller                         |
+  --    | gptimer   | 0x80000300..0x800003FF | * | 8,9 | gettimeofday() or general purpose timers     |
+  --    | gptimer   | 0x80000400..0x800004FF |   | 1   | System tick and audio samplerate timers      |
+  --    | gpio      | 0x80000500..0x800005FF |   | 10  | Switches, buttons, LEDs                      |
+  --    | svgactrl  | 0x80000600..0x800006FF | * |     | VGA controller                               |
+  --    | i2cmst    | 0x80000700..0x800007FF |   | 11  | Chrontel DAC and DVI I2C bus                 |
+  --    | i2cmst    | 0x80000800..0x800008FF |   | 12  | PMBus                                        |
+  --    | i2cmst    | 0x80000900..0x800009FF |   | 13  | External I2C bus for Zebro                   |
+  --    | ---       | 0x80000A00..0xCFFFFFFF |   |     | ---                                          |
+  --    | rvex      | 0xD0000000..0xD0001FFF | * |     | Primary r-VEX core                           |
+  --    | trace     | 0xD0002000..0xD0003FFF | * |     | Trace buffer for primary r-VEX core          |
+  --    | ---       | 0xD0004000..0xD0FFFFFF |   |     | ---                                          |
+  --    | dbguart   | 0xD1000000..0xD1000007 | * | 2   | Debug UART                                   |
+  --    | ---       | 0xD1000008..0xD1FFFFFF |   |     | ---                                          |
+  --    | audio     | 0xD2000000..0xD2000003 |   | 5   | Audio output buffer access                   |
+  --    | ---       | 0xD2000004..0xD30FFFFF |   |     | ---                                          |
+  --    | blockram  | 0xD3100000..0xD311FFFF |   |     | Instruction memory for secondary r-VEX core  |
+  --    | ---       | 0xD3120000..0xD31FFFFF |   |     | ---                                          |
+  --    | blockram  | 0xD3200000..0xD321FFFF |   |     | Data memory for secondary r-VEX core         |
+  --    | ---       | 0xD3220000..0xD32FFFFF |   |     | ---                                          |
+  --    | shadow    | 0xD3300000..0xD331FFFF |   |     | Write-only area affecting both IMEM and DMEM |
+  --    | ---       | 0xD3320000..0xD3DFFFFF |   |     | ---                                          |
+  --    | trace     | 0xD3E00000..0xD3E01FFF |   |     | Trace buffer for secondary r-VEX core        |
+  --    | ---       | 0xD3E02000..0xD3EFFFFF |   |     | ---                                          |
+  --    | rvex      | 0xD3F00000..0xD3F003FF |   |     | Secondary r-VEX core                         |
+  --    | ---       | 0xD3F00400..0xFFF8FFFF |   |     | ---                                          |
+  --    | gracectrl | 0xFFF90000..0xFFF9FFFF |   |     | System ACE interface (compact flash)         |
+  --    | ---       | 0xFFFE0000..0xFFFFFFFF |   |     | ---                                          |
+  --    '-----------'------------------------'---'-----'----------------------------------------------'
+  --
+  -- Bw. compat.: backwards compatible with old grlib platform.
+  
+  -- AHB controller.
+  ahb : ahbctrl
+    generic map (
+      rrobin                    => 1,
+      nahbm                     => CFG_NCPU+4,
+      nahbs                     => 4,
+      split                     => 1,              -- The System ACE interface can use split transfers.
+      mprio                     => 2**(CFG_NCPU+1) -- Prioritize the SVGA controller so the screen doesn't flicker.
+    )
+    port map (
+      rst                       => rstn,
+      clk                       => clkm,
+      msti                      => ahbmi,
+      msto                      => ahbmo,
+      slvi                      => ahbsi,
+      slvo                      => ahbso
     );
-
-    led(3)  <= phy_init_done;
-    led(4)  <= rstn;
-    led(5)  <= reset;
-    led(6)  <= '0';
-    lock    <= phy_init_done; -- and cgo.clklock;
-
---    end generate;
---    noddr : if (CFG_DDR2SP+CFG_MIG_DDR2) = 0 generate lock <= cgo.clklock; end generate;
- 
-----------------------------------------------------------------------
----  System ACE I/F Controller ---------------------------------------
-----------------------------------------------------------------------
-
-  grace: if CFG_GRACECTRL = 1 generate
-    grace0 : gracectrl generic map (hindex => 7, hirq => 10, mode => 2,
-        haddr => 16#002#, hmask => 16#fff#, split => CFG_SPLIT)
-      port map (rstn, clkm, clkace, ahbsi, ahbso(7), acei, aceo);
-  end generate;
-  nograce: if CFG_GRACECTRL /= 1 generate
-    aceo <= gracectrl_none;
-  end generate;
-
-  clk_33_pad : clkpad generic map (level => cmos, voltage => x25v, tech => padtech)
-        port map (clk_33, clkace);
-  sysace_mpa_pads : outpadv generic map (level => cmos, voltage => x25v, width => 7, tech => padtech)
-    port map (sysace_mpa, aceo.addr);
-  sysace_mpce_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (sysace_mpce, aceo.cen);
-  sysace_d_pads : iopadv generic map (level => cmos, voltage => x25v, tech => padtech, width => 8)
-    port map (sysace_d(7 downto 0), aceo.do(7 downto 0), aceo.doen, acei.di(7 downto 0));
-  acei.di(15 downto 8) <= (others => '0');
-  sysace_mpoe_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (sysace_mpoe, aceo.oen);
-  sysace_mpwe_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (sysace_mpwe, aceo.wen);
-  sysace_mpirq_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (sysace_mpirq, acei.irq);
-
------------------PCI-EXPRESS-Master-Target------------------------------------------
-    pcie_mt : if CFG_PCIE_TYPE = 1 generate	-- master/target without fifo
-EP: pcie_master_target_virtex
-  generic map (
-    fabtech          => fabtech,
-    hmstndx          => CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE,
-    hslvndx          => 8,
-    abits            => 21,
-    device_id        => CFG_PCIEXPDID,	       -- PCIE device ID
-    vendor_id        => CFG_PCIEXPVID,	 -- PCIE vendor ID
-    pcie_bar_mask    => 16#FFE#,
-    nsync            => 2,   -- 1 or 2 sync regs between clocks
-    haddr            => 16#a00#,    
-    hmask            => 16#fff#,   
-    pindex           => 5,   
-    paddr            => 5,   
-    pmask            => 16#fff#,
-    Master           => CFG_PCIE_SIM_MAS,  
-    lane_width       => CFG_NO_OF_LANES  
-          )
-  port map( 
-    rst              => rstn,
-    clk              => clkm,
-    -- System Interface
-    sys_clk_p        => sys_clk_p,
-    sys_clk_n        => sys_clk_n,
-    sys_reset_n      => sys_reset_n,
-    -- PCI Express Fabric Interface
-    pci_exp_txp      => pci_exp_txp,
-    pci_exp_txn      => pci_exp_txn,
-    pci_exp_rxp      => pci_exp_rxp,
-    pci_exp_rxn      => pci_exp_rxn,
-    
-    ahbso            => ahbso(8),        
-    ahbsi            => ahbsi,         
-    apbi             => apbi,	      
-    apbo             => apbo(5),	      
-    ahbmi            => ahbmi,
-    ahbmo            => ahbmo(CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE)    
-  );
-    end generate;
-------------------PCI-EXPRESS-Master-FIFO------------------------------------------
-pcie_mf : if CFG_PCIE_TYPE = 3 generate	-- master with fifo and DMA
-dma:pciedma
-      generic map (fabtech => fabtech, memtech => memtech, dmstndx =>(CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE), 
-	  dapbndx => 8, dapbaddr => 8,dapbirq => 8, blength => 12, abits => 21,
-	  device_id => CFG_PCIEXPDID, vendor_id => CFG_PCIEXPVID, pcie_bar_mask => 16#FFE#,
-	  slvndx => 8, apbndx => 5, apbaddr => 5, haddr => 16#A00#,hmask=> 16#FFF#,
-	  nsync => 2,lane_width => CFG_NO_OF_LANES)
-
-port map( 
-    rst          => rstn,
-    clk          => clkm,
-    -- System Interface
-    sys_clk_p    => sys_clk_p,
-    sys_clk_n    => sys_clk_n,
-    sys_reset_n  => sys_reset_n,
-    -- PCI Express Fabric Interface
-    pci_exp_txp  => pci_exp_txp,
-    pci_exp_txn  => pci_exp_txn,
-    pci_exp_rxp  => pci_exp_rxp,
-    pci_exp_rxn  => pci_exp_rxn,
-    
-    dapbo        => apbo(8),
-    dahbmo       => ahbmo((CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+CFG_SVGA_ENABLE)),
-    apbi         => apbi,
-    apbo         => apbo(5),
-    ahbmi        => ahbmi,
-    ahbsi        => ahbsi,
-    ahbso        => ahbso(8)
   
-  );
-    end generate;
-----------------------------------------------------------------------
-pcie_mf_no_dma: if CFG_PCIE_TYPE = 2 generate	-- master with fifo 
-EP:pcie_master_fifo_virtex
-generic map (fabtech => fabtech, memtech => memtech, 
-   hslvndx => 8, abits => 21, device_id => CFG_PCIEXPDID, vendor_id => CFG_PCIEXPVID,
-   pcie_bar_mask => 16#FFE#, pindex => 5, paddr => 5,
-  haddr => 16#A00#, hmask => 16#FFF#, nsync => 2, lane_width => CFG_NO_OF_LANES)
-port map( 
-    rst          => rstn,
-    clk          => clkm,
-    -- System Interface
-    sys_clk_p    => sys_clk_p,
-    sys_clk_n    => sys_clk_n,
-    sys_reset_n  => sys_reset_n,
-    -- PCI Express Fabric Interface
-    pci_exp_txp  => pci_exp_txp,
-    pci_exp_txn  => pci_exp_txn,
-    pci_exp_rxp  => pci_exp_rxp,
-    pci_exp_rxn  => pci_exp_rxn,
-    
-    ahbso        => ahbso(8),        
-    ahbsi        => ahbsi,         
-    apbi         => apbi,        
-    apbo         => apbo(5)        
-  );
-end generate;
-----------------------------------------------------------------------
-
----  APB Bridge and various periherals -------------------------------
-----------------------------------------------------------------------
+  -- APB bridge.
+  apb : apbctrl
+    generic map (
+      hindex                    => 1,
+      haddr                     => 16#800#,
+      hmask                     => 16#F00#,
+      nslaves                   => 11
+    )
+    port map (
+      rst                       => rstn,
+      clk                       => clkm,
+      ahbi                      => ahbsi,
+      ahbo                      => ahbso(1),
+      apbi                      => apbi,
+      apbo                      => apbo
+    );
+  
+  
+  -- r-VEX bus bridge.
+  rvex_bus_bridge_block: block is
 
-  -- APB Bridge
-  apb0 : apbctrl
-    generic map (hindex => 1, haddr => CFG_APBADDR)
-    port map (rstn, clkm, ahbsi, ahbso(1), apbi, apbo);
+    signal reset        : std_logic;
+    signal clk          : std_logic;
+    
+    -- Busses between the demuxer and the bus stages.
+    signal rvbsi_s      : bus_mst2slv_array(0 to N_RVB_SLAVES - 1);
+    signal rvbso_s      : bus_slv2mst_array(0 to N_RVB_SLAVES - 1);
+  
+    function addr_map return addrRangeAndMapping_array is
+      variable retval : addrRangeAndMapping_array(0 to N_RVB_SLAVES - 1);
+      variable i : natural;
+    begin
+      i := 0;
+      
+      -- Processors.
+      for c in 0 to CFG_NRVEX - 1 loop
+        retval(i) := addrRangeAndMap(
+          match => "------00" & std_logic_vector(to_unsigned(c, 4)) & "----" & "--------" & "--------"
+        );
+        i := i + 1;
+      end loop;
+      
+      -- Debug UART.
+      retval(i) := addrRangeAndMap(
+        match => "------01" & "--------" & "--------" & "--------"
+      );
+      i := i + 1;
+      
+      -- Audio port.
+      retval(i) := addrRangeAndMap(
+        match => "------10" & "--------" & "--------" & "--------"
+      );
+      i := i + 1;
+      
+      -- Monitor r-VEX.
+      retval(i) := addrRangeAndMap(
+        match => "------11" & "--------" & "--------" & "--------"
+      );
+      i := i + 1;
+      
+      return retval;
+    end function;
+
+  begin
+
+    reset <= not rstn;
+    clk <= clkm;
+
+    -- Instantiate the bus bridge.
+    rvex_bus_bridge_inst: entity rvex.ahb2bus
+      generic map (
+        AHB_INDEX       => 3,
+        AHB_ADDR        => 16#D00#,
+        AHB_MASK        => 16#F00#,
+        AHB_VENDOR_ID   => VENDOR_TUDELFT,
+        AHB_DEVICE_ID   => TUDELFT_BRIDGE
+      )
+      port map (
+        reset           => reset,
+        clk             => clk,
+        ahb2bridge      => ahbsi,
+        bridge2ahb      => ahbso(3),
+        bridge2bus      => rvbmo,
+        bus2bridge      => rvbmi
+      );
 
-  -- Interrupt controller
-  irqctrl : if CFG_IRQ3_ENABLE /= 0 generate
-    irqctrl0 : irqmp
-      generic map (pindex => 2, paddr => 2, ncpu => CFG_NCPU)
-      port map (rstn, clkm, apbi, apbo(2), irqo, irqi);
-  end generate;
-  irq3 : if CFG_IRQ3_ENABLE = 0 generate
-    x : for i in 0 to CFG_NCPU-1 generate
-      irqi(i).irl <= "0000";
+    -- Instantiate the demuxer.
+    rvex_bus_bridge_demux: entity rvex.bus_demux
+      generic map (
+        ADDRESS_MAP     => addr_map
+      )
+      port map (
+        reset           => reset,
+        clk             => clk,
+        clkEn           => '1',
+        mst2demux       => rvbmo,
+        demux2mst       => rvbmi,
+        demux2slv       => rvbsi_s,
+        slv2demux       => rvbso_s
+      );
+    
+    -- Generate the bus stage registers to make routing a bit easier.
+    rvex_bus_stages: for i in 0 to N_RVB_SLAVES - 1 generate
+      rvex_bus_stage: entity rvex.bus_stage
+        port map (
+          reset           => reset,
+          clk             => clk,
+          clkEn           => '1',
+          mst2stage       => rvbsi_s(i),
+          stage2mst       => rvbso_s(i),
+          stage2slv       => rvbsi(i),
+          slv2stage       => rvbso(i)
+        );
     end generate;
-    apbo(2) <= apb_none;
-  end generate;
-
-  -- Time Unit
-  gpt : if CFG_GPT_ENABLE /= 0 generate
-    timer0 : gptimer
-      generic map (pindex => 3, paddr => 3, pirq => CFG_GPT_IRQ,
-                   sepirq => CFG_GPT_SEPIRQ, sbits => CFG_GPT_SW,
-                   ntimers => CFG_GPT_NTIM, nbits  => CFG_GPT_TW)
-      port map (rstn, clkm, apbi, apbo(3), gpti, open);
-    gpti.dhalt  <= dsuo.tstop;
-    gpti.extclk <= '0';
-  end generate;
-  notim : if CFG_GPT_ENABLE = 0 generate apbo(3) <= apb_none; end generate;
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- r-VEX processor
+  ------------------------------------------------------------------------------
+  
+  rvsys_gen: for i in 0 to CFG_NRVEX-1 generate
 
-  -- GPIO Unit
-  gpio0 : if CFG_GRGPIO_ENABLE /= 0 generate
-    grgpio0: grgpio
-      generic map(pindex => 11, paddr => 11, imask => CFG_GRGPIO_IMASK, nbits => 12)
-      port map(rstn, clkm, apbi, apbo(11), gpioi, gpioo);
-  end generate;
+    -- Calculate the PIND of the current core depending on the number of
+    -- contexts of all previous cores.
+    function CALC_PIND return integer is
+      variable PIND : integer := 0;
+    begin
+      for index in 0 to i-1 loop
+        PIND := PIND + 2**CFG_RVEX_CFG(index).core.numLaneGroupsLog2;
+      end loop;
+      return PIND;
+    end function;
+
+    constant PIND : integer := CALC_PIND;
+    constant PNUM : integer := 2**CFG_RVEX_CFG(i).core.numLaneGroupsLog2;
+  begin
+
+    -- Check rvex configuration.
+    assert CFG_RVEX_CFG(i).core.numLaneGroupsLog2 = CFG_RVEX_CFG(i).core.numContextsLog2
+      report "numLaneGroups must equal numContexts due to platform constraints"
+      severity failure;
+
+    rvsys_inst: entity rvex.rvsys_grlib
+      generic map (
+        CFG                     => CFG_RVEX_CFG(i),
+        PLATFORM_TAG            => RVEX_PLATFORM_TAG,
+        AHB_MASTER_INDEX_START  => PIND,
+        CHECK_MEM               => false,
+        CHECK_MEM_FILE          => "ram.srec"
+      )
+      port map (
+        clki                    => clkm,
+        rstn                    => rstn,
+        ahbmi                   => ahbmi,
+        ahbmo                   => ahbmo(PIND+PNUM-1 downto PIND),
+        ahbsi                   => ahbsi,
+        bus2dgb                 => rvbsi(i),
+        dbg2bus                 => rvbso(i),
+        irqi                    => irqi(PIND to PIND+PNUM-1),
+        irqo                    => irqo(PIND to PIND+PNUM-1),
+        gpio_dip                => dipsw_int
+      );
 
-  ua1 : if CFG_UART1_ENABLE /= 0 generate
-    uart1 : apbuart                     -- UART 1
-      generic map (pindex   => 1, paddr => 1, pirq => 2, console => dbguart, fifosize => CFG_UART1_FIFO)
-      port map (rstn, clkm, apbi, apbo(1), u1i, u1o);
-    u1i.rxd    <= rxd1;
-    u1i.ctsn   <= '0';
-    u1i.extclk <= '0';
-    txd1       <= u1o.txd;
-    serrx_pad : inpad generic map (level => cmos, voltage => x25v, tech  => padtech) port map (dsurx, rxd1);
-    sertx_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech) port map (dsutx, txd1);
-    led(0) <= not rxd1;
-    led(1) <= not txd1;
   end generate;
-  noua0 : if CFG_UART1_ENABLE = 0 generate apbo(1) <= apb_none; end generate;
-
-
-  i2cm: if CFG_I2C_ENABLE = 1 generate  -- I2C master
-    i2c0 : i2cmst
-    generic map (pindex => 12, paddr => 12, pmask => 16#FFF#,
-                 pirq => 11, filter => I2C_FILTER)
-    port map (rstn, clkm, apbi, apbo(12), i2ci, i2co);
-    i2c_scl_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (iic_scl_main, i2co.scl, i2co.scloen, i2ci.scl);
-    i2c_sda_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (iic_sda_main, i2co.sda, i2co.sdaoen, i2ci.sda);
-  end generate i2cm;
-
------------------------------------------------------------------------
----  VGA + IIC --------------------------------------------------------
------------------------------------------------------------------------
-
-  vga : if CFG_VGA_ENABLE /= 0 generate
-    vga0 : apbvga generic map(memtech => memtech, pindex => 6, paddr => 6)
-      port map(rstn, clkm, clkvga, apbi, apbo(6), vgao);
-      clk_sel <= "00";
+  
+  
+  ------------------------------------------------------------------------------
+  -- r-VEX monitoring processor
+  ------------------------------------------------------------------------------
+  
+  monitor_rvex_gen: block
+    signal rv2stage     : bus_mst2slv_type;
+    signal stage2rv     : bus_slv2mst_type;
+    signal stage2periph : bus_mst2slv_type;
+    signal periph2stage : bus_slv2mst_type;
+    signal reset        : std_logic;
+    signal clk          : std_logic;
+  begin
+
+    reset <= not rstn;
+    clk <= clkm;
+
+    bus_bridge: entity rvex.bus2ahb
+      generic map (
+        AHB_MASTER_INDEX        => CFG_NCPU
+      )
+      port map (
+        reset                   => reset,
+        clk                     => clk,
+        bus2bridge              => stage2periph,
+        bridge2bus              => periph2stage,
+        bridge2ahb              => ahbmo(CFG_NCPU),
+        ahb2bridge              => ahbmi
+      );
+    
+    bus_stage: entity rvex.bus_stage
+      port map (
+        reset           => reset,
+        clk             => clk,
+        clkEn           => '1',
+        mst2stage       => rv2stage,
+        stage2mst       => stage2rv,
+        stage2slv       => stage2periph,
+        slv2stage       => periph2stage
+      );
+    
+    monitor_rvex_sys: entity rvex.rvsys_standalone
+      generic map (
+        CFG                     => (
+          core                    => rvex_cfg(
+            numLanesLog2           => 1,
+            numLaneGroupsLog2      => 0,
+            numContextsLog2        => 0,
+            bundleAlignLog2        => 1,
+            numBreakpoints         => 1,
+            limmhFromNeighbor      => 1,
+            limmhFromPreviousPair  => 0,
+            traceEnable            => 0,
+            perfCountSize          => 0,
+            cachePerfCountEnable   => 0
+          ),
+          cache_enable             => false,
+          cache_config             => CACHE_DEFAULT_CONFIG,
+          cache_bypassRange        => addrRange(match => "1-------------------------------"),
+          inject_latency           => false,
+          imemDepthLog2B           => 17,
+          dmemDepthLog2B           => 17,
+          traceDepthLog2B          => 13,
+          debugBusMap_imem         => addrRangeAndMap(match => "---------0-1--------------------"),
+          debugBusMap_dmem         => addrRangeAndMap(match => "---------01---------------------"),
+          debugBusMap_rvex         => addrRangeAndMap(match => "---------1-1--------------------"),
+          debugBusMap_trace        => addrRangeAndMap(match => "---------1-0--------------------"),
+          debugBusMap_mutex        => false,
+          rvexDataMap_dmem         => addrRangeAndMap(match => "000000000000--------------------"),
+          rvexDataMap_bus          => addrRangeAndMap(match => "--------------------------------")
+        ),
+        PLATFORM_TAG            => RVEX_PLATFORM_TAG
+      )
+      port map (
+        reset                   => reset,
+        clk                     => clk,
+        clkEn                   => '1',
+        rvsa2bus                => rv2stage,
+        bus2rvsa                => stage2rv,
+        debug2rvsa              => rvbsi(CFG_NRVEX + 2),
+        rvsa2debug              => rvbso(CFG_NRVEX + 2)
+      );
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- Interrupt controller
+  ------------------------------------------------------------------------------
+  
+  irqctrl0: irqmp
+    generic map (
+      pindex                    => 2,
+      paddr                     => 16#002#,
+      pmask                     => 16#00F#,
+      ncpu                      => CFG_NCPU
+    )
+    port map (
+      rst                       => rstn,
+      clk                       => clkm,
+      apbi                      => apbi,
+      apbo                      => apbo(2),
+      irqi                      => irqo,
+      irqo                      => irqi
+    );
+  
+  
+  ------------------------------------------------------------------------------
+  -- Memory controller
+  ------------------------------------------------------------------------------
+  -- pragma translate_off
+  mig_gen: if not DISABLE_DDR_SIM generate
+  begin
+  -- pragma translate_on
+  
+    -- MIG instantiation.
+    ddr3ctrl: entity work.mig_37
+      generic map (
+        SIM_BYPASS_INIT_CAL       => SIM_BYPASS_INIT_CAL,
+        CLKOUT_DIVIDE4            => work.config.CFG_MIG_CLK4
+      )
+      port map (
+        clk_ref_p                 => clk_ref_p,
+        clk_ref_n                 => clk_ref_n,
+        ddr3_dq                   => ddr3_dq,
+        ddr3_addr                 => ddr3_addr,
+        ddr3_ba                   => ddr3_ba,
+        ddr3_ras_n                => ddr3_ras_n,
+        ddr3_cas_n                => ddr3_cas_n,
+        ddr3_we_n                 => ddr3_we_n,
+        ddr3_reset_n              => ddr3_reset_n,
+        ddr3_cs_n                 => ddr3_cs_n,
+        ddr3_odt                  => ddr3_odt,
+        ddr3_cke                  => ddr3_cke,
+        ddr3_dm                   => ddr3_dm,
+        ddr3_dqs_p                => ddr3_dqs_p,
+        ddr3_dqs_n                => ddr3_dqs_n,
+        ddr3_ck_p                 => ddr3_ck_p,
+        ddr3_ck_n                 => ddr3_ck_n,
+        app_wdf_wren              => migi.app_wdf_wren,
+        app_wdf_data              => migi.app_wdf_data,
+        app_wdf_mask              => migi.app_wdf_mask,
+        app_wdf_end               => migi.app_wdf_end,
+        app_addr                  => migi.app_addr,
+        app_cmd                   => migi.app_cmd,
+        app_en                    => migi.app_en,
+        app_rdy                   => migo.app_rdy,
+        app_wdf_rdy               => migo.app_wdf_rdy,
+        app_rd_data               => migo.app_rd_data,
+        app_rd_data_valid         => migo.app_rd_data_valid,
+        tb_rst                    => open,
+        tb_clk                    => clkddr,
+        clk_ahb                   => clkm,
+        clk100                    => clk100,
+        phy_init_done             => phy_init_done,
+        sys_rst_13                => reset,
+        sys_rst_14                => rstraw
+      );
+    
+    ahb2mig0 : ahb2mig_ml605
+      generic map (
+        hindex                    => 0,
+        haddr                     => 16#000#,
+        hmask                     => 16#C00#,
+        MHz                       => 400,  -- Only used for sim debug messages.
+        Mbyte                     => 1024, -- Only used for sim debug messages.
+        nosync                    => boolean'pos(CFG_MIG_CLK4=12) --CFG_CLKDIV/12)
+      ) 
+      port map (
+        rst                       => rstn,
+        clk_ahb                   => clkm,
+        clk_ddr                   => clkddr,
+        ahbsi                     => ahbsi,
+        ahbso                     => ahbso(0),
+        migi                      => migi,
+        migo                      => migo
+      );
+    
+  -- pragma translate_off
   end generate;
-
-  svga : if CFG_SVGA_ENABLE /= 0 generate
-    svga0 : svgactrl generic map(memtech => memtech, pindex => 6, paddr => 6,
-        hindex => CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG, clk0 => 40000,
-	clk1 => 24000, clk2 => 20000, clk3 => 16000, burstlen => 4,
-                                 ahbaccsz => CFG_AHBDW)
-       port map(rstn, clkm, clkvga, apbi, apbo(6), vgao, ahbmi,
-		ahbmo(CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG), clk_sel);
+  sim_mem_gen: if DISABLE_DDR_SIM generate
+    signal reset        : std_logic;
+    signal bridge2model : bus_mst2slv_type;
+    signal model2bridge : bus_slv2mst_type;
+  begin
+    reset <= not rstn;
+    
+    -- Generate 400 MHz clock.
+    process is
+    begin
+      clkddr <= '1';
+      wait for 1250 ps;
+      clkddr <= '0';
+      wait for 1250 ps;
+    end process;
+    
+    -- Generate 100 MHz clock.
+    process is
+    begin
+      clk100 <= '1';
+      wait for 5000 ps;
+      clk100 <= '0';
+      wait for 5000 ps;
+    end process;
+    
+    -- Generate configurable clock (1200 MHz / CFG_MIG_CLK4).
+    process is
+    begin
+      clkm <= '1';
+      wait for CFG_MIG_CLK4 * 417 ps;
+      clkm <= '0';
+      wait for CFG_MIG_CLK4 * 417 ps;
+      clkm <= '1';
+      wait for CFG_MIG_CLK4 * 416 ps;
+      clkm <= '0';
+      wait for CFG_MIG_CLK4 * 417 ps;
+      clkm <= '1';
+      wait for CFG_MIG_CLK4 * 417 ps;
+      clkm <= '0';
+      wait for CFG_MIG_CLK4 * 416 ps;
+    end process;
+    
+    -- Generate PHY done signal.
+    process is
+    begin
+      phy_init_done <= '0';
+      wait for 1 us;
+      phy_init_done <= '1';
+      wait;
+    end process;
+    
+    -- Connect the DDR simulation model to nothing.
+    ddr3_dq      <= (others => 'Z');
+    ddr3_dm      <= (others => '0');
+    ddr3_addr    <= (others => '0');
+    ddr3_ba      <= (others => '0');
+    ddr3_ras_n   <= '1';
+    ddr3_cas_n   <= '1';
+    ddr3_we_n    <= '1';
+    ddr3_reset_n <= '0';
+    ddr3_cs_n    <= (others => '1');
+    ddr3_odt     <= (others => '0');
+    ddr3_cke     <= (others => '0');
+    ddr3_dqs_p   <= (others => 'Z');
+    ddr3_dqs_n   <= (others => 'Z');
+    ddr3_ck_p    <= (others => '0');
+    ddr3_ck_n    <= (others => '1');
+    
+    -- Convert the AHB bus slave interface to r-VEX bus.
+    mem_bridge_inst: entity rvex.ahb2bus
+      generic map (
+        AHB_INDEX       => 0,
+        AHB_ADDR        => 16#000#,
+        AHB_MASK        => 16#C00#,
+        AHB_VENDOR_ID   => VENDOR_TUDELFT,
+        AHB_DEVICE_ID   => TUDELFT_BRIDGE
+      )
+      port map (
+        reset           => reset,
+        clk             => clkm,
+        ahb2bridge      => ahbsi,
+        bridge2ahb      => ahbso(0),
+        bridge2bus      => bridge2model,
+        bus2bridge      => model2bridge
+      );
+    
+    -- Simulate the memory.
+    mem_model: process is
+      variable mem      : rvmem_memoryState_type;
+      variable readData : rvex_data_type;
+      variable l        : std.textio.line;
+      variable c        : character;
+    begin
+      
+      -- Load the srec file into the memory.
+      rvmem_clear(mem, '0');
+      rvmem_loadSRec(mem, "ram.srec");
+      
+      -- Initialize the bus output.
+      model2bridge <= BUS_SLV2MST_IDLE;
+      
+      -- Handle memory requests.
+      loop
+        
+        -- Wait for the next clock.
+        wait until rising_edge(clkm);
+        
+        -- If we have a request, delay for some amount of cycles.
+        if bridge2model.readEnable = '1' or bridge2model.writeEnable = '1' then
+          model2bridge <= BUS_SLV2MST_IDLE;
+          model2bridge.busy <= '1';
+          wait until rising_edge(clkm);
+          wait until rising_edge(clkm);
+          wait until rising_edge(clkm);
+          wait until rising_edge(clkm);
+          wait until rising_edge(clkm);
+        end if;
+        
+        -- Handle the bus request.
+        model2bridge <= BUS_SLV2MST_IDLE;
+        if bridge2model.readEnable = '1' then
+          rvmem_read(mem, bridge2model.address, readData);
+          model2bridge.readData <= readData;
+          model2bridge.ack <= '1';
+        elsif bridge2model.writeEnable = '1' then
+          rvmem_write(mem, bridge2model.address, bridge2model.writeData, bridge2model.writeMask);
+          model2bridge.ack <= '1';
+        end if;
+        
+      end loop;
+      
+    end process;
+    
   end generate;
-
-  vgadvi : if (CFG_VGA_ENABLE + CFG_SVGA_ENABLE) /= 0 generate
-    dvi0 : entity work.svga2ch7301c generic map (tech => fabtech, idf => 2)
-      port map (clk100, ethi.gtx_clk, lock, clk_sel, vgao, clkvga, clkvga_p, clkvga_n,
-                lcd_datal, lcd_hsyncl, lcd_vsyncl, lcd_del);
-
+  -- pragma translate_on
+  ------------------------------------------------------------------------------
+  -- System ACE (compact flash card) controller
+  ------------------------------------------------------------------------------
+  
+  grace_block: block is
+    signal acei                 : gracectrl_in_type;
+    signal aceo                 : gracectrl_out_type;
+  begin
+    
+    gracectrl_inst: gracectrl
+      generic map (
+        hindex                  => 2,
+        haddr                   => 16#900#,
+        hmask                   => 16#F00#,
+        split                   => 1,
+        hirq                    => 10,
+        mode                    => 2
+      )
+      port map (
+        rstn                    => rstn,
+        clk                     => clkm,
+        clkace                  => clk33,
+        ahbsi                   => ahbsi,
+        ahbso                   => ahbso(2),
+        acei                    => acei,
+        aceo                    => aceo
+      );
+    
+    sysace_mpa_pads : outpadv generic map (level => cmos, voltage => x25v, width => 7, tech => padtech)
+      port map (sysace_mpa, aceo.addr);
+    sysace_mpce_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (sysace_mpce, aceo.cen);
+    sysace_d_pads : iopadv generic map (level => cmos, voltage => x25v, tech => padtech, width => 8)
+      port map (sysace_d(7 downto 0), aceo.do(7 downto 0), aceo.doen, acei.di(7 downto 0));
+    acei.di(15 downto 8) <= (others => '0');
+    sysace_mpoe_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (sysace_mpoe, aceo.oen);
+    sysace_mpwe_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (sysace_mpwe, aceo.wen);
+    sysace_mpirq_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (sysace_mpirq, acei.irq);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- SVGA controller
+  ------------------------------------------------------------------------------
+  
+  vga: block is
+    signal vgao                 : apbvga_out_type;
+    signal lcd_datal            : std_logic_vector(11 downto 0);
+    signal lcd_hsyncl           : std_ulogic;
+    signal lcd_vsyncl           : std_ulogic;
+    signal lcd_del              : std_ulogic;
+    signal lcd_reset_bl         : std_ulogic;
+    signal clk_sel              : std_logic_vector(1 downto 0);
+    signal clkvga               : std_ulogic;
+    signal clkvga_p             : std_ulogic;
+    signal clkvga_n             : std_ulogic;
+  begin
+    
+    -- VGA sync generator etc.
+    svga0: svgactrl 
+      generic map (
+        length                  => 768,
+        part                    => 256,
+        memtech                 => memtech,
+        pindex                  => 6,
+        paddr                   => 16#006#,
+        hindex                  => CFG_NCPU + 1,
+        clk0                    => 40000,
+        clk1                    => 80000,
+        clk2                    => 160000,
+        clk3                    => 25000,
+        burstlen                => 8,
+        ahbaccsz                => CFG_AHBDW
+      )
+      port map (
+        rst                     => rstn,
+        clk                     => clkm,
+        vgaclk                  => clkvga,
+        apbi                    => apbi,
+        apbo                    => apbo(6),
+        vgao                    => vgao,
+        ahbi                    => ahbmi,
+        ahbo                    => ahbmo(CFG_NCPU + 1),
+        clk_sel                 => clk_sel
+      );
+    
+    -- Interface logic for the CH7301C DAC/DVI controller.
+    -- For some reason, IDF 2 is used in the leon3mp platform. This limits the
+    -- actual color depth to 5:6:5, which is just silly. IDF 0 gives full 8:8:8
+    -- control over the DAC.
+    dvi0: entity work.svga2ch7301c
+      generic map (
+        tech                    => fabtech,
+        idf                     => 0
+      )
+      port map (
+        clk100                  => clk100,
+        clk125                  => clk125,
+        rstn                    => lock,
+        clksel                  => clk_sel,
+        vgao                    => vgao,
+        clkvga                  => clkvga,
+        dclk_p                  => clkvga_p,
+        dclk_n                  => clkvga_n,
+        data                    => lcd_datal,
+        hsync                   => lcd_hsyncl,
+        vsync                   => lcd_vsyncl,
+        de                      => lcd_del
+      );
+    
+    -- GRLIB pad tech bullshit because this is totally an ASIC.
+    tft_lcd_clkp_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (tft_lcd_clk_p, clkvga_p);
+    tft_lcd_clkn_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (tft_lcd_clk_n, clkvga_n);
+    tft_lcd_reset_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (tft_lcd_reset_b, rstn);
+    tft_lcd_data_pad : outpadv generic map (level => cmos, voltage => x25v, width => 12, tech => padtech)
+      port map (tft_lcd_data, lcd_datal);
+    tft_lcd_hsync_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (tft_lcd_hsync, lcd_hsyncl);
+    tft_lcd_vsync_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (tft_lcd_vsync, lcd_vsyncl);
+    tft_lcd_de_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (tft_lcd_de, lcd_del);
+      
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- DVI I2C interface
+  ------------------------------------------------------------------------------
+  -- The following registers must be set for VGA output mode:
+  --   register 0x49 <- 0x00 (disable full power down)
+  --   register 0x21 <- 0x09 (enable RGB DACs, enable hsync/vsync outputs)
+  --
+  -- 7-bit I2C address: 0b1110110
+  -- 
+  -- DVI modes should also work but I can't be fucked to figure out the register
+  -- config for that (it requires PLL setup).
+  -- http://www.xilinx.com/products/boards/ml505/datasheets/7301ds.pdf have fun.
+  
+  i2c_dvi: block is
+    signal dvi_i2ci             : i2c_in_type;
+    signal dvi_i2co             : i2c_out_type;
+  begin
+    
+    -- I2C master controller.
     i2cdvi : i2cmst
-      generic map (pindex => 9, paddr => 9, pmask => 16#FFF#,
-                   pirq => 7, filter => I2C_FILTER)
-      port map (rstn, clkm, apbi, apbo(9), dvi_i2ci, dvi_i2co);
-  end generate;
-
-  novga : if (CFG_VGA_ENABLE + CFG_SVGA_ENABLE) = 0 generate
-     apbo(6) <= apb_none;
-     lcd_datal <= (others => '0'); clkvga_p <= '0'; clkvga_n <= '0';
-     lcd_hsyncl <= '0'; lcd_vsyncl <= '0'; lcd_del <= '0';
-     dvi_i2co.scloen <= '1'; dvi_i2co.sdaoen <= '1';
-  end generate;
-
-  tft_lcd_data_pad : outpadv generic map (level => cmos, voltage => x25v, width => 12, tech => padtech)
-        port map (tft_lcd_data, lcd_datal);
-  tft_lcd_clkp_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (tft_lcd_clk_p, clkvga_p);
-  tft_lcd_clkn_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (tft_lcd_clk_n, clkvga_n);
-  tft_lcd_hsync_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (tft_lcd_hsync, lcd_hsyncl);
-  tft_lcd_vsync_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (tft_lcd_vsync, lcd_vsyncl);
-  tft_lcd_de_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (tft_lcd_de, lcd_del);
-  tft_lcd_reset_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (tft_lcd_reset_b, rstn);
-  dvi_i2c_scl_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (dvi_iic_scl, dvi_i2co.scl, dvi_i2co.scloen, dvi_i2ci.scl);
-  dvi_i2c_sda_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
-    port map (dvi_iic_sda, dvi_i2co.sda, dvi_i2co.sdaoen, dvi_i2ci.sda);
-
------------------------------------------------------------------------
----  ETHERNET ---------------------------------------------------------
------------------------------------------------------------------------
-
-  eth0 : if CFG_GRETH = 1 generate -- Gaisler ethernet MAC
-    e1 : grethm
-      generic map(hindex => CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_SVGA_ENABLE,
-        pindex => 15, paddr => 15, pirq => 12, memtech => memtech,
-        mdcscaler => CPU_FREQ/1000, enable_mdio => 1, fifosize => CFG_ETH_FIFO,
-        nsync => 1, edcl => CFG_DSU_ETH, edclbufsz => CFG_ETH_BUF,
-        macaddrh => CFG_ETH_ENM, macaddrl => CFG_ETH_ENL, phyrstadr => 7,
-        ipaddrh => CFG_ETH_IPM, ipaddrl => CFG_ETH_IPL, giga => CFG_GRETH1G,
-	enable_mdint => 1)
-      port map(rst => rstn, clk => clkm, ahbmi => ahbmi,
-               ahbmo => ahbmo(CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_SVGA_ENABLE),
-               apbi => apbi, apbo => apbo(15), ethi => ethi, etho => etho);
-  end generate;
-
---  greth1g: if CFG_GRETH1G = 1 generate
-    gtxclk0 : entity work.gtxclk port map (
-	clk_p => gmiiclk_p, clk_n => gmiiclk_n, clkint => ethi.gtx_clk,
-	clkout => egtx_clk);
---  end generate;
-
-  ethpads : if (CFG_GRETH = 1) generate -- eth pads
-    emdio_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (emdio, etho.mdio_o, etho.mdio_oe, ethi.mdio_i);
-    etxc_pad : clkpad generic map (level => cmos, voltage => x25v, tech => padtech, arch => 2)
-      port map (etx_clk, ethi.tx_clk);
-    erxc_pad : clkpad generic map (level => cmos, voltage => x25v, tech => padtech, arch => 2)
-      port map (erx_clk, ethi.rx_clk);
-    erxd_pad : inpadv generic map (level => cmos, voltage => x25v, tech => padtech, width => 8)
-      port map (erxd, ethi.rxd(7 downto 0));
-    erxdv_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (erx_dv, ethi.rx_dv);
-    erxer_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (erx_er, ethi.rx_er);
-    erxco_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (erx_col, ethi.rx_col);
-    erxcr_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (erx_crs, ethi.rx_crs);
-    emdint_pad : inpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (emdint, ethi.mdint);
-
-
-    etxd_pad : outpadv generic map (level => cmos, voltage => x25v, tech => padtech, width => 8)
-      port map (etxd, etho.txd(7 downto 0));
-    etxen_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (etx_en, etho.tx_en);
-    etxer_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (etx_er, etho.tx_er);
-    emdc_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
-      port map (emdc, etho.mdc);
-  end generate;
-
------------------------------------------------------------------------
----  AHB ROM ----------------------------------------------------------
------------------------------------------------------------------------
-
-  bpromgen : if CFG_AHBROMEN /= 0 generate
-    brom : entity work.ahbrom
-      generic map (hindex => 6, haddr => CFG_AHBRODDR, pipe => CFG_AHBROPIP)
-      port map ( rstn, clkm, ahbsi, ahbso(6));
-  end generate;
-  nobpromgen : if CFG_AHBROMEN = 0 generate
-     ahbso(6) <= ahbs_none;
-  end generate;
-
------------------------------------------------------------------------
----  AHB RAM ----------------------------------------------------------
------------------------------------------------------------------------
-
-  ahbramgen : if CFG_AHBRAMEN = 1 generate
-    ahbram0 : ahbram
-      generic map (hindex => 3, haddr => CFG_AHBRADDR, tech => CFG_MEMTECH,
-                   kbytes => CFG_AHBRSZ, pipe => CFG_AHBRPIPE)
-      port map (rstn, clkm, ahbsi, ahbso(3));
-  end generate;
-  nram : if CFG_AHBRAMEN = 0 generate ahbso(3) <= ahbs_none; end generate;
-
------------------------------------------------------------------------
----  Test report module  ----------------------------------------------
------------------------------------------------------------------------
-
--- pragma translate_off
-
-  test0 : ahbrep generic map (hindex => 4, haddr => 16#200#)
-	port map (rstn, clkm, ahbsi, ahbso(4));
-
--- pragma translate_on
-
------------------------------------------------------------------------
----  Drive unused bus elements  ---------------------------------------
------------------------------------------------------------------------
-
-  nam1 : for i in (CFG_NCPU+CFG_AHB_UART+CFG_AHB_JTAG+CFG_GRETH+1+CFG_PCIEXP) to NAHBMST-1 generate
-    ahbmo(i) <= ahbm_none;
-  end generate;
+      generic map (
+        pindex                  => 7,
+        paddr                   => 16#007#,
+        pmask                   => 16#00F#,
+        pirq                    => 11,
+        filter                  => (CLKM_FREQ*5+50000)/100000+1
+      )
+      port map (
+        rstn                    => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(7),
+        i2ci                    => dvi_i2ci,
+        i2co                    => dvi_i2co
+      );
+    
+    -- GRLIB pad tech bullshit because this is totally an ASIC.
+    dvi_i2c_scl_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (dvi_iic_scl, dvi_i2co.scl, dvi_i2co.scloen, dvi_i2ci.scl);
+    dvi_i2c_sda_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (dvi_iic_sda, dvi_i2co.sda, dvi_i2co.sdaoen, dvi_i2ci.sda);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- PMBus interface
+  ------------------------------------------------------------------------------
+  
+  i2c_pmbus: block is
+    signal pmbus_i2ci           : i2c_in_type;
+    signal pmbus_i2co           : i2c_out_type;
+  begin
+    
+    -- I2C master controller.
+    i2cpmbus : i2cmst
+      generic map (
+        pindex                  => 8,
+        paddr                   => 16#008#,
+        pmask                   => 16#00F#,
+        pirq                    => 12,
+        filter                  => (CLKM_FREQ*5+50000)/100000+1
+      )
+      port map (
+        rstn                    => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(8),
+        i2ci                    => pmbus_i2ci,
+        i2co                    => pmbus_i2co
+      );
+    
+    -- GRLIB pad tech bullshit because this is totally an ASIC.
+    pmbus_i2c_scl_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (pmbus_scl, pmbus_i2co.scl, pmbus_i2co.scloen, pmbus_i2ci.scl);
+    pmbus_i2c_sda_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (pmbus_sda, pmbus_i2co.sda, pmbus_i2co.sdaoen, pmbus_i2ci.sda);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- Zebro interface
+  ------------------------------------------------------------------------------
+  
+  i2c_zebro: block is
+    signal zebro_i2ci           : i2c_in_type;
+    signal zebro_i2co           : i2c_out_type;
+  begin
+    
+    -- I2C master controller.
+    i2czebro : i2cmst
+      generic map (
+        pindex                  => 9,
+        paddr                   => 16#009#,
+        pmask                   => 16#00F#,
+        pirq                    => 13,
+        filter                  => (CLKM_FREQ*5+50000)/100000+1
+      )
+      port map (
+        rstn                    => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(9),
+        i2ci                    => zebro_i2ci,
+        i2co                    => zebro_i2co
+      );
+    
+    -- GRLIB pad tech bullshit because this is totally an ASIC.
+    zebro_i2c_scl_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (gpio(5), zebro_i2co.scl, zebro_i2co.scloen, zebro_i2ci.scl);
+    zebro_i2c_sda_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (gpio(6), zebro_i2co.sda, zebro_i2co.sdaoen, zebro_i2ci.sda);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- GRMON JTAG interface
+  ------------------------------------------------------------------------------
+  
+  ahbjtag_inst: ahbjtag
+    generic map (
+      tech                      => fabtech,
+      hindex                    => CFG_NCPU + 2
+    )
+    port map(
+      rst                       => rstn,
+      clk                       => clkm,
+      tck                       => '0',
+      tms                       => '0',
+      tdi                       => '0',
+      tdo                       => open,
+      ahbi                      => ahbmi,
+      ahbo                      => ahbmo(CFG_NCPU + 2),
+      tapo_tck                  => open,
+      tapo_tdi                  => open,
+      tapo_inst                 => open,
+      tapo_rst                  => open,
+      tapo_capt                 => open,
+      tapo_shft                 => open,
+      tapo_upd                  => open,
+      tapi_tdo                  => '0',
+      trst                      => '1',
+      tdoen                     => open,
+      tckn                      => '0',
+      tapo_tckn                 => open,
+      tapo_ninst                => open,
+      tapo_iupd                 => open
+    );
 
------------------------------------------------------------------------
----  Boot message  ----------------------------------------------------
------------------------------------------------------------------------
+  
+  ------------------------------------------------------------------------------
+  -- Debug UART
+  ------------------------------------------------------------------------------
+  
+  -- Debug UART
+  rvuartgen : block
+    signal reset        : std_logic;
+    signal clk          : std_logic;
+    signal rx           : std_logic;
+    signal tx           : std_logic;
+    signal uart2dbg_bus : bus_mst2slv_type;
+    signal dbg2uart_bus : bus_slv2mst_type;
+    signal irq          : std_logic;
+  begin
+
+    reset <= not rstn;
+    clk <= clkm;
+
+    -- Instantiate the AHB master for the debug UART.
+    rvex_uart_mst_inst: entity rvex.bus2ahb
+      generic map (
+        AHB_MASTER_INDEX  => CFG_NCPU + 3,
+        AHB_VENDOR_ID     => VENDOR_TUDELFT,
+        AHB_DEVICE_ID     => TUDELFT_UART,
+        BUS_ERROR_CODE    => X"00000010",
+        REQ_ERROR_CODE    => X"00000011"
+      )
+      port map (
+        reset             => reset,
+        clk               => clk,
+        bus2bridge        => uart2dbg_bus,
+        bridge2bus        => dbg2uart_bus,
+        bridge2ahb        => ahbmo(CFG_NCPU + 3),
+        ahb2bridge        => ahbmi
+      );
 
--- pragma translate_off
-  x : report_design
-    generic map (
-      msg1 => "LEON3 Demonstration design for Xilinx Virtex6 ML605 board",
-      fabtech => tech_table(fabtech), memtech => tech_table(memtech),
-      mdel => 1
+    -- Instantiate the UART.
+    rvex_uart_inst: entity rvex.periph_uart
+      generic map (
+        F_CLK             => real(CLKM_FREQ) * 1000.0,
+        F_BAUD            => 115200.0
+      )
+      port map (
+        reset             => reset,
+        clk               => clk,
+        clkEn             => '1',
+        rx                => rx,
+        tx                => tx,
+        bus2uart          => rvbsi(CFG_NRVEX),
+        uart2bus          => rvbso(CFG_NRVEX),
+        irq               => irq,
+        uart2dbg_bus      => uart2dbg_bus,
+        dbg2uart_bus      => dbg2uart_bus
       );
--- pragma translate_on
 
+    -- We're only using the APB slot for the interrupt.
+    rvex_uart_apb: process (irq) is
+    begin
+      apbo(10) <= apb_none;
+      apbo(10).pirq <= (2 => irq, 5 => audio_irq, others => '0');
+    end process;
+
+    dsurx_pad : inpad generic map (level => cmos, voltage => x25v, tech  => padtech)
+      port map (dsurx, rx);
+    dsutx_pad : outpad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (dsutx, tx);
+  
+    led(2) <= (not rx) or (not tx);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- PS/2 interfaces
+  ------------------------------------------------------------------------------
+  
+  ps2_block_a: block is
+    signal ps2i                 : ps2_in_type;
+    signal ps2o                 : ps2_out_type;
+  begin
+    
+    -- PS/2 controller.
+    ps2_inst: apbps2
+      generic map (
+        pindex                  => 0,
+        paddr                   => 16#000#,
+        pmask                   => 16#00F#,
+        pirq                    => 6,
+        fKHz                    => CLKM_FREQ
+      )
+      port map (
+        rst                     => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(0),
+        ps2i                    => ps2i,
+        ps2o                    => ps2o
+      );
+    
+    -- GRLIB pad tech bullshit because this is totally an ASIC.
+    ps2_clk_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (gpio(0), ps2o.ps2_clk_o, ps2o.ps2_clk_oe, ps2i.ps2_clk_i);
+    ps2_data_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (gpio(1), ps2o.ps2_data_o, ps2o.ps2_data_oe, ps2i.ps2_data_i);
+    
+  end block;
+  
+  ps2_block_b: block is
+    signal ps2i                 : ps2_in_type;
+    signal ps2o                 : ps2_out_type;
+  begin
+    
+    -- PS/2 controller.
+    ps2_inst: apbps2
+      generic map (
+        pindex                  => 1,
+        paddr                   => 16#001#,
+        pmask                   => 16#00F#,
+        pirq                    => 7,
+        fKHz                    => CLKM_FREQ
+      )
+      port map (
+        rst                     => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(1),
+        ps2i                    => ps2i,
+        ps2o                    => ps2o
+      );
+    
+    -- GRLIB pad tech bullshit because this is totally an ASIC.
+    ps2_clk_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (gpio(2), ps2o.ps2_clk_o, ps2o.ps2_clk_oe, ps2i.ps2_clk_i);
+    ps2_data_pad : iopad generic map (level => cmos, voltage => x25v, tech => padtech)
+      port map (gpio(3), ps2o.ps2_data_o, ps2o.ps2_data_oe, ps2i.ps2_data_i);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- General-purpose timers
+  ------------------------------------------------------------------------------
+  
+  -- Timer A: intended for gettimeofday. Prescaler set to generate 1MHz
+  -- (requires an integer AHB clock speed), first timer set to overflow every
+  -- 1000000 cycles for counting microseconds, second timer in chain mode counts
+  -- seconds. No software divisions required.
+  gptimer_block_A: block is
+    signal gpti                 : gptimer_in_type;
+    signal gpto                 : gptimer_out_type;
+  begin
+    
+    gptimer_inst_A: gptimer
+      generic map (
+        pindex                  => 3,
+        paddr                   => 16#003#,
+        pmask                   => 16#00F#,
+        pirq                    => 8,
+        sepirq                  => 1,
+        sbits                   => 16,
+        ntimers                 => 2,
+        nbits                   => 32
+      )
+      port map (
+        rst                     => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(3),
+        gpti                    => gpti,
+        gpto                    => gpto
+      );
+    
+    gpti.dhalt <= '0';
+    gpti.extclk <= '0';
+    gpti.wdogen <= '0';
+    
+  end block;
+  
+  -- Timer B: intended for audio samplerate and OS tick. The audio bit clock is
+  -- hardwired to the overflow rate of timer 1. Timer 2 is general-purpose.
+  -- IRQ 1 is technically shared between the timers. Keeping the prescaler at 0
+  -- allows fine-tuned control over the samplerate. OS tick then goes up to a
+  -- couple seconds max.. If you want more, you can chain it to get up to some
+  -- 34 days.
+  gptimer_block_B: block is
+    signal gpti                 : gptimer_in_type;
+    signal gpto                 : gptimer_out_type;
+  begin
+    
+    gptimer_inst_B: gptimer
+      generic map (
+        pindex                  => 4,
+        paddr                   => 16#004#,
+        pmask                   => 16#00F#,
+        pirq                    => 1,
+        sepirq                  => 0,
+        sbits                   => 8, -- Prescaler will probably divide by 1.
+        ntimers                 => 2,
+        nbits                   => 32
+      )
+      port map (
+        rst                     => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(4),
+        gpti                    => gpti,
+        gpto                    => gpto
+      );
+    
+    gpti.dhalt <= '0';
+    gpti.extclk <= '0';
+    gpti.wdogen <= '0';
+    audio_next <= gpto.tick(1);
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- GPIO (LEDs, switches, buttons)
+  ------------------------------------------------------------------------------
+  
+  gpio_block: block is
+    signal gpioi                : gpio_in_type;
+    signal gpioo                : gpio_out_type;
+  begin
+    
+    gpio_inst: grgpio
+      generic map (
+        pindex                  => 5,
+        paddr                   => 16#005#,
+        pmask                   => 16#00F#,
+        imask                   => 16#1FFF0000#,
+        nbits                   => 29,
+        pirq                    => 10,
+        irqgen                  => 1
+      )
+      port map (
+        rst                     => rstn,
+        clk                     => clkm,
+        apbi                    => apbi,
+        apbo                    => apbo(5),
+        gpioi                   => gpioi,
+        gpioo                   => gpioo
+      );
+    
+    led_pads : outpadv generic map (width => 10, level => cmos, voltage => x25v, tech => padtech)
+      port map (led(12 downto 3), gpioo.dout(12 downto 3));
+    
+    dipsw_pad : inpadv generic map (width => 8, level => cmos, voltage => x15v, tech => padtech)
+      port map (dipsw, dipsw_int);
+    gpioi.din(23 downto 16) <= dipsw_int;
+    
+    pbtn_pad : inpadv generic map (width => 5, level => cmos, voltage => x15v, tech => padtech)
+      port map (pbtn, gpioi.din(28 downto 24));
+    
+    gpioi.din(1 downto 0) <= "00";
+    gpioi.din(15 downto 13) <= "000";
+    
+  end block;
+  
+  
+  ------------------------------------------------------------------------------
+  -- Audio output
+  ------------------------------------------------------------------------------
+  
+  audio: block is
+    signal state                : unsigned(7 downto 0);
+    signal sample               : std_logic_vector(7 downto 0);
+    signal read_ptr             : unsigned(11 downto 0);
+    signal write_ptr            : unsigned(11 downto 0);
+    signal remain               : unsigned(11 downto 0);
+    subtype fifo_type is rvex_byte_array(0 to 4095);
+    signal fifo                 : fifo_type;
+  begin
+    
+    process (clkm) is
+      variable push, pop: boolean;
+    begin
+      if rising_edge(clkm) then
+        
+        -- PWM value.
+        state <= state + 1;
+        
+        -- PWM output: abuse LED output. Can't really use the LCD output because
+        -- it can't drive a resistive load due to the bidirectional level
+        -- shifter.
+        if state < unsigned(sample) then
+          led(0) <= '1';
+        else
+          led(0) <= '0';
+        end if;
+        
+        -- r-VEX bus interface.
+        rvbso(CFG_NRVEX+1)          <= BUS_SLV2MST_IDLE;
+        rvbso(CFG_NRVEX+1).ack      <= bus_requesting(rvbsi(CFG_NRVEX+1));
+        rvbso(CFG_NRVEX+1).readData <= X"00000" & std_logic_vector(remain);
+        
+        -- Decode push enable.
+        if remain = 4095 then
+          push := false;
+        else
+          push := rvbsi(CFG_NRVEX+1).writeEnable = '1';
+        end if;
+        
+        -- Decode pop enable.
+        if remain = 0 then
+          pop := false;
+        else
+          pop := audio_next = '1';
+        end if;
+        
+        -- Handle pushing.
+        if push then
+          write_ptr <= write_ptr + 1;
+          if not pop then
+            remain <= remain + 1;
+          end if;
+        end if;
+        
+        -- Handle popping.
+        if pop then
+          read_ptr <= read_ptr + 1;
+          if not push then
+            remain <= remain - 1;
+          end if;
+        end if;
+        
+        -- Handle the interrupt.
+        if remain < 1024 then
+          audio_irq <= '1';
+        else
+          audio_irq <= '0';
+        end if;
+        
+      end if;
+    end process;
+    
+    fifo_ram_proc: process (clkm) is
+      variable addr_r : natural range 0 to 4095;
+      variable addr_w : natural range 0 to 4095;
+    begin
+      if rising_edge(clkm) then
+          
+        -- Decode addresses.
+        addr_r := to_integer(read_ptr);
+        addr_w := to_integer(write_ptr);
+        
+        -- Handle writes.
+        if rvbsi(CFG_NRVEX+1).writeEnable = '1' then
+          fifo(addr_w) <= rvbsi(CFG_NRVEX+1).writeData(31 downto 24);
+        end if;
+        
+        -- Handle reads.
+        sample <= fifo(addr_r);
+        
+      end if;
+    end process;
+    
+  end block;
+  
 end rtl;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/Makefile work/Makefile
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/Makefile	2014-04-16 16:50:08.000000000 +0200
+++ work/Makefile	2017-02-02 13:18:09.990630284 +0100
@@ -1,5 +1,5 @@
 include .config
-GRLIB=../..
+GRLIB=../../../grlib/grlib-gpl-1.3.7-b4144
 TOP=leon3mp
 DESIGN=leon3-xilinx-ml605
 BOARD=xilinx-ml605-xc6vlx240t
@@ -14,151 +14,92 @@ EFFORT=high
 XSTOPT=-uc leon3mp.xcf
 SYNPOPT="set_option -pipe 1; set_option -retiming 0; set_option -enable_prepacking 1;\
 set_option -write_apr_constraint 0;set_option -resource_sharing 1; set_option -symbolic_fsm_compiler 1"
+
 VHDLOPTSYNFILES= \
-	mig_37/user_design/rtl/controller/arb_mux.vhd \
-	mig_37/user_design/rtl/controller/arb_row_col.vhd \
-	mig_37/user_design/rtl/controller/arb_select.vhd \
-	mig_37/user_design/rtl/controller/bank_cntrl.vhd \
-	mig_37/user_design/rtl/controller/bank_common.vhd \
-	mig_37/user_design/rtl/controller/bank_compare.vhd \
-	mig_37/user_design/rtl/controller/bank_mach.vhd \
-	mig_37/user_design/rtl/controller/bank_queue.vhd \
-	mig_37/user_design/rtl/controller/bank_state.vhd \
-	mig_37/user_design/rtl/controller/col_mach.vhd \
-	mig_37/user_design/rtl/controller/mc.vhd \
-	mig_37/user_design/rtl/controller/rank_cntrl.vhd \
-	mig_37/user_design/rtl/controller/rank_common.vhd \
-	mig_37/user_design/rtl/controller/rank_mach.vhd \
-	mig_37/user_design/rtl/controller/round_robin_arb.vhd \
-	mig_37/user_design/rtl/ecc/ecc_buf.vhd \
-	mig_37/user_design/rtl/ecc/ecc_dec_fix.vhd \
-	mig_37/user_design/rtl/ecc/ecc_gen.vhd \
-	mig_37/user_design/rtl/ecc/ecc_merge_enc.vhd \
-	mig_37/user_design/rtl/ip_top/clk_ibuf.vhd \
-	mig_37/user_design/rtl/ip_top/ddr2_ddr3_chipscope.vhd \
-	mig_37/user_design/rtl/ip_top/infrastructure.vhd \
-	mig_37/user_design/rtl/ip_top/iodelay_ctrl.vhd \
-	mig_37/user_design/rtl/ip_top/mem_intfc.vhd \
-	mig_37/user_design/rtl/ip_top/memc_ui_top.vhd \
-	mig_37/user_design/rtl/ip_top/mig_37.vhd \
-	mig_37/user_design/rtl/phy/circ_buffer.vhd \
-	mig_37/user_design/rtl/phy/phy_ck_iob.vhd \
-	mig_37/user_design/rtl/phy/phy_clock_io.vhd \
-	mig_37/user_design/rtl/phy/phy_control_io.vhd \
-	mig_37/user_design/rtl/phy/phy_data_io.vhd \
-	mig_37/user_design/rtl/phy/phy_dly_ctrl.vhd \
-	mig_37/user_design/rtl/phy/phy_dm_iob.vhd \
-	mig_37/user_design/rtl/phy/phy_dq_iob.vhd \
-	mig_37/user_design/rtl/phy/phy_dqs_iob.vhd \
-	mig_37/user_design/rtl/phy/phy_init.vhd \
-	mig_37/user_design/rtl/phy/phy_pd.vhd \
-	mig_37/user_design/rtl/phy/phy_pd_top.vhd \
-	mig_37/user_design/rtl/phy/phy_rdclk_gen.vhd \
-	mig_37/user_design/rtl/phy/phy_rdctrl_sync.vhd \
-	mig_37/user_design/rtl/phy/phy_rddata_sync.vhd \
-	mig_37/user_design/rtl/phy/phy_rdlvl.vhd \
-	mig_37/user_design/rtl/phy/phy_read.vhd \
-	mig_37/user_design/rtl/phy/phy_top.vhd \
-	mig_37/user_design/rtl/phy/phy_write.vhd \
-	mig_37/user_design/rtl/phy/phy_wrlvl.vhd \
-	mig_37/user_design/rtl/phy/rd_bitslip.vhd \
-	mig_37/user_design/rtl/ui/ui_cmd.vhd \
-	mig_37/user_design/rtl/ui/ui_rd_data.vhd \
-	mig_37/user_design/rtl/ui/ui_top.vhd \
-	mig_37/user_design/rtl/ui/ui_wr_data.vhd \
-	pcie/v6_pcie_v1_7/source/*.vhd \
-	$(GRLIB)/lib/gaisler/pcie/pcie.vhd
-
-ifeq ("$(CONFIG_PCIEXP_MASTER_TARGET)","y")
-  ifeq ("$(CONFIG_LANE_WIDTH1)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane1.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane1.ucf
-  endif
-  ifeq ("$(CONFIG_LANE_WIDTH2)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane2.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane2.ucf
-  endif
-  ifeq ("$(CONFIG_LANE_WIDTH4)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane4.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane4.ucf
-  endif
-  ifeq ("$(CONFIG_LANE_WIDTH8)","y")
-  UCF+=pcie_ucf/pcie_master_target_lane8.ucf
-  UCF_PLANAHEAD+=pcie_ucf/pcie_master_target_lane8.ucf
-  endif
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pcie_master_target_virtex.vhd
-endif
-ifeq ("$(CONFIG_PCIEXP_MASTER_FIFO)","y")
-  ifeq ("$(CONFIG_PCIEXP_MASTER_FIFO_DMA)","y")
-    ifeq ("$(CONFIG_LANE_WIDTH1)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_dma_lane1.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_dma_lane1.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH2)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_dma_lane2.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_dma_lane2.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH4)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_dma_lane4.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_dma_lane4.ucf
-    endif
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pcie_master_fifo_virtex.vhd
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pciedma.vhd
-  endif
-  ifneq ("$(CONFIG_PCIEXP_MASTER_FIFO_DMA)","y")
-    ifeq ("$(CONFIG_LANE_WIDTH1)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_lane1.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_lane1.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH2)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_lane2.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_lane2.ucf
-    endif
-    ifeq ("$(CONFIG_LANE_WIDTH4)","y")
-    UCF+=pcie_ucf/pcie_master_fifo_lane4.ucf
-    UCF_PLANAHEAD+=pcie_ucf/pcie_master_fifo_lane4.ucf
-    endif
-VHDLOPTSYNFILES+=$(GRLIB)/lib/gaisler/pcie/pcie_master_fifo_virtex.vhd
-  endif
-endif
+  mig_37/user_design/rtl/controller/arb_mux.vhd \
+  mig_37/user_design/rtl/controller/arb_row_col.vhd \
+  mig_37/user_design/rtl/controller/arb_select.vhd \
+  mig_37/user_design/rtl/controller/bank_cntrl.vhd \
+  mig_37/user_design/rtl/controller/bank_common.vhd \
+  mig_37/user_design/rtl/controller/bank_compare.vhd \
+  mig_37/user_design/rtl/controller/bank_mach.vhd \
+  mig_37/user_design/rtl/controller/bank_queue.vhd \
+  mig_37/user_design/rtl/controller/bank_state.vhd \
+  mig_37/user_design/rtl/controller/col_mach.vhd \
+  mig_37/user_design/rtl/controller/mc.vhd \
+  mig_37/user_design/rtl/controller/rank_cntrl.vhd \
+  mig_37/user_design/rtl/controller/rank_common.vhd \
+  mig_37/user_design/rtl/controller/rank_mach.vhd \
+  mig_37/user_design/rtl/controller/round_robin_arb.vhd \
+  mig_37/user_design/rtl/ecc/ecc_buf.vhd \
+  mig_37/user_design/rtl/ecc/ecc_dec_fix.vhd \
+  mig_37/user_design/rtl/ecc/ecc_gen.vhd \
+  mig_37/user_design/rtl/ecc/ecc_merge_enc.vhd \
+  mig_37/user_design/rtl/ip_top/clk_ibuf.vhd \
+  mig_37/user_design/rtl/ip_top/ddr2_ddr3_chipscope.vhd \
+  mig_37/user_design/rtl/ip_top/infrastructure.vhd \
+  mig_37/user_design/rtl/ip_top/iodelay_ctrl.vhd \
+  mig_37/user_design/rtl/ip_top/mem_intfc.vhd \
+  mig_37/user_design/rtl/ip_top/memc_ui_top.vhd \
+  mig_37/user_design/rtl/ip_top/mig_37.vhd \
+  mig_37/user_design/rtl/phy/circ_buffer.vhd \
+  mig_37/user_design/rtl/phy/phy_ck_iob.vhd \
+  mig_37/user_design/rtl/phy/phy_clock_io.vhd \
+  mig_37/user_design/rtl/phy/phy_control_io.vhd \
+  mig_37/user_design/rtl/phy/phy_data_io.vhd \
+  mig_37/user_design/rtl/phy/phy_dly_ctrl.vhd \
+  mig_37/user_design/rtl/phy/phy_dm_iob.vhd \
+  mig_37/user_design/rtl/phy/phy_dq_iob.vhd \
+  mig_37/user_design/rtl/phy/phy_dqs_iob.vhd \
+  mig_37/user_design/rtl/phy/phy_init.vhd \
+  mig_37/user_design/rtl/phy/phy_pd.vhd \
+  mig_37/user_design/rtl/phy/phy_pd_top.vhd \
+  mig_37/user_design/rtl/phy/phy_rdclk_gen.vhd \
+  mig_37/user_design/rtl/phy/phy_rdctrl_sync.vhd \
+  mig_37/user_design/rtl/phy/phy_rddata_sync.vhd \
+  mig_37/user_design/rtl/phy/phy_rdlvl.vhd \
+  mig_37/user_design/rtl/phy/phy_read.vhd \
+  mig_37/user_design/rtl/phy/phy_top.vhd \
+  mig_37/user_design/rtl/phy/phy_write.vhd \
+  mig_37/user_design/rtl/phy/phy_wrlvl.vhd \
+  mig_37/user_design/rtl/phy/rd_bitslip.vhd \
+  mig_37/user_design/rtl/ui/ui_cmd.vhd \
+  mig_37/user_design/rtl/ui/ui_rd_data.vhd \
+  mig_37/user_design/rtl/ui/ui_top.vhd \
+  mig_37/user_design/rtl/ui/ui_wr_data.vhd
 
 VERILOGOPTSYNFILES= \
-	mig/user_design/rtl/controller/*.v \
-	mig/user_design/rtl/ecc/*.v \
-	mig/user_design/rtl/ip_top/*.v \
-	mig/user_design/rtl/phy/*.v \
-	mig/user_design/rtl/phy/*.v \
-	mig/user_design/rtl/ui/*.v \
-	$$XILINX/verilog/src/glbl.v
+  mig/user_design/rtl/controller/*.v \
+  mig/user_design/rtl/ecc/*.v \
+  mig/user_design/rtl/ip_top/*.v \
+  mig/user_design/rtl/phy/*.v \
+  mig/user_design/rtl/ui/*.v \
+  $$XILINX/verilog/src/glbl.v
+
 VHDLSYNFILES= \
 	ahb2mig_ml605.vhd config.vhd ahbrom.vhd \
-	svga2ch7301c.vhd gtxclk.vhd leon3mp.vhd
+	svga2ch7301c.vhd gtxclk.vhd \
+	ptag.vhd gracectrl.vhd leon3mp.vhd
 
-VHDLSIMFILES=testbench.vhd
+VERILOGSYNFILES = \
 
-ifeq ("$(CONFIG_PCIEXP_MASTER_TARGET)","y")
-VHDLSIMFILES+=$(GRLIB)/lib/tech/unisim/ise/GTPA1_DUAL.vhd $(GRLIB)/lib/tech/unisim/ise/GTP_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/GTXE1.vhd $(GRLIB)/lib/tech/unisim/ise/GTX_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/PCIE_2_0.vhd $(GRLIB)/lib/tech/unisim/ise/PCIE_A1.vhd
-else 
-ifeq ("$(CONFIG_PCIEXP_MASTER_FIFO)","y")
-VHDLSIMFILES+=$(GRLIB)/lib/tech/unisim/ise/GTPA1_DUAL.vhd $(GRLIB)/lib/tech/unisim/ise/GTP_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/GTXE1.vhd $(GRLIB)/lib/tech/unisim/ise/GTX_DUAL.vhd \
-$(GRLIB)/lib/tech/unisim/ise/PCIE_2_0.vhd $(GRLIB)/lib/tech/unisim/ise/PCIE_A1.vhd
-endif
-endif
+
+VERILOGSIMFILES =
+VHDLSIMFILES= \
+	testbench.vhd
 
 SIMTOP=testbench
 SDCFILE=default.sdc
 BITGEN=$(GRLIB)/boards/$(BOARD)/default.ut
-CLEAN=soft-clean migclean pcieclean
-TECHLIBS = secureip unisim
-VLOGOPT= -O0
-VCOMOPT= -explicit -O0 
+CLEAN=soft-clean migclean
+TECHLIBS = secureip unisim unimacro
+EXTRALIBS=../../../lib
+VLOGOPT= -O0 +incdir+../design/tb/include
+VCOMOPT= -explicit -O0
 ifeq ("$(GRLIB_SIMULATOR)","ALDEC")
 VSIMOPT= +access +w -t ps -novopt +notimingchecks -L secureip_ver -L xilinxcorelib_ver -L unisims_ver glbl $(SIMTOP)
 else
-VSIMOPT= -t ps -novopt +notimingchecks -L secureip_ver -L xilinxcorelib_ver -L unisims_ver glbl $(SIMTOP)
+VSIMOPT= -t ps -do ../phy.do -novopt +notimingchecks -L secureip_ver -L xilinxcorelib_ver -L unisims_ver glbl $(SIMTOP)
 endif
 
 LIBSKIP = core1553bbc core1553brm core1553brt gr1553 corePCIF \
@@ -166,8 +107,8 @@ LIBSKIP = core1553bbc core1553brm core15
 	spansion
 DIRSKIP = b1553 pci/pcif leon2 leon2ft crypto satcan ambatest can \
 	usb grusbhc spacewire ascs slink spi hcan \
-	leon4 leon4v0 l2cache pwm gr1553b iommu ac97
-FILESKIP = grcan.vhd ddr2.v mobile_ddr.v
+	leon3v3 leon4 leon4v0 l2cache pwm gr1553b iommu ac97
+FILESKIP = grcan.vhd ddr2.v mobile_ddr.v leaves.vhd gracectrl.vhd
 GRLIB_CONFIG = grlib_config.vhd
 
 include $(GRLIB)/bin/Makefile
@@ -175,6 +116,9 @@ include $(GRLIB)/software/leon3/Makefile
 
 ##################  project specific targets ##########################
 
+# Stop deleting logs!
+.SECONDARY:
+
 mig_37 mig:
 	cp grlib_mig/mig.* .
 	coregen -b mig.xco -p mig.cgp
@@ -192,11 +136,3 @@ mig39:
 migclean:
 	-rm -rf tmp coregen* mig*
 
-pcie:
-	coregen -b pcie/pcie.xco -p pcie
-	patch -p0 < pcie.diff
-
-pcieclean:
-	-rm -rf pcie/v6_pcie_v1_7* pcie/tmp pcie/coregen.cgc tx.dat rx.dat
-
-.PHONY : pcie pcieclean
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie/coregen.cgp work/pcie/coregen.cgp
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie/coregen.cgp	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie/coregen.cgp	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-# Date: Wed Aug  8 14:52:14 2012
-
-SET addpads = false
-SET asysymbol = true
-SET busformat = BusFormatAngleBracketNotRipped
-SET createndf = false
-SET designentry = VHDL
-SET device = xc6vlx240t
-SET devicefamily = virtex6
-SET flowvendor = Other
-SET formalverification = false
-SET foundationsym = false
-SET implementationfiletype = Ngc
-SET package = ff1156
-SET removerpms = false
-SET simulationfiles = Behavioral
-SET speedgrade = -1
-SET verilogsim = false
-SET vhdlsim = true
-SET workingdirectory = ./tmp/
-
-# CRC: efb42278
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie/pcie.xco work/pcie/pcie.xco
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie/pcie.xco	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie/pcie.xco	1970-01-01 01:00:00.000000000 +0100
@@ -1,205 +0,0 @@
-##############################################################
-#
-# Xilinx Core Generator version 13.2
-# Date: Wed Aug  8 14:55:22 2012
-#
-##############################################################
-#
-#  This file contains the customisation parameters for a
-#  Xilinx CORE Generator IP GUI. It is strongly recommended
-#  that you do not manually alter this file as it may cause
-#  unexpected and unsupported behavior.
-#
-##############################################################
-#
-#  Generated from component: xilinx.com:ip:v6_pcie:1.7
-#
-##############################################################
-#
-# BEGIN Project Options
-SET addpads = false
-SET asysymbol = true
-SET busformat = BusFormatAngleBracketNotRipped
-SET createndf = false
-SET designentry = VHDL
-SET device = xc6vlx240t
-SET devicefamily = virtex6
-SET flowvendor = Other
-SET formalverification = false
-SET foundationsym = false
-SET implementationfiletype = Ngc
-SET package = ff1156
-SET removerpms = false
-SET simulationfiles = Behavioral
-SET speedgrade = -1
-SET verilogsim = false
-SET vhdlsim = true
-# END Project Options
-# BEGIN Select
-SELECT Virtex-6_Integrated_Block_for_PCI_Express family Xilinx,_Inc. 1.7
-# END Select
-# BEGIN Parameters
-CSET acceptable_l0s_latency=Maximum_of_64_ns
-CSET acceptable_l1_latency=No_limit
-CSET ack_nak_timeout_func=Absolute
-CSET ack_nak_timeout_value=0000
-CSET bar0_64bit=false
-CSET bar0_enabled=true
-CSET bar0_prefetchable=false
-CSET bar0_scale=Megabytes
-CSET bar0_size=2
-CSET bar0_type=Memory
-CSET bar1_64bit=false
-CSET bar1_enabled=false
-CSET bar1_prefetchable=false
-CSET bar1_scale=Kilobytes
-CSET bar1_size=2
-CSET bar1_type=N/A
-CSET bar2_64bit=false
-CSET bar2_enabled=false
-CSET bar2_prefetchable=false
-CSET bar2_scale=Bytes
-CSET bar2_size=128
-CSET bar2_type=N/A
-CSET bar3_64bit=false
-CSET bar3_enabled=false
-CSET bar3_prefetchable=false
-CSET bar3_scale=Kilobytes
-CSET bar3_size=2
-CSET bar3_type=N/A
-CSET bar4_64bit=false
-CSET bar4_enabled=false
-CSET bar4_prefetchable=false
-CSET bar4_scale=Kilobytes
-CSET bar4_size=2
-CSET bar4_type=N/A
-CSET bar5_enabled=false
-CSET bar5_prefetchable=false
-CSET bar5_scale=Kilobytes
-CSET bar5_size=2
-CSET bar5_type=N/A
-CSET base_class_menu=Simple_communication_controllers
-CSET buf_opt_bma=false
-CSET cardbus_cis_pointer=00000000
-CSET class_code_base=05
-CSET class_code_interface=00
-CSET class_code_sub=00
-CSET component_name=v6_pcie_v1_7
-CSET cost_table=1
-CSET cpl_finite=false
-CSET cpl_timeout_disable_sup=false
-CSET cpl_timeout_range=Range_B
-CSET d0_pme_support=true
-CSET d0_power_consumed=0
-CSET d0_power_consumed_factor=0
-CSET d0_power_dissipated=0
-CSET d0_power_dissipated_factor=0
-CSET d1_pme_support=true
-CSET d1_power_consumed=0
-CSET d1_power_consumed_factor=0
-CSET d1_power_dissipated=0
-CSET d1_power_dissipated_factor=0
-CSET d1_support=false
-CSET d2_pme_support=true
-CSET d2_power_consumed=0
-CSET d2_power_consumed_factor=0
-CSET d2_power_dissipated=0
-CSET d2_power_dissipated_factor=0
-CSET d2_support=false
-CSET d3_power_consumed=0
-CSET d3_power_consumed_factor=0
-CSET d3_power_dissipated=0
-CSET d3_power_dissipated_factor=0
-CSET d3cold_pme_support=false
-CSET d3hot_pme_support=true
-CSET de_emph=0
-CSET device_id=0007
-CSET device_port_type=PCI_Express_Endpoint_device
-CSET device_specific_initialization=false
-CSET disable_tx_aspm_l0s=false
-CSET dll_link_active_cap=false
-CSET downstream_link_num=00
-CSET dsn_enabled=true
-CSET en_route_err_cor=false
-CSET en_route_err_ftl=false
-CSET en_route_err_nfl=false
-CSET en_route_inta=false
-CSET en_route_intb=false
-CSET en_route_intc=false
-CSET en_route_intd=false
-CSET en_route_pm_pme=false
-CSET en_route_pme_to=false
-CSET en_route_pme_to_ack=false
-CSET en_route_unlock=false
-CSET enable_ack_nak_timer=false
-CSET enable_lane_reversal=false
-CSET enable_replay_timer=true
-CSET enable_slot_clock_cfg=true
-CSET expansion_rom_enabled=false
-CSET expansion_rom_scale=Kilobytes
-CSET expansion_rom_size=2
-CSET ext_pci_cfg_space=false
-CSET ext_pci_cfg_space_addr=3FF
-CSET extended_tag_field=false
-CSET force_no_scrambling=false
-CSET hw_auton_spd_disable=false
-CSET intx_generation=true
-CSET io_base_limit_registers=Disabled
-CSET legacy_interrupt=INTA
-CSET link_speed=2.5_GT/s
-CSET max_payload_size=128_bytes
-CSET maximum_link_width=X8
-CSET msi_64b=true
-CSET msi_enabled=true
-CSET msi_vec_mask=false
-CSET msix_enabled=false
-CSET msix_pba_bir=BAR_0
-CSET msix_pba_offset=0
-CSET msix_table_bir=BAR_0
-CSET msix_table_offset=0
-CSET msix_table_size=1
-CSET multiple_message_capable=1_vector
-CSET no_soft_reset=true
-CSET pci_cfg_space=false
-CSET pci_cfg_space_addr=3F
-CSET pcie_blk_locn=X0Y0
-CSET pcie_cap_slot_implemented=false
-CSET pcie_debug_ports=false
-CSET perf_level=Good
-CSET phantom_functions=No_function_number_bits_used
-CSET pipe_pipeline=None
-CSET prefetchable_memory_base_limit_registers=Disabled
-CSET rcb=64_byte
-CSET ref_clk_freq=100_MHz
-CSET replay_timeout_func=Add
-CSET replay_timeout_value=0026
-CSET revision_id=00
-CSET root_cap_crs=false
-CSET slot_cap_attn_butn=false
-CSET slot_cap_attn_ind=false
-CSET slot_cap_elec_interlock=false
-CSET slot_cap_hotplug_cap=false
-CSET slot_cap_hotplug_surprise=false
-CSET slot_cap_mrl=false
-CSET slot_cap_no_cmd_comp_sup=false
-CSET slot_cap_physical_slot_num=0
-CSET slot_cap_pwr_ctrl=false
-CSET slot_cap_pwr_ind=false
-CSET slot_cap_pwr_limit_scale=0
-CSET slot_cap_pwr_limit_value=0
-CSET sub_class_interface_menu=Generic_XT_compatible_serial_controller
-CSET subsystem_id=0007
-CSET subsystem_vendor_id=10EE
-CSET trans_buf_pipeline=None
-CSET trgt_link_speed=4'h1
-CSET trim_tlp_digest=false
-CSET upconfigure_capable=true
-CSET user_clk_freq=250_default
-CSET vc_cap_enabled=false
-CSET vc_cap_reject_snoop=false
-CSET vendor_id=10EE
-CSET vsec_enabled=false
-CSET xlnx_ref_board=ML_605
-# END Parameters
-GENERATE
-# CRC: 1ab9c854
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie.diff work/pcie.diff
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie.diff	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie.diff	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
-diff -Naur pcie.org/v6_pcie_v1_7/source/v6_pcie_v1_7.vhd pcie/v6_pcie_v1_7/source/v6_pcie_v1_7.vhd
---- pcie.org/v6_pcie_v1_7/source/v6_pcie_v1_7.vhd	2013-07-16 16:50:59.000000000 +0200
-+++ pcie/v6_pcie_v1_7/source/v6_pcie_v1_7.vhd	2012-08-10 12:23:30.000000000 +0200
-@@ -752,10 +752,10 @@
-       VSEC_CAP_ON                              : boolean;
-       VSEC_CAP_VERSION                         : bit_vector);
-     port (
--      PCIEXPRXN                           : in  std_logic_vector(7 downto 0);
--      PCIEXPRXP                           : in  std_logic_vector(7 downto 0);
--      PCIEXPTXN                           : out std_logic_vector(7 downto 0);
--      PCIEXPTXP                           : out std_logic_vector(7 downto 0);
-+      PCIEXPRXN                           : in  std_logic_vector(LINK_CAP_MAX_LINK_WIDTH_int-1 downto 0);
-+      PCIEXPRXP                           : in  std_logic_vector(LINK_CAP_MAX_LINK_WIDTH_int-1 downto 0);
-+      PCIEXPTXN                           : out std_logic_vector(LINK_CAP_MAX_LINK_WIDTH_int-1 downto 0);
-+      PCIEXPTXP                           : out std_logic_vector(LINK_CAP_MAX_LINK_WIDTH_int-1 downto 0);
-       SYSCLK                              : in  std_logic;
-       FUNDRSTN                            : in  std_logic;
-       TRNLNKUPN                           : out std_logic;
-
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_dma_lane1.ucf work/pcie_ucf/pcie_master_fifo_dma_lane1.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_dma_lane1.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_fifo_dma_lane1.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mf.dma/EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mf.dma/EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/user_clk_prebuf" TNM_NET = "CLK_USER_CLK" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_USER_CLK" = PERIOD "CLK_USER_CLK" TS_SYSCLK/1.6 HIGH 50 % PRIORITY 1;
-
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_dma_lane2.ucf work/pcie_ucf/pcie_master_fifo_dma_lane2.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_dma_lane2.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_fifo_dma_lane2.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mf.dma/EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mf.dma/EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/user_clk_prebuf" TNM_NET = "CLK_USER_CLK" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_USER_CLK" = PERIOD "CLK_USER_CLK" TS_SYSCLK/1.6 HIGH 50 % PRIORITY 1;
-
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_dma_lane4.ucf work/pcie_ucf/pcie_master_fifo_dma_lane4.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_dma_lane4.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_fifo_dma_lane4.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mf.dma/EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-# PCIe Lane 2
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[2].GTX" LOC = GTXE1_X0Y13;
-# PCIe Lane 3
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[3].GTX" LOC = GTXE1_X0Y12;
-
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mf.dma/EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mf.dma/EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_lane1.ucf work/pcie_ucf/pcie_master_fifo_lane1.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_lane1.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_fifo_lane1.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mf_no_dma.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mf_no_dma.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/user_clk_prebuf" TNM_NET = "CLK_USER_CLK" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_USER_CLK" = PERIOD "CLK_USER_CLK" TS_SYSCLK/1.6 HIGH 50 % PRIORITY 1;
-
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_lane2.ucf work/pcie_ucf/pcie_master_fifo_lane2.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_lane2.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_fifo_lane2.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mf_no_dma.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mf_no_dma.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/user_clk_prebuf" TNM_NET = "CLK_USER_CLK" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_USER_CLK" = PERIOD "CLK_USER_CLK" TS_SYSCLK/1.6 HIGH 50 % PRIORITY 1;
-
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_lane4.ucf work/pcie_ucf/pcie_master_fifo_lane4.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_fifo_lane4.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_fifo_lane4.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,34 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mf_no_dma.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-# PCIe Lane 2
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[2].GTX" LOC = GTXE1_X0Y13;
-# PCIe Lane 3
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[3].GTX" LOC = GTXE1_X0Y12;
-
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mf_no_dma.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-
-
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mf_no_dma.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane1.ucf work/pcie_ucf/pcie_master_target_lane1.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane1.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_target_lane1.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mt.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mt.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/user_clk_prebuf" TNM_NET = "CLK_USER_CLK" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_USER_CLK" = PERIOD "CLK_USER_CLK" TS_SYSCLK/1.6 HIGH 50 % PRIORITY 1;
-
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane2.ucf work/pcie_ucf/pcie_master_target_lane2.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane2.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_target_lane2.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mt.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mt.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/user_clk_prebuf" TNM_NET = "CLK_USER_CLK" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_USER_CLK" = PERIOD "CLK_USER_CLK" TS_SYSCLK/1.6 HIGH 50 % PRIORITY 1;
-
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane4.ucf work/pcie_ucf/pcie_master_target_lane4.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane4.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_target_lane4.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mt.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-# PCIe Lane 2
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[2].GTX" LOC = GTXE1_X0Y13;
-# PCIe Lane 3
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[3].GTX" LOC = GTXE1_X0Y12;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mt.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 1 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane8.ucf work/pcie_ucf/pcie_master_target_lane8.ucf
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/pcie_ucf/pcie_master_target_lane8.ucf	2014-04-16 16:50:08.000000000 +0200
+++ work/pcie_ucf/pcie_master_target_lane8.ucf	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-NET "sys_reset_n" TIG;
-NET "sys_reset_n" LOC = AE13 | IOSTANDARD = LVCMOS25 | PULLUP | NODELAY ;
-
-#NET "sys_clk_p" LOC = P6;
-#NET "sys_clk_n" LOC = P5;
-INST "pcie_mt.EP/pcie_clk_v6.refclk_ibuf" LOC = IBUFDS_GTXE1_X0Y6;
-
-# PCIe Lane 0
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[0].GTX" LOC = GTXE1_X0Y15;
-# PCIe Lane 1
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[1].GTX" LOC = GTXE1_X0Y14;
-# PCIe Lane 2
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[2].GTX" LOC = GTXE1_X0Y13;
-# PCIe Lane 3
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[3].GTX" LOC = GTXE1_X0Y12;
-# PCIe Lane 4
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[4].GTX" LOC = GTXE1_X0Y11;
-# PCIe Lane 5
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[5].GTX" LOC = GTXE1_X0Y10;
-# PCIe Lane 6
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[6].GTX" LOC = GTXE1_X0Y9;
-# PCIe Lane 7
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_gt_i/gtx_v6_i/GTXD[7].GTX" LOC = GTXE1_X0Y8;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_2_0_i/pcie_block_i" LOC = PCIE_X0Y1;
-
-INST "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i" LOC = MMCM_ADV_X0Y7;
-
-# Timing Constraints
-
-NET "pcie_mt.EP/sys_clk_c" TNM_NET = "SYSCLK" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_125" TNM_NET = "CLK_125" ;
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/TxOutClk_bufg" TNM_NET = "TXOUTCLKBUFG";
-NET "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/clk_250" TNM_NET = "CLK_250" ;
-
-TIMESPEC "TS_SYSCLK"  = PERIOD "SYSCLK" 100 MHz HIGH 50 % ;
-TIMESPEC "TS_CLK_125"  = PERIOD "CLK_125" TS_SYSCLK*1.25 HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_TXOUTCLKBUFG"  = PERIOD "TXOUTCLKBUFG" 100 MHz HIGH 50 % PRIORITY 100 ;
-TIMESPEC "TS_CLK_250" = PERIOD "CLK_250" TS_SYSCLK*2.5 HIGH 50 % PRIORITY 1;
-
-
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_int_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/trn_reset_n_i.CLR" TIG ;
-PIN "pcie_mt.EP/pcie_v6.v6_pcie_v1_7_i/pcie_clocking_i/mmcm_adv_i.RST" TIG ;
-
-#TIMESPEC "TS_RESETN" = FROM FFS(*) TO FFS(trn_reset_n_i) 8 ns;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/svga2ch7301c.vhd work/svga2ch7301c.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/svga2ch7301c.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/svga2ch7301c.vhd	2017-02-02 13:18:09.990630284 +0100
@@ -98,9 +98,9 @@ architecture rtl of svga2ch7301c is
   signal d0, d1 : std_logic_vector(11 downto 0);
   signal red, green, blue : std_logic_vector(7 downto 0);
 
-  signal lvgaclk, vgaclk, clk40, clk65, clk50, clk25 : std_ulogic;
+  signal lvgaclk, vgaclk, clk40, clk6, clk12, clk25 : std_ulogic;
   
-  signal clkval : std_logic_vector(1 downto 0);
+  signal clkval : std_logic_vector(3 downto 0);
   signal clkval40 : std_logic_vector(1 downto 0);
   signal clkval65 : std_logic_vector(1 downto 0);
   
@@ -191,13 +191,13 @@ begin  -- rtl
   
   -- Clock selection
   bufg00 : BUFG port map (I => lvgaclk, O => vgaclk);
-  lvgaclk <= clk25 when clksel = "00" else clk40 when clksel = "01"
- 	else clk50 when clksel = "10" else clk65;
+  lvgaclk <= clk25 when clksel = "00" else clk12 when clksel = "01"
+ 	else clk6 when clksel = "10" else clk40;
   
   -- Generate clocks
   clkdiv : process(clk100, rstn)
   begin
-    if rstn = '0' then clkval <= "00";
+    if rstn = '0' then clkval <= "0000";
     elsif rising_edge(clk100) then
       clkval <= clkval + 1;
     end if;
@@ -214,8 +214,8 @@ begin  -- rtl
   end process;
 
   clk25 <= clkval(1);
-  clk50 <= clkval(0);
+  clk12 <= clkval(2);
+  clk6  <= clkval(3);
   clk40 <= clkval40(1);
-  clk65 <= clkval65(0);
   
 end rtl;
diff -rupN '--exclude=ram.srec' '--exclude=ptag.vhd' ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/testbench.vhd work/testbench.vhd
--- ../../grlib/grlib-gpl-1.3.7-b4144/designs/leon3-xilinx-ml605/testbench.vhd	2014-04-16 16:51:31.000000000 +0200
+++ work/testbench.vhd	2017-02-02 13:34:31.761894524 +0100
@@ -18,7 +18,7 @@
 --
 --  You should have received a copy of the GNU General Public License
 --  along with this program; if not, write to the Free Software
---  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
+--  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ------------------------------------------------------------------------------
 
 library ieee;
@@ -97,7 +97,7 @@ constant SIM_BYPASS_INIT_CAL : string :=
   signal ddr3_ck_p     : std_logic_vector(CK_WIDTH-1 downto 0);
   signal ddr3_ck_n     : std_logic_vector(CK_WIDTH-1 downto 0);
 
-  
+
   -- Debug support unit
   signal dsubre     : std_ulogic;
 
@@ -128,7 +128,10 @@ constant SIM_BYPASS_INIT_CAL : string :=
   signal gmiiclk_n  : std_logic := '0';
 
   -- Output signals for LEDs
-  signal led       : std_logic_vector(6 downto 0);
+  signal gpio      : std_logic_vector(6 downto 0);
+  signal led       : std_logic_vector(12 downto 0);
+  signal dipsw     : std_logic_vector(7 downto 0);
+  signal pbtn      : std_logic_vector(4 downto 0);
 
 signal iic_scl_main, iic_sda_main : std_logic;
 signal iic_scl_dvi, iic_sda_dvi : std_logic;
@@ -149,19 +152,6 @@ signal clk_33          : std_ulogic := '
 
   signal brdyn     : std_ulogic;
 
----------------------pcie----------------------------------------------
-signal cor_sys_reset_n : std_logic := '1';
-signal ep_sys_clk_p    : std_logic;
-signal ep_sys_clk_n    : std_logic;
-signal rp_sys_clk      : std_logic;
-
-signal cor_pci_exp_txn : std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-signal cor_pci_exp_txp : std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-signal cor_pci_exp_rxn : std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-signal cor_pci_exp_rxp : std_logic_vector(CFG_NO_OF_LANES-1 downto 0);
-
----------------------pcie end---------------------------------------------
-
 begin
 
   -- clock and reset
@@ -171,26 +161,21 @@ begin
   gmiiclk_p    <= not gmiiclk_p after 4 ns;
   gmiiclk_n    <= not gmiiclk_n after 4 ns;
   clk_33       <= not clk_33 after 15 ns;
-  rst        <= '1', '0' after 200 us;
+  rst        <= '1', '0' after 20 us;
   rstn1      <= not rst;
   dsubre     <= '0';
   urxd       <= 'H';
-  
+
   d3 : entity work.leon3mp
     generic map (fabtech, memtech, padtech, disas, dbguart, pclow,
-                 SIM_BYPASS_INIT_CAL)
+                 SIM_BYPASS_INIT_CAL, true)
     port map (
-      reset     => rst,
-      errorn    => error,
-      clk_ref_p    => clk200p,
-      clk_ref_n    => clk200n,
-
-      -- PROM
-      address   => address(24 downto 1),
-      data      => data(15 downto 0),
-      romsn     => romsn,
-      oen       => oen,
-      writen    => writen,
+      reset         => rst,
+      clk_ref_p     => clk200p,
+      clk_ref_n     => clk200n,
+      gmiiclk_p     => gmiiclk_p,
+      gmiiclk_n     => gmiiclk_n,
+      clk_33        => clk_33,
 
       -- DDR3
       ddr3_dq       => ddr3_dq,
@@ -209,60 +194,40 @@ begin
       ddr3_ck_p     => ddr3_ck_p,
       ddr3_ck_n     => ddr3_ck_n,
       
-      -- Debug Unit
-      dsubre    => dsubre,
-
-      -- AHB Uart
-      dsutx     => dsutx,
-      dsurx     => dsurx,
-
-      -- PHY
-      gmiiclk_p  => gmiiclk_p,
-      gmiiclk_n  => gmiiclk_n,
-      egtx_clk  => egtx_clk,
-      etx_clk   => etx_clk,
-      erx_clk   => erx_clk,
-      erxd      => erxdt(7 downto 0),
-      erx_dv    => erx_dv,
-      erx_er    => erx_er,
-      erx_col   => erx_col,
-      erx_crs   => erx_crs,
-      emdint    => emdint,
-      etxd      => etxdt(7 downto 0),
-      etx_en    => etx_en,
-      etx_er    => etx_er,
-      emdc      => emdc,
-      emdio     => emdio,
+      -- System ACE.
+      sysace_mpa    => sysace_mpa,
+      sysace_mpce   => sysace_mpce,
+      sysace_mpirq  => sysace_mpirq,
+      sysace_mpoe   => sysace_mpoe,
+      sysace_mpwe   => sysace_mpwe,
+      sysace_d      => sysace_d,
+      
+      -- DVI/VGA.
+      tft_lcd_data  => tft_lcd_data,
+      tft_lcd_clk_p => tft_lcd_clk_p,
+      tft_lcd_clk_n => tft_lcd_clk_n,
+      tft_lcd_hsync => tft_lcd_hsync,
+      tft_lcd_vsync => tft_lcd_vsync,
+      tft_lcd_de    => tft_lcd_de,
+      tft_lcd_reset_b => tft_lcd_reset_b,
+      
+      -- I2C interfaces.
+      dvi_iic_scl   => iic_scl_dvi,
+      dvi_iic_sda   => iic_sda_dvi,
+      pmbus_scl     => iic_scl_main,
+      pmbus_sda     => iic_sda_main,
+
+      -- Debug UART
+      dsutx         => dsutx,
+      dsurx         => dsurx,
 
       -- Output signals for LEDs
-        iic_scl_main => iic_scl_main, 
-	iic_sda_main => iic_sda_main,
-        dvi_iic_scl => iic_scl_dvi, 
-	dvi_iic_sda => iic_sda_dvi,
-        tft_lcd_data => tft_lcd_data, 
-	tft_lcd_clk_p => tft_lcd_clk_p, 
-	tft_lcd_clk_n => tft_lcd_clk_n, 
-	tft_lcd_hsync => tft_lcd_hsync,
-        tft_lcd_vsync => tft_lcd_vsync, 
-	tft_lcd_de => tft_lcd_de, 
-	tft_lcd_reset_b => tft_lcd_reset_b,
-        clk_33 => clk_33, 
-        sysace_mpa => sysace_mpa, 
-	sysace_mpce => sysace_mpce, 
-	sysace_mpirq => sysace_mpirq, 
-	sysace_mpoe => sysace_mpoe,
-        sysace_mpwe => sysace_mpwe, 
-	sysace_d => sysace_d,
-        pci_exp_txp=> cor_pci_exp_txp,
-        pci_exp_txn=> cor_pci_exp_txn,
-        pci_exp_rxp=> cor_pci_exp_rxp,
-        pci_exp_rxn=> cor_pci_exp_rxn,
-        sys_clk_p=> ep_sys_clk_p,   
-        sys_clk_n=> ep_sys_clk_n,
-        sys_reset_n=> cor_sys_reset_n,
-        led => led
-      );
-
+      gpio          => gpio,
+      led           => led,
+      dipsw         => dipsw,
+      pbtn          => pbtn
+      
+    );
 
   u1 : ddr3ram
     generic map (
@@ -289,14 +254,14 @@ begin
       wen    => ddr3_we_n,
       dm     => ddr3_dm,
       ba     => ddr3_ba,
-      a      => ddr3_addr,
+      a      => ddr3_addr(12 downto 0),
       resetn => ddr3_reset_n,
       dq     => ddr3_dq,
       dqs    => ddr3_dqs_p,
       dqsn   => ddr3_dqs_n,
       doload => led(3)
       );
-  
+
   address(0) <= '0';
   prom0 : for i in 0 to 1 generate
       sr0 : sram generic map (index => i+4, abits => 24, fname => promfile)
@@ -304,14 +269,6 @@ begin
                   writen, oen);
   end generate;
 
-  phy0 : if (CFG_GRETH = 1) generate
-    emdio <= 'H';
-    p0: phy
-      generic map (address => 7)
-      port map(rstn1, emdio, etx_clk, erx_clk, erxdt, erx_dv, erx_er,
-               erx_col, erx_crs, etxdt, etx_en, etx_er, emdc, egtx_clk);
-  end generate;
-
 --  spimem0: if CFG_SPIMCTRL = 1 generate
 --    s0 : spi_flash generic map (ftype => 4, debug => 0, fname => promfile,
 --                                readcmd => CFG_SPIMCTRL_READCMD,
