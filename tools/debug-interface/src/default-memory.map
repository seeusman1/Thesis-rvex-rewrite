#
# This file specifies the memory map for accessing the core through the debug
# interface. Each line consists of three parts: the context mask, the
# definition name and the value. The mask and definition name are separated by
# a colon, the value is enclosed by curly braces. Anything after a hash is
# ignored.
#
# -----------------------------------------------------------------------------
# Context mask
# -----------------------------------------------------------------------------
# rvd allows you to switch between multiple rvex contexts easily using the
# select command. Only the definitions in this file which contain the selected
# context in the mask will be evaluated. This allows you to specify different
# definitions for different contexts.
# 
# The context mask must be one of the following:
#  - "all": matches any context.
#  - <from>..<to>: range, matching any context within from and to inclusive.
#  - <context>: matches only the specified context.
#
# rvd supports up to 32 contexts, numbered from 0 to 31.
#
# -----------------------------------------------------------------------------
# Definition name and value
# -----------------------------------------------------------------------------
# Definitions in rvd can be used anywhere in place of an integer literal. They
# work kind of like #define in the C preprocessor, in that they are expanded
# when they are used, so definition order in this file does not matter. When
# used in expressions though, they behave as if there were parenthesis around
# the expansion compared to the C preprocessor.
#
# The value for a definition should be a valid expression. To get more
# information on how expressions work in rvd, run "rvd help expressions".
#

# Specifies the number of contexts. This defines what rvd will do when you run
# a command for all contexts. Should be defined for all contexts, there's no
# point in defining a different number for different contexts (obviously).
all:_NUM_CONTEXTS           { 4 }

# Control register base address.
all:CREG                    { 0xF0000000 }

# Coarse memory map for the control registers, hardcoded in core_ctrlRegs.vhd.
all:CREG_GLOB               { CREG + 0x000 }
all:CREG_GPREG              { CREG + 0x100 + (_CUR_CONTEXT * 0x400) }
all:CREG_CTXT               { CREG + 0x200 + (_CUR_CONTEXT * 0x400) }

# Aliases for the old register names.
all:DCRF                    { DCR }
all:C_CYC                   { CYC }
all:C_CYCH                  { CYCH }
all:C_STALL                 { STALL }
all:C_STALLH                { STALLH }
all:C_BUN                   { BUN }
all:C_BUNH                  { BUNH }
all:C_SYL                   { SYL }
all:C_SYLH                  { SYLH }
all:C_NOP                   { NOP }
all:C_NOPH                  { NOPH }
all:C_IACC                  { IACC }
all:C_IACCH                 { IACCH }
all:C_IMISS                 { IMISS }
all:C_IMISSH                { IMISSH }
all:C_DRACC                 { DRACC }
all:C_DRACCH                { DRACCH }
all:C_DRMISS                { DRMISS }
all:C_DRMISSH               { DRMISSH }
all:C_DWACC                 { DWACC }
all:C_DWACCH                { DWACCH }
all:C_DWMISS                { DWMISS }
all:C_DWMISSH               { DWMISSH }
all:C_DBYPASS               { DBYPASS }
all:C_DBYPASSH              { DBYPASSH }
all:C_DWBUF                 { DWBUF }
all:C_DWBUFH                { DWBUFH }

# This is called after a context change to set banking bits. Currently there
# are no banking bits, so this does nothing.
all:SET_BANK                { 0 }

all:PRINT_STATE { _STATE }

# Waits for completion of a program and then prints statistics. Should only be
# called using a single context.
all:WAIT_COMPLETE {
  
  printf("Waiting for program to terminate");
  
  # In case _NUM_CONTEXTS expands to something complicated, we'll want to
  # preload it here.
  set(count, _NUM_CONTEXTS);
  
  # Initialize prev_cycle things.
  set(prev_cyc0, 0);
  set(prev_cyc1, 0);
  set(prev_cyc2, 0);
  set(prev_cyc3, 0);
  set(prev_cyc4, 0);
  set(prev_cyc5, 0);
  set(prev_cyc6, 0);
  set(prev_cyc7, 0);
  
  # Wait for completion.
  set(diffs, 1);
  while (diffs, (
    
    # Load the current cycle counter values.
    if (count > 0, (set(_CUR_CONTEXT, 0); SET_BANK; set(cyc0, readWord(C_CYC))), set(cyc0, 0));
    if (count > 1, (set(_CUR_CONTEXT, 1); SET_BANK; set(cyc1, readWord(C_CYC))), set(cyc1, 0));
    if (count > 2, (set(_CUR_CONTEXT, 2); SET_BANK; set(cyc2, readWord(C_CYC))), set(cyc2, 0));
    if (count > 3, (set(_CUR_CONTEXT, 3); SET_BANK; set(cyc3, readWord(C_CYC))), set(cyc3, 0));
    if (count > 4, (set(_CUR_CONTEXT, 4); SET_BANK; set(cyc4, readWord(C_CYC))), set(cyc4, 0));
    if (count > 5, (set(_CUR_CONTEXT, 5); SET_BANK; set(cyc5, readWord(C_CYC))), set(cyc5, 0));
    if (count > 6, (set(_CUR_CONTEXT, 6); SET_BANK; set(cyc6, readWord(C_CYC))), set(cyc6, 0));
    if (count > 7, (set(_CUR_CONTEXT, 7); SET_BANK; set(cyc7, readWord(C_CYC))), set(cyc7, 0));
    
    # See if the cycle counter values changed since the last time we read them.
    set(diffs, 
      (cyc0 != prev_cyc0) ||
      (cyc1 != prev_cyc1) ||
      (cyc2 != prev_cyc2) ||
      (cyc3 != prev_cyc3) ||
      (cyc4 != prev_cyc4) ||
      (cyc5 != prev_cyc5) ||
      (cyc6 != prev_cyc6) ||
      (cyc7 != prev_cyc7)
    );
    
    # Store the previous values.
    set(prev_cyc0, cyc0);
    set(prev_cyc1, cyc1);
    set(prev_cyc2, cyc2);
    set(prev_cyc3, cyc3);
    set(prev_cyc4, cyc4);
    set(prev_cyc5, cyc5);
    set(prev_cyc6, cyc6);
    set(prev_cyc7, cyc7);
    
    # Delay for 500 milliseconds between checks.
    delay_ms(500);
    
    printf(".");
    
  ));
  
  printf(" done.\n\n");
  
  # Do a performance counter dump for each context.
  set(cur, 0);
  set(total_cyc, 0);
  while (cur < count, (
    
    set(_CUR_CONTEXT, cur);
    SET_BANK;
    printf("\033[1mPerformance counters for context %d:\033[0m\n", cur);
    set(cyc, readWord(C_CYC));
    set(total_cyc, total_cyc + cyc);
    printf("             Active cycles = %u\n", cyc);
    printf("        Active cycles high = %u\n", readWord(C_CYCH));
    printf("            Stalled cycles = %u\n", readWord(C_STALL));
    printf("    Committed bundle count = %u\n", readWord(C_BUN));
    printf("  Committed syllable count = %u\n", readWord(C_SYL));
    printf("       Committed NOP count = %u\n", readWord(C_NOP));
    printf("\n");
    printf("\033[1mPerformance counters for cache block %d:\033[0m\n", cur);
    printf("Instruction cache accesses = %u\n", readWord(C_IACC));
    printf("  Instruction cache misses = %u\n", readWord(C_IMISS));
    printf("  Data cache read accesses = %u\n", readWord(C_DRACC));
    printf("    Data cache read misses = %u\n", readWord(C_DRMISS));
    printf(" Data cache write accesses = %u\n", readWord(C_DWACC));
    printf("   Data cache write misses = %u\n", readWord(C_DWMISS));
    printf("Data cache bypass accesses = %u\n", readWord(C_DBYPASS));
    printf("Data cache accesses with buffered write = %u\n", readWord(C_DWBUF));
    printf("\n");
    
    set(cur, cur + 1);
  ));
  printf(" Sum of all active cycles = \033[1m%u\033[0m\n", total_cyc);
  printf(" (this is the total cycle count if contexts are never active at the same time)\n\n");
  
  set(cur, 0);
  printf("Processor cycle count = \033[1m%u\033[0m\n", readWordPreload(CREG_GPREG + (63*4)));
}



# This is evaluated before any rvd command is called.
all:_ALWAYS {
  SET_BANK;
}

# This is evaluated when "rvd break" is called.
all:_BREAK {
  write(DCRF, 0x09hh);
  PRINT_STATE;
}

# This is evaluated when "rvd step" is called.
all:_STEP {
  write(DCRF, 0x0Ahh);
  PRINT_STATE;
}
  
# This is evaluated when "rvd resume" is called.
all:_RESUME {
  write(DCRF, 0x0Chh);
}

# This is evaluated when "rvd release" is called.
all:_RELEASE {
  write(DCRF, 0x10hh);
}
  
# This is evaluated when "rvd reset" is called.
all:_RESET {
  write(DCRF, 0x09hh); # break
  set(reg, 0);
  while (reg < 64, (
    writeWord(CREG_GPREG + (reg*4), 0);
    set(reg, reg + 1);
  ));
  write(DCRF, 0x80hh); # reset
}
  
# This is evaluated when "rvd reset break" is called.
all:_RESET_BREAK {
  write(DCRF, 0x89hh);
}

# This is evaluated when "rvd gdb" waits for a breakpoint.
all:_WAIT {
  set(retval, 0x202);
  set(d, readWord(DCR));
  while (!(d & 0x01000000), (
    delay_ms(250);
    set(d, readWord(DCR));
  ));
  
  if (d & 0x80000000, (
    # STOP instruction.
    set(retval, readByte(RET));
  ), (
    # Debug trap.
    set(d, (d >> 16) & 0xFF);
    if (d == 0xFA, (
      # Software breakpoint.
      set(retval, 0x200);
    ));
    if (d == 0xFB, (
      # Single step.
      set(retval, 0x201);
    ));
    if (d >= 0xFC, (
      # Hardware breakpoint.
      set(retval, 0x100 + (d - 0xFC));
    ));
  ));
  retval
}

# This is evaluated when "rvd state" is called.
all:_STATE {
  
  printf("Dumping state for context %d...\n\n", _CUR_CONTEXT);
  
  SET_BANK;

  # Core running or stopped
  set (val, readByte(DCR));
  if (val&0x1,
    (printf("\033[1mCore stopped\033[0m\n");),
    (printf("\033[1mCore running\033[0m\n");)
  );
  printf("\n");
  
  # Special registers
  printf("\033[1mSpecial regs:\033[0m\n");
  printf("   PC = 0x%08X\n", readWord(PC));
  printf(" l0.0 = 0x%08X\n\n", readWord(LR));
  
  # General purpose registers
  printf("\033[1mGeneral purpose regs:\033[0m\n");
  preload(CREG_GPREG, 256);
  set(reg, 0);
  while (reg < 64, (
    set(val, readWordPreload(CREG_GPREG + (reg*4)));
    if (val, (
      printf("\033[1;32m");
    ));
    printf("r0.%.2d = 0x%08X  \033[0m", reg, val);
    set(reg, reg + 1);
    if (!(reg & 3), (
      printf("\n");
    ));
  ));
  printf("\n");
  
  # Branch registers
  printf("\033[1mBranch regs:\033[0m\n");
  set(val, readByte(BR));
  set(reg, 0);
  while (reg < 8, (
    if (val & (1 << reg), (
      printf("\033[1;32m b0.%d = true        \033[0m", reg);
    ), (
      printf(" b0.%d = false       \033[0m", reg);
    ));
    
    set(reg, reg + 1);
    if (!(reg & 3), (
      printf("\n");
    ));
  ));
  printf("\n");
  
  # Performance counters
  printf("\033[1mPerformance counters:\033[0m\n");
  printf("            Active cycles = %u\n", readWord(C_CYC));
  printf("       Active cycles high = %u\n", readWord(C_CYCH));
  printf("           Stalled cycles = %u\n", readWord(C_STALL));
  printf("   Committed bundle count = %u\n", readWord(C_BUN));
  printf(" Committed syllable count = %u\n", readWord(C_SYL));
  printf("      Committed NOP count = %u\n", readWord(C_NOP));
  printf("\n");
  
  # Trap registers
  printf("\033[1mTrap registers:\033[0m\n");
  printf("    Trap cause = %u\n", readByte(TC));
  printf("    Trap point = 0x%x\n", readWord(TP));
  printf(" Trap argument = 0x%x\n", readWord(TA));
  printf("\n");

}

# This reads out the low and high values of all performance counters.
all:_PERFORMANCE_COUNTERS {
  SET_BANK;
  
  printf("Performance counters for context %d:\n", _CUR_CONTEXT);
  
  printf("              Active cycles = %u\n", readWord(C_CYC));
  printf("         Active cycles high = %u\n", readWord(C_CYCH));
  printf("             Stalled cycles = %u\n", readWord(C_STALL));
  printf("             Stalled cycles = %u\n", readWord(C_STALLH));
  printf("     Committed bundle count = %u\n", readWord(C_BUN));
  printf("     Committed bundle count = %u\n", readWord(C_BUNH));
  printf("   Committed syllable count = %u\n", readWord(C_SYL));
  printf("   Committed syllable count = %u\n", readWord(C_SYLH));
  printf("        Committed NOP count = %u\n", readWord(C_NOP));
  printf("        Committed NOP count = %u\n", readWord(C_NOPH));
  printf("        ICache access count = %u\n", readWord(C_IACC));
  printf("        ICache access count = %u\n", readWord(C_IACCH));
  printf("          ICache miss count = %u\n", readWord(C_IMISS));
  printf("          ICache miss count = %u\n", readWord(C_IMISSH));
  printf("          DCache read count = %u\n", readWord(C_DRACC));
  printf("          DCache read count = %u\n", readWord(C_DRACCH));
  printf("     DCache read miss count = %u\n", readWord(C_DRMISS));
  printf("     DCache read miss count = %u\n", readWord(C_DRMISSH));
  printf("         DCache write count = %u\n", readWord(C_DWACC));
  printf("         DCache write count = %u\n", readWord(C_DWACCH));
  printf("    DCache write miss count = %u\n", readWord(C_DWMISS));
  printf("    DCache write miss count = %u\n", readWord(C_DWMISSH));
  printf("        DCache bypass count = %u\n", readWord(C_DBYPASS));
  printf("        DCache bypass count = %u\n", readWord(C_DBYPASSH));
  printf("DCache buffered write count = %u\n", readWord(C_DWBUF));
  printf("DCache buffered write count = %u\n", readWord(C_DWBUFH));
}

# Convert a core/gdb address to a debug bus address.
all:_GDB_ADDR_R { _GDB_ADDR }
all:_GDB_ADDR_W { _GDB_ADDR }

# Return the number of registers which gdb is aware of.
all:_GDB_REG_NUM { 81 }

# Read gdb registers.
all:_GDB_REG_PRE { preload(CREG_GPREG, 0x120) }
all:_GDB_REG_R {
  prioritize (
    _GDB_REG_INDEX < 64,  readWordPreload(CREG_GPREG + (_GDB_REG_INDEX*4)),
    _GDB_REG_INDEX < 72,  (readBytePreload(BR) & (1hh << (_GDB_REG_INDEX - 64))) != 0,
    _GDB_REG_INDEX == 72, readWordPreload(LR),
    _GDB_REG_INDEX == 73, readWordPreload(PC),
    _GDB_REG_INDEX == 74, readHalfPreload(CCRF),
    _GDB_REG_INDEX == 75, readHalfPreload(SCCRF),
    _GDB_REG_INDEX == 76, readBytePreload(TC),
    _GDB_REG_INDEX == 77, readWordPreload(TP),
    _GDB_REG_INDEX == 78, readWordPreload(TA),
    _GDB_REG_INDEX == 79, readWordPreload(TH),
    _GDB_REG_INDEX == 80, readWordPreload(PH)
  )
}

# Write gdb registers.
all:_GDB_REG_W {
  prioritize (
    _GDB_REG_INDEX < 64,  writeWord(CREG_GPREG + (_GDB_REG_INDEX*4), _GDB_REG_VALUE),
    _GDB_REG_INDEX < 72,  (
      set(brVal, readByte(BR));
      set(brMask, 1 << (_GDB_REG_INDEX - 64));
      set(brVal, (brVal & (~brMask)));
      if (_GDB_REG_VALUE, (
        set(brVal, brVal | brMask);
      ));
      writeByte(BR, brVal);
    ),
    _GDB_REG_INDEX == 72, writeWord(LR, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 73, writeWord(PC, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 74, writeHalf(CCRF, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 75, writeHalf(SCCRF, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 76, writeByte(TC, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 77, writeWord(TP, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 78, writeWord(TA, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 79, writeWord(TH, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 80, writeWord(PH, _GDB_REG_VALUE)
  )
}

# Soft breakpoint instruction: trap r0.0, 0xFA. Copy the stop bit from the
# syllable which is being replaced.
all:_GDB_SOFTBRK {
  0x908003E8w | (_GDB_SOFTBRK_SYL & 0x00000002w)
}

# Sets or deletes a breakpoint or watchpoint.
all:_GDB_HARDBRK {
  prioritize (
    
    # Fail if index >= 4.
    _GDB_HARDBRK_INDEX >= 4, 0,
    
    # Read-only watchpoints are not supported.
    _GDB_HARDBRK_TYPE == 3, 0,
    
    # Otherwise:
    1, (
      
      # Write the breakpoint address register.
      prioritize(
        _GDB_HARDBRK_INDEX == 0, writeWord(BRK0, _GDB_HARDBRK_ADDR),
        _GDB_HARDBRK_INDEX == 1, writeWord(BRK1, _GDB_HARDBRK_ADDR),
        _GDB_HARDBRK_INDEX == 2, writeWord(BRK2, _GDB_HARDBRK_ADDR),
        _GDB_HARDBRK_INDEX == 3, writeWord(BRK3, _GDB_HARDBRK_ADDR)
      );
      
      # Read the current breakpoint configuration register.
      set(cfg, readHalf(DCRB));
      
      # Clear the configuration nibble for the selected breakpoint.
      set(cfg, cfg & (~(0xF << (4 * _GDB_HARDBRK_INDEX))));
      
      # Load the new configuration for the selected breakpoint. The gdb
      # convention for this happens to match ours, except for that type 4 is
      # type 3 for us and that gdb type 3 is not supported.
      set(cfg, cfg | (if(_GDB_HARDBRK_TYPE==4,3,_GDB_HARDBRK_TYPE) << (4 * _GDB_HARDBRK_INDEX)));
      
      # Write the new configuration.
      writeHalf(DCRB, cfg);
      
      # Return success.
      1
    )
  )
}
