#
# This file specifies the memory map for accessing the core through the debug
# interface. Each line consists of three parts: the context mask, the
# definition name and the value. The mask and definition name are separated by
# a colon, the value is enclosed by curly braces. Anything after a hash is
# ignored.
#
# -----------------------------------------------------------------------------
# Context mask
# -----------------------------------------------------------------------------
# rvd allows you to switch between multiple rvex contexts easily using the
# select command. Only the definitions in this file which contain the selected
# context in the mask will be evaluated. This allows you to specify different
# definitions for different contexts.
# 
# The context mask must be one of the following:
#  - "all": matches any context.
#  - <from>..<to>: range, matching any context within from and to inclusive.
#  - <context>: matches only the specified context.
#
# rvd supports up to 32 contexts, numbered from 0 to 31.
#
# -----------------------------------------------------------------------------
# Definition name and value
# -----------------------------------------------------------------------------
# Definitions in rvd can be used anywhere in place of an integer literal. They
# work kind of like #define in the C preprocessor, in that they are expanded
# when they are used, so definition order in this file does not matter. When
# used in expressions though, they behave as if there were parenthesis around
# the expansion compared to the C preprocessor.
#
# The value for a definition should be a valid expression. To get more
# information on how expressions work in rvd, run "rvd help expressions".
#

# Specifies the number of contexts. This defines what rvd will do when you run
# a command for all contexts. Should be defined for all contexts, there's no
# point in defining a different number for different contexts (obviously).
all:_NUM_CONTEXTS           { 4 }

# Control register base address.
all:CREG                    { 0xF0000000 }

# Coarse memory map for the control registers, hardcoded in core_ctrlRegs.vhd.
all:CREG_GLOB               { CREG + 0x000 }
all:CREG_GPREG              { CREG + 0x100 + (_CUR_CONTEXT * 0x400) }
all:CREG_CTXT               { CREG + 0x200 + (_CUR_CONTEXT * 0x400) }

# Control register mnemonics. These should match the values in
# core_ctrlRegs_pkg.vhd.
all:GSR                     { CREG_GLOB + 0x00 } # Global status register.
all:BUS_BANK                { CREG_GLOB + 0x03 } # Debug bus bank selection.
all:BCRR                    { CREG_GLOB + 0x04 } # Debug bus reconfiguration request.
all:CC                      { CREG_GLOB + 0x08 } # Current configuration.
all:AFF                     { CREG_GLOB + 0x0C } # Cache affinity.
all:CNT                     { CREG_GLOB + 0x10 } # Cycle counter.
all:CCR                     { CREG_CTXT + 0x00 } # Context control register.
all:TC                      { CREG_CTXT + 0x00 } # Trap cause (byte).
all:BR                      { CREG_CTXT + 0x01 } # Branch registers (byte).
all:SCCR                    { CREG_CTXT + 0x04 } # Saved context control register.
all:LR                      { CREG_CTXT + 0x08 } # Link register.
all:PC                      { CREG_CTXT + 0x0C } # PC register.
all:TH                      { CREG_CTXT + 0x10 } # Trap handler.
all:PH                      { CREG_CTXT + 0x14 } # Panic handler.
all:TP                      { CREG_CTXT + 0x18 } # Trap point.
all:TA                      { CREG_CTXT + 0x1C } # Trap argument.
all:BRK0                    { CREG_CTXT + 0x20 } # Breakpoint 0.
all:BRK1                    { CREG_CTXT + 0x24 } # Breakpoint 1.
all:BRK2                    { CREG_CTXT + 0x28 } # Breakpoint 2.
all:BRK3                    { CREG_CTXT + 0x2C } # Breakpoint 3.
all:DCR                     { CREG_CTXT + 0x30 } # Debug control register 1.
all:DCRF                    { CREG_CTXT + 0x30 } # Debug control flags (byte).
all:DCRC                    { CREG_CTXT + 0x31 } # Break cause (byte).
all:DCRB                    { CREG_CTXT + 0x32 } # Breakpoint configuration (half).
all:DCR2                    { CREG_CTXT + 0x34 } # Debug control register 2.
all:RET                     { CREG_CTXT + 0x34 } # Program return value (byte).
all:_TRACE_CTRL             { CREG_CTXT + 0x37 } # Trace control register (byte).
all:CRR                     { CREG_CTXT + 0x38 } # Context reconfiguration request.
all:C_CYC                   { CREG_CTXT + 0x3C } # Non-idle cycle counter.
all:C_STALL                 { CREG_CTXT + 0x40 } # Non-idle stall counter.
all:C_BUN                   { CREG_CTXT + 0x44 } # Committed bundle counter.
all:C_SYL                   { CREG_CTXT + 0x48 } # Committed syllable counter.
all:C_NOP                   { CREG_CTXT + 0x4C } # Committed NOP counter.
all:SCRP                    { CREG_CTXT + 0x50 } # Scratch-pad register 1.
all:SCRP2                   { CREG_CTXT + 0x54 } # Scratch-pad register 2.
all:SCRP3                   { CREG_CTXT + 0x58 } # Scratch-pad register 3.
all:SCRP4                   { CREG_CTXT + 0x5C } # Scratch-pad register 4.

# This is called after a context change to set banking bits. Currently there
# are no banking bits, so this does nothing.
all:SET_BANK                { 0 }

all:PRINT_STATE {
  printf("Dumping state for context %d...\n\n", _CUR_CONTEXT);
  
  SET_BANK;
  
  # Special registers
  printf("\033[1mSpecial regs:\033[0m\n");
  printf("   PC = 0x%08X\n", readWord(PC));
  printf(" l0.0 = 0x%08X\n\n", readWord(LR));
  
  # General purpose registers
  printf("\033[1mGeneral purpose regs:\033[0m\n");
  set(reg, 0);
  while (reg < 64, (
    set(val, readWord(CREG_GPREG + (reg*4)));
    if (val, (
      printf("\033[1;32m");
    ));
    printf("r0.%.2d = 0x%08X  \033[0m", reg, val);
    set(reg, reg + 1);
    if (!(reg & 3), (
      printf("\n");
    ));
  ));
  printf("\n");
  
  # Branch registers
  printf("\033[1mBranch regs:\033[0m\n");
  set(val, readByte(BR));
  set(reg, 0);
  while (reg < 8, (
    if (val & (1 << reg), (
      printf("\033[1;32m b0.%d = true        \033[0m", reg);
    ), (
      printf(" b0.%d = false       \033[0m", reg);
    ));
    
    set(reg, reg + 1);
    if (!(reg & 3), (
      printf("\n");
    ));
  ));
  printf("\n");
  
  # Performance counters
  printf("\033[1mPerformance counters:\033[0m\n");
  printf("            Active cycles = %u\n", readWord(C_CYC));
  printf("           Stalled cycles = %u\n", readWord(C_STALL));
  printf("   Committed bundle count = %u\n", readWord(C_BUN));
  printf(" Committed syllable count = %u\n", readWord(C_SYL));
  printf("      Committed NOP count = %u\n", readWord(C_NOP));
  printf("\n");
  
}

# Waits for completion of a program and then prints statistics. Should only be
# called using a single context.
all:WAIT_COMPLETE {
  
  printf("Waiting for program to terminate");
  
  # In case _NUM_CONTEXTS expands to something complicated, we'll want to
  # preload it here.
  set(count, _NUM_CONTEXTS);
  
  # Initialize prev_cycle things.
  set(prev_cyc0, 0);
  set(prev_cyc1, 0);
  set(prev_cyc2, 0);
  set(prev_cyc3, 0);
  set(prev_cyc4, 0);
  set(prev_cyc5, 0);
  set(prev_cyc6, 0);
  set(prev_cyc7, 0);
  
  # Wait for completion.
  set(diffs, 1);
  while (diffs, (
    
    # Load the current cycle counter values.
    if (count > 0, (set(_CUR_CONTEXT, 0); SET_BANK; set(cyc0, readWord(C_CYC))), set(cyc0, 0));
    if (count > 1, (set(_CUR_CONTEXT, 1); SET_BANK; set(cyc1, readWord(C_CYC))), set(cyc1, 0));
    if (count > 2, (set(_CUR_CONTEXT, 2); SET_BANK; set(cyc2, readWord(C_CYC))), set(cyc2, 0));
    if (count > 3, (set(_CUR_CONTEXT, 3); SET_BANK; set(cyc3, readWord(C_CYC))), set(cyc3, 0));
    if (count > 4, (set(_CUR_CONTEXT, 4); SET_BANK; set(cyc4, readWord(C_CYC))), set(cyc4, 0));
    if (count > 5, (set(_CUR_CONTEXT, 5); SET_BANK; set(cyc5, readWord(C_CYC))), set(cyc5, 0));
    if (count > 6, (set(_CUR_CONTEXT, 6); SET_BANK; set(cyc6, readWord(C_CYC))), set(cyc6, 0));
    if (count > 7, (set(_CUR_CONTEXT, 7); SET_BANK; set(cyc7, readWord(C_CYC))), set(cyc7, 0));
    
    # See if the cycle counter values changed since the last time we read them.
    set(diffs, 
      (cyc0 != prev_cyc0) ||
      (cyc1 != prev_cyc1) ||
      (cyc2 != prev_cyc2) ||
      (cyc3 != prev_cyc3) ||
      (cyc4 != prev_cyc4) ||
      (cyc5 != prev_cyc5) ||
      (cyc6 != prev_cyc6) ||
      (cyc7 != prev_cyc7)
    );
    
    # Store the previous values.
    set(prev_cyc0, cyc0);
    set(prev_cyc1, cyc1);
    set(prev_cyc2, cyc2);
    set(prev_cyc3, cyc3);
    set(prev_cyc4, cyc4);
    set(prev_cyc5, cyc5);
    set(prev_cyc6, cyc6);
    set(prev_cyc7, cyc7);
    
    # Delay for 500 milliseconds between checks.
    delay_ms(500);
    
    printf(".");
    
  ));
  
  printf(" done.\n\n");
  
  # Do a performance counter dump for each context.
  set(cur, 0);
  set(total_cyc, 0);
  while (cur < count, (
    
    set(_CUR_CONTEXT, cur);
    SET_BANK;
    printf("\033[1mPerformance counters for context %d:\033[0m\n", cur);
    set(cyc, readWord(C_CYC));
    set(total_cyc, total_cyc + cyc);
    printf("            Active cycles = %u\n", cyc);
    printf("           Stalled cycles = %u\n", readWord(C_STALL));
    printf("   Committed bundle count = %u\n", readWord(C_BUN));
    printf(" Committed syllable count = %u\n", readWord(C_SYL));
    printf("      Committed NOP count = %u\n", readWord(C_NOP));
    printf("\n");
    
    set(cur, cur + 1);
  ));
  printf(" Sum of all active cycles = \033[1m%u\033[0m\n", total_cyc);
  printf(" (this is the total cycle count if contexts are never active at the same time)\n\n");
  
}



# This is evaluated before any rvd command is called.
all:_ALWAYS {
  SET_BANK;
}

# This is evaluated when "rvd break" is called.
all:_BREAK {
  write(DCRF, 0x09hh);
  PRINT_STATE;
}

# This is evaluated when "rvd step" is called.
all:_STEP {
  write(DCRF, 0x0Ahh);
  PRINT_STATE;
}
  
# This is evaluated when "rvd resume" is called.
all:_RESUME {
  write(DCRF, 0x0Chh);
}

# This is evaluated when "rvd release" is called.
all:_RELEASE {
  write(DCRF, 0x10hh);
}
  
# This is evaluated when "rvd reset" is called.
all:_RESET {
  write(DCRF, 0x09hh); # break
  set(reg, 0);
  while (reg < 64, (
    writeWord(CREG + 0x80 + (reg*4), 0);
    set(reg, reg + 1);
  ));
  write(DCRF, 0x80hh); # reset
}
  
# This is evaluated when "rvd reset break" is called.
all:_RESET_BREAK {
  write(DCRF, 0x89hh);
}
  
# This is evaluated when "rvd state" is called.
all:_STATE {
  PRINT_STATE;
}

