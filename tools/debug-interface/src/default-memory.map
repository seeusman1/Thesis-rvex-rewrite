#
# This file specifies the memory map for accessing the core through the debug
# interface. Each line consists of three parts: the context mask, the
# definition name and the value. The mask and definition name are separated by
# a colon, the value is enclosed by curly braces. Anything after a hash is
# ignored.
#
# -----------------------------------------------------------------------------
# Context mask
# -----------------------------------------------------------------------------
# rvd allows you to switch between multiple rvex contexts easily using the
# select command. Only the definitions in this file which contain the selected
# context in the mask will be evaluated. This allows you to specify different
# definitions for different contexts.
# 
# The context mask must be one of the following:
#  - "all": matches any context.
#  - <from>..<to>: range, matching any context within from and to inclusive.
#  - <context>: matches only the specified context.
#
# rvd supports up to 32 contexts, numbered from 0 to 31.
#
# -----------------------------------------------------------------------------
# Definition name and value
# -----------------------------------------------------------------------------
# Definitions in rvd can be used anywhere in place of an integer literal. They
# work kind of like #define in the C preprocessor, in that they are expanded
# when they are used, so definition order in this file does not matter. When
# used in expressions though, they behave as if there were parenthesis around
# the expansion compared to the C preprocessor.
#
# The value for a definition should be a valid expression. To get more
# information on how expressions work in rvd, run "rvd help expressions".
#

# Specifies the number of contexts. This defines what rvd will do when you run
# a command for all contexts. Should be defined for all contexts, there's no
# point in defining a different number for different contexts (obviously).
all:_NUM_CONTEXTS           { 4 }

# Control register base address.
all:CREG                    { 0xF0000000 }

# Coarse memory map for the control registers, hardcoded in core_ctrlRegs.vhd.
all:CREG_GLOB               { CREG + 0x000 }
all:CREG_GPREG              { CREG + 0x100 + (_CUR_CONTEXT * 0x400) }
all:CREG_CTXT               { CREG + 0x200 + (_CUR_CONTEXT * 0x400) }

# Control register mnemonics. These should match the values in
# core_ctrlRegs_pkg.vhd.
all:GSR                     { CREG_GLOB + 0x00 } # Global status register.
all:BUS_BANK                { CREG_GLOB + 0x03 } # Debug bus bank selection.
all:BCRR                    { CREG_GLOB + 0x04 } # Debug bus reconfiguration request.
all:CC                      { CREG_GLOB + 0x08 } # Current configuration.
all:AFF                     { CREG_GLOB + 0x0C } # Cache affinity.
all:CNT                     { CREG_GLOB + 0x10 } # Cycle counter.
all:CCR                     { CREG_CTXT + 0x00 } # Context control register.
all:TC                      { CREG_CTXT + 0x00 } # Trap cause (byte).
all:BR                      { CREG_CTXT + 0x01 } # Branch registers (byte).
all:CCRF                    { CREG_CTXT + 0x02 } # Context control register flags (short).
all:SCCR                    { CREG_CTXT + 0x04 } # Saved context control register.
all:SCCRF                   { CREG_CTXT + 0x06 } # Saved context control register flags (short).
all:LR                      { CREG_CTXT + 0x08 } # Link register.
all:PC                      { CREG_CTXT + 0x0C } # PC register.
all:TH                      { CREG_CTXT + 0x10 } # Trap handler.
all:PH                      { CREG_CTXT + 0x14 } # Panic handler.
all:TP                      { CREG_CTXT + 0x18 } # Trap point.
all:TA                      { CREG_CTXT + 0x1C } # Trap argument.
all:BRK0                    { CREG_CTXT + 0x20 } # Breakpoint 0.
all:BRK1                    { CREG_CTXT + 0x24 } # Breakpoint 1.
all:BRK2                    { CREG_CTXT + 0x28 } # Breakpoint 2.
all:BRK3                    { CREG_CTXT + 0x2C } # Breakpoint 3.
all:DCR                     { CREG_CTXT + 0x30 } # Debug control register 1.
all:DCRF                    { CREG_CTXT + 0x30 } # Debug control flags (byte).
all:DCRC                    { CREG_CTXT + 0x31 } # Break cause (byte).
all:DCRB                    { CREG_CTXT + 0x32 } # Breakpoint configuration (half).
all:DCR2                    { CREG_CTXT + 0x34 } # Debug control register 2.
all:RET                     { CREG_CTXT + 0x34 } # Program return value (byte).
all:_TRACE_CTRL             { CREG_CTXT + 0x37 } # Trace control register (byte).
all:CRR                     { CREG_CTXT + 0x38 } # Context reconfiguration request.
all:C_CYC                   { CREG_CTXT + 0x3C } # Non-idle cycle counter.
all:C_STALL                 { CREG_CTXT + 0x40 } # Non-idle stall counter.
all:C_BUN                   { CREG_CTXT + 0x44 } # Committed bundle counter.
all:C_SYL                   { CREG_CTXT + 0x48 } # Committed syllable counter.
all:C_NOP                   { CREG_CTXT + 0x4C } # Committed NOP counter.
all:SCRP                    { CREG_CTXT + 0x50 } # Scratch-pad register 1.
all:SCRP2                   { CREG_CTXT + 0x54 } # Scratch-pad register 2.
all:SCRP3                   { CREG_CTXT + 0x58 } # Scratch-pad register 3.
all:SCRP4                   { CREG_CTXT + 0x5C } # Scratch-pad register 4.

# This is called after a context change to set banking bits. Currently there
# are no banking bits, so this does nothing.
all:SET_BANK                { 0 }

all:PRINT_STATE { _STATE }

# Waits for completion of a program and then prints statistics. Should only be
# called using a single context.
all:WAIT_COMPLETE {
  
  printf("Waiting for program to terminate");
  
  # In case _NUM_CONTEXTS expands to something complicated, we'll want to
  # preload it here.
  set(count, _NUM_CONTEXTS);
  
  # Initialize prev_cycle things.
  set(prev_cyc0, 0);
  set(prev_cyc1, 0);
  set(prev_cyc2, 0);
  set(prev_cyc3, 0);
  set(prev_cyc4, 0);
  set(prev_cyc5, 0);
  set(prev_cyc6, 0);
  set(prev_cyc7, 0);
  
  # Wait for completion.
  set(diffs, 1);
  while (diffs, (
    
    # Load the current cycle counter values.
    if (count > 0, (set(_CUR_CONTEXT, 0); SET_BANK; set(cyc0, readWord(C_CYC))), set(cyc0, 0));
    if (count > 1, (set(_CUR_CONTEXT, 1); SET_BANK; set(cyc1, readWord(C_CYC))), set(cyc1, 0));
    if (count > 2, (set(_CUR_CONTEXT, 2); SET_BANK; set(cyc2, readWord(C_CYC))), set(cyc2, 0));
    if (count > 3, (set(_CUR_CONTEXT, 3); SET_BANK; set(cyc3, readWord(C_CYC))), set(cyc3, 0));
    if (count > 4, (set(_CUR_CONTEXT, 4); SET_BANK; set(cyc4, readWord(C_CYC))), set(cyc4, 0));
    if (count > 5, (set(_CUR_CONTEXT, 5); SET_BANK; set(cyc5, readWord(C_CYC))), set(cyc5, 0));
    if (count > 6, (set(_CUR_CONTEXT, 6); SET_BANK; set(cyc6, readWord(C_CYC))), set(cyc6, 0));
    if (count > 7, (set(_CUR_CONTEXT, 7); SET_BANK; set(cyc7, readWord(C_CYC))), set(cyc7, 0));
    
    # See if the cycle counter values changed since the last time we read them.
    set(diffs, 
      (cyc0 != prev_cyc0) ||
      (cyc1 != prev_cyc1) ||
      (cyc2 != prev_cyc2) ||
      (cyc3 != prev_cyc3) ||
      (cyc4 != prev_cyc4) ||
      (cyc5 != prev_cyc5) ||
      (cyc6 != prev_cyc6) ||
      (cyc7 != prev_cyc7)
    );
    
    # Store the previous values.
    set(prev_cyc0, cyc0);
    set(prev_cyc1, cyc1);
    set(prev_cyc2, cyc2);
    set(prev_cyc3, cyc3);
    set(prev_cyc4, cyc4);
    set(prev_cyc5, cyc5);
    set(prev_cyc6, cyc6);
    set(prev_cyc7, cyc7);
    
    # Delay for 500 milliseconds between checks.
    delay_ms(500);
    
    printf(".");
    
  ));
  
  printf(" done.\n\n");
  
  # Do a performance counter dump for each context.
  set(cur, 0);
  set(total_cyc, 0);
  while (cur < count, (
    
    set(_CUR_CONTEXT, cur);
    SET_BANK;
    printf("\033[1mPerformance counters for context %d:\033[0m\n", cur);
    set(cyc, readWord(C_CYC));
    set(total_cyc, total_cyc + cyc);
    printf("            Active cycles = %u\n", cyc);
    printf("           Stalled cycles = %u\n", readWord(C_STALL));
    printf("   Committed bundle count = %u\n", readWord(C_BUN));
    printf(" Committed syllable count = %u\n", readWord(C_SYL));
    printf("      Committed NOP count = %u\n", readWord(C_NOP));
    printf("\n");
    
    set(cur, cur + 1);
  ));
  printf(" Sum of all active cycles = \033[1m%u\033[0m\n", total_cyc);
  printf(" (this is the total cycle count if contexts are never active at the same time)\n\n");
  
}



# This is evaluated before any rvd command is called.
all:_ALWAYS {
  SET_BANK;
}

# This is evaluated when "rvd break" is called.
all:_BREAK {
  write(DCRF, 0x09hh);
  PRINT_STATE;
}

# This is evaluated when "rvd step" is called.
all:_STEP {
  write(DCRF, 0x0Ahh);
  PRINT_STATE;
}
  
# This is evaluated when "rvd resume" is called.
all:_RESUME {
  write(DCRF, 0x0Chh);
}

# This is evaluated when "rvd release" is called.
all:_RELEASE {
  write(DCRF, 0x10hh);
}
  
# This is evaluated when "rvd reset" is called.
all:_RESET {
  write(DCRF, 0x09hh); # break
  set(reg, 0);
  while (reg < 64, (
    writeWord(CREG_GPREG + (reg*4), 0);
    set(reg, reg + 1);
  ));
  write(DCRF, 0x80hh); # reset
}
  
# This is evaluated when "rvd reset break" is called.
all:_RESET_BREAK {
  write(DCRF, 0x89hh);
}

# This is evaluated when "rvd gdb" waits for a breakpoint.
all:_WAIT {
  set(retval, 0x202);
  set(d, readWord(DCR));
  while (!(d & 0x01000000), (
    delay_ms(250);
    set(d, readWord(DCR));
  ));
  
  if (d & 0x80000000, (
    # STOP instruction.
    set(retval, readByte(RET));
  ), (
    # Debug trap.
    set(d, (d >> 16) & 0xFF);
    if (d == 0xFA, (
      # Software breakpoint.
      set(retval, 0x200);
    ));
    if (d == 0xFB, (
      # Single step.
      set(retval, 0x201);
    ));
    if (d >= 0xFC, (
      # Hardware breakpoint.
      set(retval, 0x100 + (d - 0xFC));
    ));
  ));
  retval
}

# This is evaluated when "rvd state" is called.
all:_STATE {
  
  printf("Dumping state for context %d...\n\n", _CUR_CONTEXT);
  
  SET_BANK;

  # Core running or stopped
  set (val, readByte(DCR));
  if (val&0x1,
    (printf("\033[1mCore stopped\033[0m\n");),
    (printf("\033[1mCore running\033[0m\n");)
  );
  printf("\n");
  
  # Special registers
  printf("\033[1mSpecial regs:\033[0m\n");
  printf("   PC = 0x%08X\n", readWord(PC));
  printf(" l0.0 = 0x%08X\n\n", readWord(LR));
  
  # General purpose registers
  printf("\033[1mGeneral purpose regs:\033[0m\n");
  preload(CREG_GPREG, 256);
  set(reg, 0);
  while (reg < 64, (
    set(val, readWordPreload(CREG_GPREG + (reg*4)));
    if (val, (
      printf("\033[1;32m");
    ));
    printf("r0.%.2d = 0x%08X  \033[0m", reg, val);
    set(reg, reg + 1);
    if (!(reg & 3), (
      printf("\n");
    ));
  ));
  printf("\n");
  
  # Branch registers
  printf("\033[1mBranch regs:\033[0m\n");
  set(val, readByte(BR));
  set(reg, 0);
  while (reg < 8, (
    if (val & (1 << reg), (
      printf("\033[1;32m b0.%d = true        \033[0m", reg);
    ), (
      printf(" b0.%d = false       \033[0m", reg);
    ));
    
    set(reg, reg + 1);
    if (!(reg & 3), (
      printf("\n");
    ));
  ));
  printf("\n");
  
  # Performance counters
  printf("\033[1mPerformance counters:\033[0m\n");
  printf("            Active cycles = %u\n", readWord(C_CYC));
  printf("           Stalled cycles = %u\n", readWord(C_STALL));
  printf("   Committed bundle count = %u\n", readWord(C_BUN));
  printf(" Committed syllable count = %u\n", readWord(C_SYL));
  printf("      Committed NOP count = %u\n", readWord(C_NOP));
  printf("\n");
  
  # Trap registers
  printf("\033[1mTrap registers:\033[0m\n");
  printf("    Trap cause = %u\n", readByte(TC));
  printf("    Trap point = 0x%x\n", readWord(TP));
  printf(" Trap argument = 0x%x\n", readWord(TA));
  printf("\n");

}

# Convert a core/gdb address to a debug bus address.
all:_GDB_ADDR_R { _GDB_ADDR }
all:_GDB_ADDR_W { _GDB_ADDR }

# Return the number of registers which gdb is aware of.
all:_GDB_REG_NUM { 81 }

# Read gdb registers.
all:_GDB_REG_PRE { preload(CREG_GPREG, 0x120) }
all:_GDB_REG_R {
  prioritize (
    _GDB_REG_INDEX < 64,  readWordPreload(CREG_GPREG + (_GDB_REG_INDEX*4)),
    _GDB_REG_INDEX < 72,  (readBytePreload(BR) & (1hh << (_GDB_REG_INDEX - 64))) != 0,
    _GDB_REG_INDEX == 72, readWordPreload(LR),
    _GDB_REG_INDEX == 73, readWordPreload(PC),
    _GDB_REG_INDEX == 74, readHalfPreload(CCRF),
    _GDB_REG_INDEX == 75, readHalfPreload(SCCRF),
    _GDB_REG_INDEX == 76, readBytePreload(TC),
    _GDB_REG_INDEX == 77, readWordPreload(TP),
    _GDB_REG_INDEX == 78, readWordPreload(TA),
    _GDB_REG_INDEX == 79, readWordPreload(TH),
    _GDB_REG_INDEX == 80, readWordPreload(PH)
  )
}

# Write gdb registers.
all:_GDB_REG_W {
  prioritize (
    _GDB_REG_INDEX < 64,  writeWord(CREG_GPREG + (_GDB_REG_INDEX*4), _GDB_REG_VALUE),
    _GDB_REG_INDEX < 72,  (
      set(brVal, readByte(BR));
      set(brMask, 1 << (_GDB_REG_INDEX - 64));
      set(brVal, (brVal & (~brMask)));
      if (_GDB_REG_VALUE, (
        set(brVal, brVal | brMask);
      ));
      writeByte(BR, brVal);
    ),
    _GDB_REG_INDEX == 72, writeWord(LR, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 73, writeWord(PC, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 74, writeHalf(CCRF, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 75, writeHalf(SCCRF, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 76, writeByte(TC, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 77, writeWord(TP, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 78, writeWord(TA, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 79, writeWord(TH, _GDB_REG_VALUE),
    _GDB_REG_INDEX == 80, writeWord(PH, _GDB_REG_VALUE)
  )
}

# Soft breakpoint instruction: trap r0.0, 0xFA. Copy the stop bit from the
# syllable which is being replaced.
all:_GDB_SOFTBRK {
  0x908003E8w | (_GDB_SOFTBRK_SYL & 0x00000002w)
}

# Sets or deletes a breakpoint or watchpoint.
all:_GDB_HARDBRK {
  prioritize (
    
    # Fail if index >= 4.
    _GDB_HARDBRK_INDEX >= 4, 0,
    
    # Read-only watchpoints are not supported.
    _GDB_HARDBRK_TYPE == 3, 0,
    
    # Otherwise:
    1, (
      
      # Write the breakpoint address register.
      prioritize(
        _GDB_HARDBRK_INDEX == 0, writeWord(BRK0, _GDB_HARDBRK_ADDR),
        _GDB_HARDBRK_INDEX == 1, writeWord(BRK1, _GDB_HARDBRK_ADDR),
        _GDB_HARDBRK_INDEX == 2, writeWord(BRK2, _GDB_HARDBRK_ADDR),
        _GDB_HARDBRK_INDEX == 3, writeWord(BRK3, _GDB_HARDBRK_ADDR)
      );
      
      # Read the current breakpoint configuration register.
      set(cfg, readHalf(DCRB));
      
      # Clear the configuration nibble for the selected breakpoint.
      set(cfg, cfg & (~(0xF << (4 * _GDB_HARDBRK_INDEX))));
      
      # Load the new configuration for the selected breakpoint. The gdb
      # convention for this happens to match ours, except for that type 4 is
      # type 3 for us and that gdb type 3 is not supported.
      set(cfg, cfg | (if(_GDB_HARDBRK_TYPE==4,3,_GDB_HARDBRK_TYPE) << (4 * _GDB_HARDBRK_INDEX)));
      
      # Write the new configuration.
      writeHalf(DCRB, cfg);
      
      # Return success.
      1
    )
  )
}
