%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                         INSTRUCTION DECODING TABLE                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This file describes the instructions encodings of the processor in a common
% format. Since the documentation is intended to be compiled to LaTeX code, it
% somehow made sense to use LaTeX syntax for the definition language. I'm sorry.
% The file is interpreted by python though, not by LaTeX. Don't try to run this
% through LaTeX directly...
%
% The following LaTeX-like commands are interpreted by python to define the
% opcode table. They must be the only thing on a certain line aside from (maybe)
% comments, otherwise they are interpreted as LaTeX documentation.
%
% \section{name} - starts a group of instructions in the documentation for
%    readability. Any textual lines between \group and \syllable is interpreted
%    as LaTeX documentation for the group.
%
% \syllable{opcode}{mnemonic}{syntax} - starts a syllable definition. The opcode
%    should be a 9-bit binary string with dashes for don't cares, mapping to
%    syllable bit 31..23. The value of the LSB is not really part of the opcode,
%    but defines whether the instruction can be used with only a register for
%    the second operand (0), only an immediate for the second operand (1), or
%    both (-). In VHDL terms, this describes the contents of the "valid" field.
%    The mnemonic is the name of the instruction. It will be made lowercase for
%    the assembler syntax and uppercase for the documentation (when used without
%    context). Finally, the syntax describes the assembler syntax of the
%    syllable. In this, the following LaTeX-like commands may be used. The {}
%    may be omitted.
%
%      .-------.--------.--------.-----------------------------.
%      | Cmd   | Docs   | VHDL   | Encoded by bitfield         |
%      |-------|--------|--------|-----------------------------|
%      | \rd{} | $r0.d  | r#.%r1 | syl(22..17)                 |
%      |-------|--------|--------|-----------------------------|
%      | \rx{} | $r0.x  | r#.%r2 | syl(16..11)                 |
%      |-------|--------|--------|-----------------------------|
%      | \ry{} | $r0.y  | r#.%r3 | syl(10..5)  for imm_sw 0    |
%      |       | imm    | %ih    | syl(10..2)  for imm_sw 1    |
%      |-------|--------|--------|-----------------------------|
%      | \rs{} | $r0.1  | r#.1   | -                           |
%      |-------|--------|--------|-----------------------------|
%      | \bd{} | $b0.bd | b#.%b2 | syl(19..17) for brFmt 0     |
%      |       |        | b#.%b3 | syl(4..2)   for brFmt 1     |
%      |-------|--------|--------|-----------------------------|
%      | \bs{} | $b0.bs | b#.%b3 | syl(4..2)   for brFmt 0     |
%      |       |        | b#.%b1 | syl(26..24) for brFmt 1     |
%      |-------|--------|--------|-----------------------------|
%      | \lr{} | $l0.0  | l#.0   | -                           |
%      |-------|--------|--------|-----------------------------|
%      | \of{} | offs   | %bt    | syl(23..5)                  |
%      |-------|--------|--------|-----------------------------|
%      | \sa{} |stackadj| %bi    | syl(23..5)                  |
%      |-------|--------|--------|-----------------------------|
%      | \lt{} | tgt    | %i1    | syl(27..25)                 |
%      |-------|--------|--------|-----------------------------|
%      | \li{} | imm    | %i2    | syl(24..2)                  |
%      '-------'--------'--------'-----------------------------'
%
%    Any textual lines between \syllable and \group or the next \syllable is
%    interpreted as LaTeX documentation for the syllable. These text sections
%    may also use the commands in the table above inline, but the {} may NOT
%    be omitted here.
%
% \class{x} - specifies the resource class. x should be ALU, MEM, MUL, BR or
%    LIMMH.
%
% \datapath{member}{value}   - specifies a value for the datapath decoding table.
% \alu{member}{value}        - specifies a value for the ALU decoding table.
% \branch{member}{value}     - specifies a value for the branch unit decoding table.
% \memory{member}{value}     - specifies a value for the memory unit decoding table.
% \multiplier{member}{value} - specifies a value for the multiplier decoding table.
%    Which members need to be specified and what values they can take depends
%    first and foremost the VHDL code (core_opcode*_pkg.vhd). This is also their
%    primary documentation source.
%
% \noasm{} - attribute which specifies that this syllable cannot be assembled.
%    Used for LIMMH instructions. This will disable rendering the syntax in the
%    documentation.
% 
% All commands other than \group and \syllable specify attributes for the
% syllables. These are used to describe the characteristics and functionality
% of the instructions. How they do this depends on where they are written with
% respect to the \group and \syllable commands:
%
%  - Attributes specified before the first \group command are interpreted as
%    the default. All groups will inherit these attributes.
%
%  - Attributes specified between \group and the first \syllable in the group
%    determine the group defaults, overriding the global defaults. All syllables
%    within the group will inherit these attributes.
%
%
%===============================================================================
% Default attributes
%===============================================================================

% Default class is ALU.
\class{ALU}

% Refer to the datapath schematic diagram in core_opcodeDatapath_pkg.vhd for
% documentation of the following attributes.
\datapath{funcSel}{ALU}
\datapath{gpRegWE}{'0'}
\datapath{linkWE}{'0'}
\datapath{brRegWE}{'0'}
\datapath{allBrRegsWE}{'0'}
\datapath{stackOp}{'0'}
\datapath{op1LinkReg}{'0'}
\datapath{op3LinkReg}{'0'}
\datapath{op3BranchRegs}{'0'}
\datapath{brFmt}{'0'}
\datapath{isLIMMH}{'0'}
\datapath{isTrap}{'0'}
\datapath{isNOP}{'1'}

% Refer to the structure and type declarations in core_opcodeAlu_pkg.vhd for
% documentation of the following attributes.
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{ZERO}
\alu{opBrMux}{PASS}
\alu{divs}{'0'}
\alu{unsignedOp}{'0'}
\alu{bitwiseOp}{BITW_OR}
\alu{shiftLeft}{'0'}
\alu{compare}{'0'}
\alu{intResultMux}{BITWISE}
\alu{brResultMux}{PASS}

% Refer to the structure and type declarations in core_opcodeBranch_pkg.vhd for
% documentation of the following attributes.
\branch{isBranchInstruction}{'0'}
\branch{branchIfTrue}{'0'}
\branch{branchIfFalse}{'0'}
\branch{branchToLink}{'0'}
\branch{link}{'0'}
\branch{stop}{'0'}
\branch{RFI}{'0'}

% Refer to the structure and type declarations in core_opcodeMemory_pkg.vhd for
% documentation of the following attributes.
\memory{isMemoryInstruction}{'0'}
\memory{readEnable}{'0'}
\memory{writeEnable}{'0'}
\memory{unsignedOp}{'0'}
\memory{accessSizeBLog2}{ACCESS_SIZE_WORD}

% Refer to the structure and type declarations in core_opcodeMultiplier_pkg.vhd
% for documentation of the following attributes.
\multiplier{isMultiplyInstruction}{'0'}
\multiplier{op1sel}{LOW_HALF}
\multiplier{op1unsigned}{'0'}
\multiplier{op2sel}{LOW_HALF}
\multiplier{op2unsigned}{'0'}
\multiplier{resultSel}{PASS}

%===============================================================================
\section{ALU arithmetic instructions}
%===============================================================================
\datapath{gpRegWE}{'1'}
\datapath{isNOP}{'0'}
\alu{intResultMux}{ADDER}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}

\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

The \rvex{} ALU has a 32-bit adder for arithmetic. Some exotic instructions are
available to make efficient multiplications by small constants and to speed up
software divisions.

%-------------------------------------------------------------------------------
\syllable{01100010-}{ADD}{\rd = \rx, \ry}
Performs a 32-bit addition. Notice that \insn{ADD} instructions may be used as
move or load immediate operations when \code{x} is set to 0. While the \insn{OR}
instruction is often used instead, there is no functional difference between the
two when used inthis way.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx + \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101011-}{SH1ADD}{\rd = \rx, \ry}
\alu{op1Mux}{SHL1}
Performs a 32 bit addition. \code{\rx} is first left-shifted by one.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx << 1) + \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101100-}{SH2ADD}{\rd = \rx, \ry}
\alu{op1Mux}{SHL2}
Performs a 32 bit addition. \code{\rx} is first left-shifted by two.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx << 2) + \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101101-}{SH3ADD}{\rd = \rx, \ry}
\alu{op1Mux}{SHL3}
Performs a 32 bit addition. \code{\rx} is first left-shifted by three.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx << 3) + \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101110-}{SH4ADD}{\rd = \rx, \ry}
\alu{op1Mux}{SHL4}
Performs a 32 bit addition. \code{\rx} is first left-shifted by four.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx << 4) + \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00011010-}{SUB}{\rd = \ry, \rx}
\alu{op1Mux}{EXTEND32INV}
\alu{opBrMux}{TRUE}
Performs a 32-bit subtraction. Note that, unlike all other instructions, the
immediate must be specified first. This allows \insn{SUB} to be used to subtract
a register from an immediate.

Notice that \insn{SUB} reduces to two's complement negation when \code{x} or
\code{imm} equal zero.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \ry + \rx;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01111---0}{ADDCG}{\rd, \bd = \bs, \rx, \ry}
\datapath{brFmt}{'1'}
\datapath{brRegWE}{'1'}
\alu{opBrMux}{PASS}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CARRY_OUT}
Primitive for additions of integers wider than 32 bits. Addition is performed by
first setting a scratch branch register to false using \insn{NEQ} for the carry
input. Then \insn{ADDCG} can be used to add up words together one by one with
increasing significance, using the scratch branch register for the carry chain.

Subtractions can be performed by setting the carry input to 1 using \insn{EQ}
and ones-complementing one of the inputs using \insn{XOR}.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
long long tmp = \rx + \ry + (\bs ? 1 : 0);
\rd = (int)tmp;
\bd = (tmp & 0x100000000) != 0;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01110---0}{DIVS}{\rd, \bd = \bs, \rx, \ry}
\datapath{brFmt}{'1'}
\datapath{brRegWE}{'1'}
\alu{op1Mux}{SHL1}
\alu{opBrMux}{PASS}
\alu{divs}{'1'}
\alu{brResultMux}{DIVS}
Primitive for integer divisions, used in conjunction with \insn{ADDCG}.
\todo[inline]{Figure out how divisions work so it can be explained here.}

Notice that \insn{DIVS} reduces to rotate left by one through a branch register
when \code{y} is zero. This may be used for for shift left by one
operations on integers wider than 32 bits.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
int tmp = (\rx << 1) | (\bs ? 1 : 0);
bool flag = (\rx & 0x80000000) != 0;
\rd = flag ? (tmp + \ry) : (tmp - \ry);
\bd = flag;
\end{lstlisting}

%===============================================================================
\section{ALU barrel shifter instructions}
%===============================================================================
\datapath{gpRegWE}{'1'}
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}
\alu{intResultMux}{SHIFTER}

\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

The \rvex{} ALU includes a barrel shifter. It should be noted that the shift
amount input to the barrel shifter is 8-bit unsigned, not 32-bit as one might
expect. That is, the upper 24 bits of the shift amount are discarded, and for
instance a left shift by a negative amount will \emph{not} simply result in a
right shift.

%-------------------------------------------------------------------------------
\syllable{01101111-}{SHL}{\rd = \rx, \ry}
\alu{unsignedOp}{'1'}
\alu{shiftLeft}{'1'}
Performs a left-shift operation. Zeros are shifted in from the right.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx << \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00011000-}{SHR}{\rd = \rx, \ry}
Performs a signed right-shift operation. That is, the sign bit of \code{\rx} is
shifted in from the left.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx >> \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00011001-}{SHRU}{\rd = \rx, \ry}
\alu{unsignedOp}{'1'}
Performs an unsigned right-shift operation. That is, zeros are shifted in from
the left.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned int)\rx >> \ry;
\end{lstlisting}

%===============================================================================
\section{ALU bitwise instructions}
%===============================================================================
\datapath{gpRegWE}{'1'}
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{intResultMux}{BITWISE}

\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{opBrMux}{FALSE} % Only because legacy decoding did this.

The \rvex{} ALU supports a subset of bitwise operations in a single cycle.

%-------------------------------------------------------------------------------
\syllable{01100011-}{AND}{\rd = \rx, \ry}
\alu{bitwiseOp}{BITW_AND}
Performs a bitwise \code{AND} operation.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx & \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01100100-}{ANDC}{\rd = \rx, \ry}
\alu{op1Mux}{EXTEND32INV}
\alu{bitwiseOp}{BITW_AND}
Performs a bitwise \code{AND} operation, with the first operand one's
complemented.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = ~\rx & \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101001-}{OR}{\rd = \rx, \ry}
\alu{bitwiseOp}{BITW_OR}
Performs a bitwise \code{OR} operation. Notice that \insn{OR} instructions
reduce to move or load immediate operations when \code{x} is set to 0.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx | \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101010-}{ORC}{\rd = \rx, \ry}
\alu{op1Mux}{EXTEND32INV}
\alu{bitwiseOp}{BITW_OR}
Performs a bitwise \code{OR} operation, with the first operand one's
complemented. Notice that \insn{ORC} instructions reduce to one's complement
when \code{y} or \code{imm} is set to 0.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = ~\rx | \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00011111-}{XOR}{\rd = \rx, \ry}
\alu{bitwiseOp}{BITW_XOR}
Performs a bitwise \code{XOR} operation.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx ^ \ry;
\end{lstlisting}

%===============================================================================
\section{ALU single-bit instructions}
%===============================================================================
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}

\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

The \rvex{} ALU supports several bitfield operations in a single cycle. Note
that the bit selection logic follows the same rules as the shift amount in the
barrel shifter. That is, only the least significant byte of the bit selection
operand is used to select the bit, the rest is ignored.

%-------------------------------------------------------------------------------
\syllable{00101100-}{SBIT}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{opBrMux}{TRUE}
\alu{bitwiseOp}{SET_BIT}
\alu{intResultMux}{BITWISE}
Sets a given bit in a 32-bit integer.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx | (1 << \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00101101-}{SBITF}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{opBrMux}{FALSE}
\alu{bitwiseOp}{SET_BIT}
\alu{intResultMux}{BITWISE}
Clears a given bit in a 32-bit integer.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx & ~(1 << \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011100-}{TBIT}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{intResultMux}{BOOL}
\alu{brResultMux}{TBIT}
Copies a given bit to an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx & (1 << \ry)) != 0;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011101-}{TBIT}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{intResultMux}{BOOL}
\alu{brResultMux}{TBIT}
Copies a given bit to a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = (\rx & (1 << \ry)) != 0;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011110-}{TBITF}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{intResultMux}{BOOL}
\alu{brResultMux}{TBITF}
Copies the complement of a given bit to an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx & (1 << \ry)) == 0;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011111-}{TBITF}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{intResultMux}{BOOL}
\alu{brResultMux}{TBITF}
Copies the complement of a given bit to a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = (\rx & (1 << \ry)) == 0;
\end{lstlisting}

%===============================================================================
\section{ALU boolean instructions}
%===============================================================================
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{intResultMux}{BOOL}

\alu{opBrMux}{FALSE} % Only because legacy decoding did this.
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

As well as supporting many bitwise operations, the \rvex{} ALU also supports
some boolean operations in a single cycle. The boolean operations are defined in
the same way as C boolean operations are defined. That is, the value 0
represents false, and any other value represents true.

%-------------------------------------------------------------------------------
\syllable{01011010-}{ANDL}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{LOGIC_AND}
Performs a boolean \code{AND} operation and stores the result in an integer
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx && \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011011-}{ANDL}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{LOGIC_AND}
Performs a boolean \code{AND} operation and stores the result in a branch
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx && \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011000-}{ORL}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{LOGIC_OR}
Performs a boolean \code{OR} operation and stores the result in an integer
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx || \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01011001-}{ORL}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{LOGIC_OR}
Performs a boolean \code{OR} operation and stores the result in a branch
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx || \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010100-}{NANDL}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{LOGIC_NAND}
Performs a boolean \code{NAND} operation and stores the result in an integer
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = !(\rx && \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010101-}{NANDL}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{LOGIC_NAND}
Performs a boolean \code{NAND} operation and stores the result in a branch
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = !(\rx && \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010110-}{NORL}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{LOGIC_NOR}
Performs a boolean \code{NOR} operation and stores the result in an integer
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = !(\rx || \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010111-}{NORL}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{LOGIC_NOR}
Performs a boolean \code{NOR} operation and stores the result in a branch
register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = !(\rx || \ry);
\end{lstlisting}

%===============================================================================
\section{ALU compare instructions}
%===============================================================================
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32INV}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{TRUE}
\alu{compare}{'1'}
\alu{intResultMux}{BOOL}

\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

The \rvex{} ALU supports all 32-bit possible integer comparison operations in a
single cycle. The immediate version of \insn{CMPNE} which writes to a branch
register is used to load an immediate branch register.

%-------------------------------------------------------------------------------
\syllable{01000000-}{CMPEQ}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{CMP_EQ}
Determines whether the first operand is equal to the second operand and stores
the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx == \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000001-}{CMPEQ}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{CMP_EQ}
Determines whether the first operand is equal to the second operand and stores
the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx == \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000010-}{CMPGE}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{CMP_GE}
Determines whether the first operand is greater than or equal to the second
operand and stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx >= \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000011-}{CMPGE}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{CMP_GE}
Determines whether the first operand is greater than or equal to the second
operand and stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx >= \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000100-}{CMPGEU}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_GE}
Determines whether the first operand is greater than or equal to the second
operand in unsigned arithmetic and stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned int)\rx >= (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000101-}{CMPGEU}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_GE}
Determines whether the first operand is greater than or equal to the second
operand in unsigned arithmetic and stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = (unsigned int)\rx >= (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000110-}{CMPGT}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{CMP_GT}
Determines whether the first operand is greater than the second operand and
stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx > \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01000111-}{CMPGT}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{CMP_GT}
Determines whether the first operand is greater than the second operand and
stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx > \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001000-}{CMPGTU}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_GT}
Determines whether the first operand is greater than the second operand in
unsigned arithmetic and stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned int)\rx > (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001001-}{CMPGTU}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_GT}
Determines whether the first operand is greater than the second operand in
unsigned arithmetic and stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = (unsigned int)\rx > (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001010-}{CMPLE}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{CMP_LE}
Determines whether the first operand is less than or equal to the second
operand and stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx <= \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001011-}{CMPLE}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{CMP_LE}
Determines whether the first operand is less than or equal to the second
operand and stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx <= \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001100-}{CMPLEU}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_LE}
Determines whether the first operand is less than or equal to the second
operand in unsigned arithmetic and stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned int)\rx <= (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001101-}{CMPLEU}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_LE}
Determines whether the first operand is less than or equal to the second
operand in unsigned arithmetic and stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = (unsigned int)\rx <= (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001110-}{CMPLT}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{CMP_LT}
Determines whether the first operand is less than the second operand and stores
the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx <= \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01001111-}{CMPLT}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{CMP_LT}
Determines whether the first operand is less than the second operand and stores
the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx <= \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010000-}{CMPLTU}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_LT}
Determines whether the first operand is less than the second operand in unsigned
arithmetic and stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned int)\rx <= (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010001-}{CMPLTU}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_LT}
Determines whether the first operand is less than the second operand in unsigned
arithmetic and stores the result in a branch register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = (unsigned int)\rx <= (unsigned int)\ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010010-}{CMPNE}{\rd = \rx, \ry}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{brResultMux}{CMP_NE}
Determines whether the first operand is not equal to the second operand and
stores the result in an integer register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \rx != \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01010011-}{CMPNE}{\bd = \rx, \ry}
\datapath{brRegWE}{'1'}
\alu{brResultMux}{CMP_NE}
Determines whether the first operand is not equal to the second operand and
stores the result in a branch register.

Notice that the immediate version of \insn{CMPNE} reduces to a load immediate
operation for branch registers when \code{x} is zero.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\bd = \rx != \ry;
\end{lstlisting}

%===============================================================================
\section{ALU selection instructions}
%===============================================================================
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'}
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32INV}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{TRUE}
\alu{intResultMux}{OP_SEL}

\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

The \rvex{} ALU has single-cycle instructions for conditional moves and
computation of the minimum and maximum of two integer values.

%-------------------------------------------------------------------------------
\syllable{00111----}{SLCT}{\rd = \bs, \rx, \ry}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{PASS}
Conditional move.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \bs ? \rx : \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00110----}{SLCTF}{\rd = \bs, \rx, \ry}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{INVERT}
Conditional move, with operands swapped with respect to \insn{SLCT}.

Notice that the immediate version of \insn{SLCTF} reduces to a move from a
branch register to an integer register when \code{x} is 0 and \code{y} is 1.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \bs ? \ry : \rx;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01100101-}{MAX}{\rd = \rx, \ry}
\alu{compare}{'1'}
\alu{brResultMux}{CMP_GE}
Computes maximum of the input operands using signed arithmetic.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx >= \ry) : \rx ? \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01100110-}{MAXU}{\rd = \rx, \ry}
\alu{compare}{'1'}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_GE}
Computes maximum of the input operands using unsigned arithmetic.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = ((unsigned int)\rx >= (unsigned int)\ry) : \rx ? \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01100111-}{MIN}{\rd = \rx, \ry}
\alu{compare}{'1'}
\alu{brResultMux}{CMP_LE}
Computes minimum of the input operands using signed arithmetic.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (\rx <= \ry) : \rx ? \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{01101000-}{MINU}{\rd = \rx, \ry}
\alu{compare}{'1'}
\alu{unsignedOp}{'1'}
\alu{brResultMux}{CMP_LE}
Computes minimum of the input operands using unsigned arithmetic.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = ((unsigned int)\rx <= (unsigned int)\ry) : \rx ? \ry;
\end{lstlisting}

%===============================================================================
\section{ALU type conversion instructions}
%===============================================================================
\datapath{gpRegWE}{'1'}
\datapath{isNOP}{'0'}
\alu{op2Mux}{ZERO}
\alu{intResultMux}{ADDER}

\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{opBrMux}{FALSE} % Only because legacy decoding did this.
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

The \rvex{} ALU is capable of supporting typecasts from 32-bit integers to
16-bit and 8-bit integers in a single cycle.

%-------------------------------------------------------------------------------
\syllable{000110110}{SXTB}{\rd = \rx}
\alu{op1Mux}{EXTEND8}
Performs sign extension for an 8-bit value.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (char)\rx;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000111000}{SXTH}{\rd = \rx}
\alu{op1Mux}{EXTEND16}
Performs sign extension for a 16-bit value.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (short)\rx;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000111010}{ZXTB}{\rd = \rx}
\alu{op1Mux}{EXTEND8}
\alu{unsignedOp}{'1'}
Performs zero extension for an 8-bit value.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned char)\rx;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000111100}{ZXTH}{\rd = \rx}
\alu{op1Mux}{EXTEND16}
\alu{unsignedOp}{'1'}
Performs zero extension for a 16-bit value.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = (unsigned short)\rx;
\end{lstlisting}

%===============================================================================
\section{ALU miscellaneous instructions}
%===============================================================================
\datapath{isNOP}{'0'}

%-------------------------------------------------------------------------------
\syllable{01100000-}{NOP}{}
\datapath{isNOP}{'1'}
Performs no operation.

%-------------------------------------------------------------------------------
\syllable{100100010}{CLZ}{\rd = \rx}
\datapath{gpRegWE}{'1'}
\datapath{brFmt}{'1'} % Only because legacy decoding did this.
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE} % Only because legacy decoding did this.
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.
\alu{intResultMux}{CLZ}
This operations counts the number of leading zeros in the operand. That is, the
value 0x80000000 returns 0 and the value 0 returns 32.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
unsigned int in = \rx;
int out = 32;
while (in) {
  in >>= 1;
  out--;
}
\rd = out;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00001011-}{MOVTL}{\lr = \ry}
\datapath{linkWE}{'1'}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}
\alu{intResultMux}{OP_SEL}
Copies a general purpose register or immediate to the link register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\lr = \ry;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000011000}{MOVFL}{\rd = \lr}
\datapath{gpRegWE}{'1'}
\datapath{op1LinkReg}{'1'}
\alu{op1Mux}{EXTEND32},
\alu{op2Mux}{ZERO},
\alu{bitwiseOp}{BITW_OR},
\alu{intResultMux}{BITWISE},
Copies the link register to a general purpose register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = \lr;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{10010000-}{TRAP}{\rx, \ry}
\datapath{isTrap}{'1'}
Software trap. The first parameter is the trap argument, while the second
parameter is the trap cause byte.

%===============================================================================
\section{Multiply instructions}
%===============================================================================
\class{MUL}
\datapath{funcSel}{MUL}
\datapath{gpRegWE}{'1'}
\datapath{isNOP}{'0'}
\multiplier{isMultiplyInstruction}{'1'}

\rvex{} pipelanes may be design-time configured to contain a multiplication
unit. This unit supports 16x16 and 16x32 multiplications.

In the default pipeline configuration, these instructions are pipelined by
two cycles. That is, the result of a multiply instruction is not available yet
in the subsequent instruction.

\todo[inline]{Properly document the multiply instructions. This is a bit of a
pain due to the fact that they make no sense to me at all.}

%-------------------------------------------------------------------------------
\syllable{00000000-}{MPYLL}{\rd = \rx, \ry}
\multiplier{op1sel}{LOW_HALF}
\multiplier{op2sel}{LOW_HALF}
\multiplier{resultSel}{PASS}
Multiply signed low 16 x low 16 bits.

%-------------------------------------------------------------------------------
\syllable{00000001-}{MPYLLU}{\rd = \rx, \ry}
\multiplier{op1sel}{LOW_HALF}
\multiplier{op1unsigned}{'1'}
\multiplier{op2sel}{LOW_HALF}
\multiplier{op2unsigned}{'1'}
\multiplier{resultSel}{PASS}
Multiply unsigned low 16 x low 16 bits.

%-------------------------------------------------------------------------------
\syllable{00000010-}{MPYLH}{\rd = \rx, \ry}
\multiplier{op1sel}{LOW_HALF}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{resultSel}{PASS}
Multiply signed low 16 (s1) x high 16 (s2) bits.

%-------------------------------------------------------------------------------
\syllable{00000011-}{MPYLHU}{\rd = \rx, \ry}
\multiplier{op1sel}{LOW_HALF}
\multiplier{op1unsigned}{'1'}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{op2unsigned}{'1'}
\multiplier{resultSel}{PASS}
Multiply unsigned low 16 (s1) x high 16 (s2) bits.

%-------------------------------------------------------------------------------
\syllable{00000100-}{MPYHH}{\rd = \rx, \ry}
\multiplier{op1sel}{HIGH_HALF}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{resultSel}{PASS}
Multiply signed high 16 x high 16 bits.

%-------------------------------------------------------------------------------
\syllable{00000101-}{MPYHHU}{\rd = \rx, \ry}
\multiplier{op1sel}{HIGH_HALF}
\multiplier{op1unsigned}{'1'}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{op2unsigned}{'1'}
\multiplier{resultSel}{PASS}
Multiply unsigned high 16 x high 16 bits.

%-------------------------------------------------------------------------------
\syllable{00000110-}{MPYL}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op2sel}{LOW_HALF}
\multiplier{resultSel}{PASS}
Multiply signed low 16 (s2) x 32 (s1) bits.

%-------------------------------------------------------------------------------
\syllable{00000111-}{MPYLU}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op1unsigned}{'1'}
\multiplier{op2sel}{LOW_HALF}
\multiplier{op2unsigned}{'1'}
\multiplier{resultSel}{PASS}
Multiply unsigned low 16 (s2) x 32 (s1) bits.

%-------------------------------------------------------------------------------
\syllable{00001000-}{MPYH}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{resultSel}{PASS}
Multiply signed high 16 (s2) x 32 (s1) bits.

%-------------------------------------------------------------------------------
\syllable{00001001-}{MPYHU}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op1unsigned}{'1'}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{op2unsigned}{'1'}
\multiplier{resultSel}{PASS}
Multiply unsigned high 16 (s2) x 32 (s1) bits.

%-------------------------------------------------------------------------------
\syllable{00001010-}{MPYHS}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{resultSel}{SHL16}
Multiply signed high 16 (s2) x 32 (s1) bits, shift left 16.

%-------------------------------------------------------------------------------
\syllable{10010010-}{MPYLHUS}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op2sel}{LOW_HALF}
\multiplier{op2unsigned}{'1'}
\multiplier{resultSel}{SHR32}
Multiply unsigned low 16 (s2) x signed 32 (s1) bits, shift right 32.

%-------------------------------------------------------------------------------
\syllable{10010011-}{MPYHHS}{\rd = \rx, \ry}
\multiplier{op1sel}{WORD}
\multiplier{op2sel}{HIGH_HALF}
\multiplier{resultSel}{SHR16}
Multiply signed high 16 (s2) x 32 (s1) bits, shift right 16.

%===============================================================================
\section{Memory instructions}
%===============================================================================
\class{MEM}
\datapath{isNOP}{'0'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}
\alu{intResultMux}{ADDER}
\memory{isMemoryInstruction}{'1'}

\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.

Some \rvex{} pipelanes have a memory unit. The memory unit supports byte,
halfword and word operations. Sign or zero extension is part of the byte and
halfword load instructions.

The addressing mode is always register $+$ immediate. Note that attempts to read
misaligned memory locations will fail with a \trap{MISALIGNED_ACCESS} trap.

In the default pipeline configuration, these instructions are pipelined by
two cycles. That is, the result of a memory load instruction is not available
yet in the subsequent instruction. However, the current cache and core guarantee
that a memory write to address $x$ immediately followed by a memory read from
address $x$ returns the newly written value.

%-------------------------------------------------------------------------------
\syllable{000100001}{LDW}{\rd = \ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{gpRegWE}{'1'}
\memory{readEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_WORD}
Loads a 32-bit word from memory.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = *(int*)(\rx + \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000100011}{LDH}{\rd = \ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{gpRegWE}{'1'}
\memory{readEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_HALFWORD}
Loads a 16-bit halfword from memory and sign-extends it.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = *(short*)(\rx + \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000100101}{LDHU}{\rd = \ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{gpRegWE}{'1'}
\memory{readEnable}{'1'}
\memory{unsignedOp}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_HALFWORD}
Loads a 16-bit halfword from memory and zero-extends it.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = *(unsigned short*)(\rx + \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000100111}{LDB}{\rd = \ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{gpRegWE}{'1'}
\memory{readEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_BYTE}
Loads a byte from memory and sign-extends it.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = *(char*)(\rx + \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000101001}{LDBU}{\rd = \ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{gpRegWE}{'1'}
\memory{readEnable}{'1'}
\memory{unsignedOp}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_BYTE}
Loads a byte from memory and zero-extends it.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rd = *(unsigned char*)(\rx + \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000011011}{LDW}{\lr = \ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{linkWE}{'1'}
\memory{readEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_WORD}
Loads a word from memory. The result is written to the link register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\lr = *(int*)(\rx + \ry);
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{001011101}{LDBR}{\ry[\rx]}
\datapath{funcSel}{MEM}
\datapath{allBrRegsWE}{'1'}
\memory{readEnable}{'1'}
\memory{unsignedOp}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_BYTE}
Loads a byte from memory. The result is written to the entire branch register
file at once. This is intended to improve context switching performance
somewhat.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
char tmp = *(char*)(\rx + \ry);
$b0.0 = tmp & 1;
$b0.1 = tmp & 2;
$b0.2 = tmp & 4;
$b0.3 = tmp & 8;
$b0.4 = tmp & 16;
$b0.5 = tmp & 32;
$b0.6 = tmp & 64;
$b0.7 = tmp & 128;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000101011}{STW}{\ry[\rx] = \rd}
\memory{writeEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_WORD}
Stores a 32-bit word into memory.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
*(int*)(\rx + \ry) = \rd;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000101101}{STH}{\ry[\rx] = \rd}
\memory{writeEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_HALFWORD}
Stores a 16-bit halfword into memory.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
*(short*)(\rx + \ry) = \rd;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000101111}{STB}{\ry[\rx] = \rd}
\memory{writeEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_BYTE}
Stores a byte into memory.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
*(char*)(\rx + \ry) = \rd;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{000011101}{STW}{\ry[\rx] = \lr}
\datapath{op3LinkReg}{'1'}
\memory{writeEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_WORD}
Store word in memory, from link register.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
*(int*)(\rx + \ry) = \lr;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{001011111}{STBR}{\ry[\rx]}
\datapath{op3BranchRegs}{'1'}
\memory{writeEnable}{'1'}
\memory{accessSizeBLog2}{ACCESS_SIZE_BYTE}
Store byte in memory, from branch register file.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
char tmp = $b0.0;
tmp |= $b0.1 << 1
tmp |= $b0.2 << 2
tmp |= $b0.3 << 3
tmp |= $b0.4 << 4
tmp |= $b0.5 << 5
tmp |= $b0.6 << 6
tmp |= $b0.7 << 7
*(char*)(\rx + \ry) = tmp
\end{lstlisting}

%===============================================================================
\section{Branch instructions}
%===============================================================================
\class{BR}
\datapath{isNOP}{'0'}
\branch{isBranchInstruction}{'1'}
\branch{branchIfTrue}{'1'}
\branch{branchIfFalse}{'1'}

The highest-indexed pipelane in every \rvex{} system (i.e., the pipelane which
the last syllable in a bundle maps to) contains a branch unit. This unit
supports the flow control operations outlined below.

Branch offsets are signed immediates relative to the next program counter
(\code{PC+1}). Because there are certain alignment requirements to program
counters, the lower two or three bits of the offset are not actually included
in the bitfield. Whether this value is two or three depends on the value of the
\code{BRANCH_OFFS_SHIFT} constant defined in \code{core_intIface_pkg.vhd}; it
is three by default. It must be set to two to support branching to the start of
any bundle when stop bits are fully enabled. This must then also be updated in
the assembler.

Note that branch offsets and the stack adjust immediate are not eligible for 
long immediate instructions.

%-------------------------------------------------------------------------------
\syllable{00100000-}{GOTO}{\of}
Branches to \code{PC+1} + \code{\of} unconditionally.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
PCP1 += \of;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100001-}{IGOTO}{\lr}
\branch{branchToLink}{'1'}
Branches to the address in \code{\lr} unconditionally. This is used for branches 
to code which cannot be reached using the branch offset immediate.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
PCP1 = \lr;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100010-}{CALL}{\lr = \of}
\datapath{funcSel}{PCP1}
\datapath{linkWE}{'1'}
\branch{link}{'1'}
Branches to \code{PC+1} + \code{\of} unconditionally, while storing \code{PC+1} 
in the link register. This is used for function calls.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\lr = PCP1;
PCP1 += \of;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100011-}{ICALL}{\lr = \lr}
\datapath{funcSel}{PCP1}
\datapath{linkWE}{'1'}
\branch{branchToLink}{'1'}
\branch{link}{'1'}
Branches to the address in \code{\lr} unconditionally, while storing \code{PC+1} 
in the link register. In other words, it essentially swaps \code{PC+1} and 
\code{\lr}. This is used for dynamic function calls or calls to functions which 
cannot be reached using the branch offset immediate method.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
unsigned int tmp = \lr;
\lr = PCP1;
PCP1 = tmp;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100100-}{BR}{\bs, \of}
\branch{branchIfFalse}{'0'}
Branches to \code{PC+1} + \code{\of} only if \code{\bs} is true. This 
instruction performs no operation if \code{\bs} is false.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
PCP1 += \bs ? \of : 0;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100101-}{BRF}{\bs, \of}
\branch{branchIfTrue}{'0'}
Branches to \code{PC+1} + \code{\of} only if \code{\bs} is false. This 
instruction performs no operation if \code{\bs} is true.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
PCP1 += \bs ? 0 : \of;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100110-}{RETURN}{\rs = \rs, \sa, \lr}
\datapath{gpRegWE}{'1'}
\datapath{stackOp}{'1'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.
\alu{intResultMux}{ADDER}
\branch{branchToLink}{'1'}
Returns from a function by branching to \code{\lr} unconditionally, while adding 
\code{\sa} to \code{\rs}. \code{\sa} is interpreted as a signed immediate. This
allows final stack pointer adjustment and returning to be done with a single
syllable.

Notice that this instruction is identical to \insn{IGOTO}, except for the fact 
that \insn{IGOTO} does not access \code{\rs}.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rs += \sa;
PCP1 = \lr;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00100111-}{RFI}{\rs = \rs, \sa}
\datapath{gpRegWE}{'1'}
\datapath{stackOp}{'1'}
\alu{op1Mux}{EXTEND32}
\alu{op2Mux}{EXTEND32}
\alu{opBrMux}{FALSE}
\alu{bitwiseOp}{BITW_AND} % Only because legacy decoding did this.
\alu{intResultMux}{ADDER}
\branch{branchIfTrue}{'0'}
\branch{branchIfFalse}{'0'}
\branch{RFI}{'1'}
Returns from a trap service routine by branching to \creg{TP} unconditionally 
and restoring \creg{SCCR} to \creg{CCR}, while adding \code{\sa} to \code{\rs}. 
\code{\sa} is interpreted as a signed immediate. This allows final stack pointer 
adjustment and returning to be done with a single syllable.

\begin{lstlisting}[numbers=none, basicstyle=\ttfamily\footnotesize, language=C++]
\rs += \sa;
CR_CCR = CR_SCCR;
PCP1 = CR_TP;
\end{lstlisting}

%-------------------------------------------------------------------------------
\syllable{00101000-}{STOP}{}
\branch{branchIfTrue}{'0'}
\branch{branchIfFalse}{'0'}
\branch{stop}{'1'}
Causes a \trap{STOP} trap to occur during execution of the next instruction.
The \trap{STOP} trap will cause the B flag in \creg{DCR} to be set, which will
stop execution. Thus, the processor will be stopped after the bundle in which
the \insn{STOP} instruction resides is executed.

%===============================================================================
\section{Long immediate instructions}
%===============================================================================
\datapath{isNOP}{'0'}

%-------------------------------------------------------------------------------
\syllable{1000-----}{LIMMH}{\lt, \li}
\class{LIMMH}
\datapath{isLIMMH}{'1'}
\noasm{}
This special instruction forwards \code{\li} to lane \code{\lt}. Actually, only
the least significant bit of \code{\lt} is used by the processor, to distinguish
between the two possible long immediate forwarding paths. Refer to
Section~\ref{sec:core-ug-isa-syl-classes-limm} for more information.
