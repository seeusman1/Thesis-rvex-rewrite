%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              TRAP DEFINITIONS                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% This file describes the possible trap causes and documentation thereof.
% Since the documentation is intended to be compiled to LaTeX code, it somehow
% made sense to use LaTeX syntax for the definition language. I'm sorry. The
% file is interpreted by python though, not by LaTeX. Don't try to run this
% through LaTeX directly...
%
% The following LaTeX-like commands are interpreted by python to define the
% traps. They must be the only thing on a certain line aside from (maybe)
% comments, otherwise they are interpreted as LaTeX documentation.
% 
%  - \trap{<index>}{<mnemonic>}{<name>}
%    Starts a trap description. <index> is the trap index, which may range from
%    1 to 255. <mnemonic> is the trap identifier, which must be a valid C and
%    VHDL identifier. It is prefixed with "RVEX_TRAP_" in the definition files.
%    <name> is the LaTeX formatted friendly name of the trap, used as the
%    section title.
% 
%  - \trapgen{<python range>}{<start index>}{<mnemonic>}{<name>}
%    Same as \trap, but specifies a list of traps. <python range> is executed as
%    a python expression, expected to generate an iterable of integers. A
%    trap specification is generated for each of these iterations. The index
%    for each trap is computed as <offset> + iter. \n{} expands to the number
%    when used inline in <mnemonic>, <name> and <desc> below. In the
%    documentation it expands to $n$.
% 
%  - \description{<desc>}
%    Defines a trap-specific explanation of the trap, to be used by the debug
%    systems to allow the user to quickly identify the trap. In this
%    description, the following commands may be used inline:
%     - \at{}: expands to " at <trap point>" if the trap point is known, or
%       nothing if the trap point is not known. The trap point is expressed in
%       hexadecimal notation.
%     - \arg{u}: expands to the trap argument in unsigned decimal notation.
%     - \arg{s}: expands to the trap argument in signed decimal notation.
%     - \arg{x}: expands to the trap argument in hexadecimal notation.
% 
%  - \debug{}
%    Marks that this trap is a debug trap. The {} is required!
% 
%  - \interrupt{}
%    Marks that this trap is an interrupt trap. The {} is required!
% 
%  - Anything else:
%    Any unrecognized line is used as a LaTeX documentation for the trap.
%
%===============================================================================

\trap{1}{INVALID_OP}{Invalid opcode trap}
\description{invalid opcode in lane \arg{u}\at{}}

This trap is generated by hardware in the following conditions.

\begin{itemize}

\item An unknown opcode is encountered.

\item The stop bit was set such that the next bundle would start on an address
violating the minimum design-time configured bundle alignment.

\item A branch opcode is encountered in a pipelane which does not have an active
branch unit.

\item A memory opcode is encountered in a pipelane which is not design-time
configured to include a memory unit.

\item A multiplier opcode is encountered in a pipelane which is not design-time
configured to include a multiplier.

\end{itemize}

\noindent The trap argument is set to the lane index which caused the trap.

%===============================================================================

\trap{2}{MISALIGNED_BRANCH}{Misaligned branch trap}
\description{misaligned branch\at{}; target was \arg{x}}

This trap is generated by hardware when a branch to a misaligned address is
requested. The trap argument is set to the branch target.

%===============================================================================

\trap{3}{FETCH_FAULT}{Instruction fetch bus fault trap}
\description{instr. fetch fault\at{}}

This trap is generated by hardware when an instruction fetch resulted in a bus
fault. The trap argument is unused; the program counter can be determined from
the trap point.

%===============================================================================

\trap{4}{MISALIGNED_ACCESS}{Misaligned memory access trap}
\description{misaligned access\at{}; address was \arg{x}}

This trap is generated by hardware when a misaligned memory access was
requested. That is, a 32-bit word access was attempted with an address which is
not divisible by four, or a 16-bit word access was attempted with an odd
address. The trap argument is set to the requested memory address.

%===============================================================================

\trap{5}{DMEM_FAULT}{Memory access bus fault trap}
\description{dmem fault\at{}; address was \arg{x}}

This trap is generated by hardware when a data memory access resulted in a bus
fault. The trap argument is set to the requested memory address.

%===============================================================================

\trap{6}{LIMMH_FAULT}{Long immediate forwarding fault trap}
\description{LIMMH fwd. fault in lane \arg{u}\at{}}

This trap is generated by hardware under the following conditions.

\begin{itemize}

\item A \insn{LIMMH} instruction is trying to forward to a lane for which no
route is available in the core. Note that only the least significant bit of the
target lane is actually checked, though. In this case, the trap argument is the
index of the lane with the \insn{LIMMH} instruction.

\item Two \insn{LIMMH} instructions are trying to forward to the same lane. In
this case, the trap argument is the index of the target lane.

\item A \insn{LIMMH} instruction is attempting to forward to a syllable which
is not using an immediate. In this case, the trap argument is also the index of
the target lane.

\end{itemize}

%===============================================================================

\trap{7}{EXT_INTERRUPT}{External interrupt trap}
\description{external interrupt \arg{s}}
\interrupt{}

This trap is generated by hardware when the external interrupt request line is
asserted while interrupts are enabled by means of the I flag in \creg{CCR}. When
the trap service routine is entered, the state of the external interrupt ID
signal is saved as the trap argument in \creg{TA}, and in the same cycle, the
interrupt is acknowledged. This ensures that the interrupt ID presented to the
trap service routine always matches the acknowledged interrupt.

There is a delay between the core registering that the external interrupt
request line is asserted and generating the trap, and the actual entering of the
trap service routine. This delay is due to the pipeline flush required to do
this, and is in the order of a couple cycles; compared to actually servicing a
trap this delay is negligible. However, if it is ever possible that an active
interrupt is disabled before it is acknowledged by the core, it is possible that
the core will enter the trap service routine due to an interrupt which was
disabled before it could be handled. In this case, the interrupt controller
should provide the core with an otherwise reserved interrupt ID indicating that
there was no interrupt. The trap service routine should handle this special
interrupt ID as no-operation.

%===============================================================================

\trap{8}{STOP}{Stop trap}
\description{stop request\at{}}

This trap is generated by hardware in the instruction immediately following a
\insn{STOP} instruction. It is handled in a completely different way than the
other traps are; the hardware will not jump to \creg{TH} or \creg{PH}. Instead,
the D and B flags in \creg{DCR} are set, thus stopping execution, and the
program counter is set to the trap point. This allows an external debugging or
control system to resume processing after the stop trap by simply writing
a one to the R flag in \creg{DCR}.

%===============================================================================

\trap{9}{CONTEXT_SWITCH}{Software context switch trap}
\description{stop request\at{}}

This trap is generated by hardware when the contents of \creg{RSC} differ from
\creg{CSC} while this trap is enabled using the C flag in \creg{CCR}. The
intended use of this trap is to allow hardware context 0 to control software
context switching on the other hardware contexts. When used in this way, the
trap service routine for this trap should perform the following tasks.

\begin{itemize}
\item If \creg{CSC} $\neq$ -1, save the current context to the memory
identified by \creg{CSC}.
\item Set \creg{CSC} to \creg{RSC}.
\item Restore the software context identified by \creg{RSC} from memory.
\end{itemize}

The way in which \creg{RSC} and \creg{CSC} identify the software context to be
exchanged is up to the operating system code.

%===============================================================================

\trapgen{range(3)}{248}{SOFT_DEBUG_\n{}}{Software debug traps}
\description{soft debug trap \n{}\at{}}
\debug{}

These traps are never generated by hardware, but are intended to be used as soft
breakpoints using the \insn{TRAP} instruction. That is, the debug system may
override one of the syllables in a any bundle where a breakpoint is desired with
a \insn{TRAP} syllable. It may return control to the application by reverting
the \insn{TRAP} syllable back into the original syllable. If it is not the
intention of the debugger to disable the breakpoint, it may single step over
the instruction at the breakpoint, and then replace the \insn{TRAP} syllable.

Unlike the other undefined traps (which may be used as arbitrary software
traps), these traps behave like hardware debug traps. That is, they will be
handled by halting the core if the core is in external debug mode (i.e. the E
flag in \creg{DCR} is set). This means that an external debugger can also use
this system to support an arbitrary number of breakpoints.

Likewise, disabling breakpoints using the B flag in \creg{CCR} will prevent even
the \insn{TRAP} instruction from actually generating a trap.

%===============================================================================

\trap{251}{STEP_COMPLETE}{Single step complete debug trap}
\description{step complete trap\at{}}

This trap is generated by hardware whenever the S flag in \creg{DCR} is set
while debug traps are enabled. This allows the debug system to single-step.
Refer to the documentation of \creg{DCR} for more information.

%===============================================================================

\trapgen{range(4)}{252}{HW_BREAKPOINT_\n{}}{Hardware breakpoint debug traps}
\description{breakpoint \n{}\at{}, address/PC \arg{x}}
\debug{}

These traps are generated by hardware when the corresponding hardware breakpoint
or watchpoint is hit while debug traps are enabled.

%===============================================================================
