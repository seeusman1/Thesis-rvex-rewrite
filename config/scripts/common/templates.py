import textwrap

def generate_footer(lang, infile, outfile, footer):
    """Writes a generated file to outfile, taking the header from infile.
    
    lang can be 'vhdl' or 'c', determining the comment style.
    """
    
    # Get the comment style.
    com_start, com_end = _comment_style(lang)
    
    # Read the input file for the header.
    with open(infile, 'r') as f:
        header = f.readlines()
    
    # Look for the special marker line which seperates the header from the
    # generated footer, and cut the old footer away.
    for i, l in enumerate(header):
        if com_start + ' ##################### GENERATED FROM HERE ONWARDS ##################### ' + com_end in l:
            header = header[:i+3]
            break
    else:
        raise Exception('Could not find start marker in %s.' + infile)
    header = ''.join(header)
    
    # Write the output file.
    with open(outfile, 'w') as f:
        f.write(header)
        f.write(_post_process(footer, com_start, com_end))


def generate(lang, templatefile, outfile, data):
    """Writes a generated file to outfile, using a template file.
    
    Any line which starts with an @ is interpreted to be a template command.
    The remainder of the line is the command name, indexing into the data
    dictionary. The amount of spacing before the @ command is interpreted as
    indentation to be added to the template expansion.
    
    lang can be 'vhdl' or 'c', determining the comment style.
    """
    
    # Read the template file.
    with open(templatefile, 'r') as f:
        template = f.readlines()
    
    # Generate from the template.
    output = []
    for i, line in enumerate(template):
        if line.lstrip().startswith('@'):
            
            # Template command.
            cmd = line.strip()[1:]
            indent = line[0:line.find('@')]
            
            # Make sure we have data for this command.
            if cmd not in data:
                raise Exception('Unknown template expansion command @%s on line %s:%d' %
                                (cmd, templatefile, i+1))
            
            # Apply indentation.
            expansion = [indent + line for line in data[cmd].split('\n')]
            expansion[-1] = expansion[-1].rstrip()
            output.append('\n'.join(expansion))
            
        else:
            output.append(line)
    output = ''.join(output)
    
    # Write the output file.
    generate_raw(lang, outfile, output)


def generate_raw(lang, outfile, text):
    """Writes a generated file to outfile. The contents of the file are
    specified by text. lang can be 'vhdl' or 'c', determining the comment
    style.
    """
    
    # Get the comment style.
    com_start, com_end = _comment_style(lang)
    
    # Write the output file.
    with open(outfile, 'w') as f:
        f.write('%s This file is generated by the scripts in /config. %s\n\n' %
                (com_start, com_end))
        f.write(_post_process(text, com_start, com_end))


def _post_process(text, com_start, com_end):
    text = text.split('\n')
    for i in range(len(text) - 1):
        text[i] = text[i].rstrip()
        if i % 10 == 0:
            text[i] += (' ' * (100 - len(text[i])) +
                (' %s GENERATED %s' % (com_start, com_end)))
    return '\n'.join(text)


def _comment_style(lang):
    com = {
        'vhdl':   ('--', '--'),
        'c':      ('/*', '*/'),
        'tex':    ('%%', '%%'),
        'memmap': ('##', '##')
    }
    lang = lang.lower()
    if lang not in com:
        raise Exception('Unknown language %s.' + lang)
    return com[lang]


def rewrap(s, length, prefix=''):
    lines = s.split('\n')
    pars = []
    
    def last(l):
        return 0 if len(l) == 0 else l[-1]
    
    def get(l, i):
        return last(l) if i >= len(l) else l[i]
    
    par = []
    hang = []
    for line in lines:
        ind = len(line) - len(line.lstrip())
        if line == '' or ind < last(hang) or line.lstrip()[0:1] in ['-', '*']:
            pars.append((''.join(par).rstrip(), hang))
            par = []
            hang = []
        par.append(line.strip() + ' ')
        hang.append(ind)
    pars.append((''.join(par).rstrip(), hang))
    
    lines = []
    for par, hang in pars:
        for ind in hang:
            par = textwrap.wrap(par, length-len(prefix)-ind)
            if len(par) == 0:
                par = ''
                break
            lines.append(ind*' ' + par[0])
            par = '\n'.join(par[1:])
        ind = last(hang)
        par = textwrap.wrap(par, length-len(prefix)-ind)
        lines += [ind*' ' + line for line in par]
        
    lines = [prefix + line for line in lines]
    return '\n'.join(lines) + '\n'

