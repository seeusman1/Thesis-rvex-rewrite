
%===============================================================================

\trap{1}{INVALID_OP}{Invalid opcode trap}
\description{invalid opcode in lane \arg{u}\at{}}

This trap is generated by hardware in the following conditions.

\begin{itemize}

\item An unknown opcode is encountered.

\item The stop bit was set such that the next bundle would start on an address
violating the minimum design-time configured bundle alignment.

\item A branch opcode is encountered in a pipelane that does not have an active
branch unit.

\item A memory opcode is encountered in a pipelane that is not design-time
configured to include a memory unit.

\item A multiplier opcode is encountered in a pipelane that is not design-time
configured to include a multiplier.

\end{itemize}

\noindent The trap argument is set to the lane index that caused the trap.

%===============================================================================

\trap{2}{MISALIGNED_BRANCH}{Misaligned branch trap}
\description{misaligned branch\at{}; target was \arg{x}}

This trap is generated by hardware when a branch to a misaligned address is
requested. The trap argument is set to the branch target.

%===============================================================================

\trap{3}{FETCH_FAULT}{Instruction fetch bus fault trap}
\description{instr. bus fault\at{}}

This trap is generated by hardware when an instruction fetch resulted in a bus
fault. The trap argument is unused; the program counter can be determined from
the trap point.

%===============================================================================

\trap{4}{MISALIGNED_ACCESS}{Misaligned memory access trap}
\description{misaligned access\at{}; address was \arg{x}}

This trap is generated by hardware when a misaligned memory access was
requested. That is, a 32-bit word access was attempted with an address that is
not divisible by four, or a 16-bit word access was attempted with an odd
address. The trap argument is set to the requested memory address.

%===============================================================================

\trap{5}{DMEM_FAULT}{Memory access bus fault trap}
\description{data bus fault\at{}; address was \arg{x}}

This trap is generated by hardware when a data memory access resulted in a bus
fault. The trap argument is set to the requested memory address.

%===============================================================================

\trap{6}{LIMMH_FAULT}{Long immediate forwarding fault trap}
\description{LIMMH fwd. fault in lane \arg{u}\at{}}

This trap is generated by hardware under the following conditions.

\begin{itemize}

\item A \insn{LIMMH} instruction is trying to forward to a lane for which no
route is available in the core. Note that only the least significant bit of the
target lane is actually checked, though. In this case, the trap argument is the
index of the lane with the \insn{LIMMH} instruction.

\item Two \insn{LIMMH} instructions are trying to forward to the same lane. In
this case, the trap argument is the index of the target lane.

\item A \insn{LIMMH} instruction is attempting to forward to a syllable that
is not using an immediate. In this case, the trap argument is also the index of
the target lane.

\end{itemize}

%===============================================================================

\trap{7}{EXT_INTERRUPT}{External interrupt trap}
\description{external interrupt \arg{s}}
\interrupt{}

This trap is generated by hardware when the external interrupt request line is
asserted while interrupts are enabled by means of the I flag in \creg{CCR}. When
the trap service routine is entered, the state of the external interrupt ID
signal is saved as the trap argument in \creg{TA}, and in the same cycle, the
interrupt is acknowledged. This ensures that the interrupt ID presented to the
trap service routine always matches the acknowledged interrupt.

There is a delay between the core registering that the external interrupt
request line is asserted and generating the trap, and the actual entering of the
trap service routine. This delay is due to the pipeline flush required to do
this, and is in the order of a couple cycles; compared to actually servicing a
trap this delay is negligible. However, if it is ever possible that an active
interrupt is disabled before it is acknowledged by the core, it is possible that
the core will enter the trap service routine due to an interrupt that was
disabled before it could be handled. In this case, the interrupt controller
should provide the core with an otherwise reserved interrupt ID indicating that
there was no interrupt. The trap service routine should handle this special
interrupt ID as no-operation.

%===============================================================================

\trap{8}{STOP}{Stop trap}
\description{stop request\at{}}
\debug{} % <- I have no idea anymore why this is! It seems very out of place.
% But this is what the old decoder did... don't fix what ain't broken, I guess.

This trap is generated by hardware in the instruction immediately following a
\insn{STOP} instruction. It is handled in a completely different way than the
other traps are; the hardware will not jump to \creg{TH} or \creg{PH}. Instead,
the D and B flags in \creg{DCR} are set, thus stopping execution, and the
program counter is set to the trap point. This allows an external debugging or
control system to resume processing after the stop trap by simply writing
a one to the R flag in \creg{DCR}.

%===============================================================================

\trap{9}{SOFT_CTXT_SWITCH}{Software context switch trap}
\description{soft ctxt sw. request\at{}}

This trap is generated by hardware when the contents of \creg{RSC} differ from
\creg{CSC} while this trap is enabled using the C flag in \creg{CCR}. The
intended use of this trap is to allow hardware context 0 to control software
context switching on the other hardware contexts. When used in this way, the
trap service routine for this trap should perform the following tasks.

\begin{itemize}
\item If \creg{CSC} $\neq$ -1, save the current context to the memory
identified by \creg{CSC}.
\item Set \creg{CSC} to \creg{RSC}.
\item Restore the software context identified by \creg{RSC} from memory.
\end{itemize}

The way in which \creg{RSC} and \creg{CSC} identify the software context to be
exchanged is up to the operating system code.

%===============================================================================

\trap{16}{DMEM_PAGE_FAULT}{Data access page fault}
\description{data page fault\at{}; address was \arg{x}}

This trap is generated by the MMU when an application tries to access an
unmapped page.

%===============================================================================

\trap{17}{DMEM_KSPACE_VIO}{Kernel space data access violation}
\description{kern. acc. vio.\at{}; address was \arg{x}}

This trap is generated by the MMU when an application tries to access a
kernel-only page while running in user mode.

%===============================================================================

\trap{18}{DMEM_WRITE_VIO}{Write access violation}
\description{write acc. vio.\at{}; address was \arg{x}}

This trap is generated by the MMU when an application tries to write to a
read-only page. Note that kernel threads are allowed to write to read-only
pages if WP in \creg{CMC1} is disabled. This is the default behavior.

%===============================================================================

\trap{19}{DMEM_WRITE_TO_CLEAN}{Write to clean page}
\description{write to clean\at{}; address was \arg{x}}

This trap is generated by the MMU when an application tries to write to a clean
page while the WTC flag in \creg{CMC1} is disabled. This trap may be used to
implement copy-on-write.

%===============================================================================

\trap{24}{IMEM_PAGE_FAULT}{Instruction access page fault}
\description{instr. page fault\at{}}

This trap is generated by the MMU when an application tries to fetch an
instruction from an unmapped page.

%===============================================================================

\trap{25}{IMEM_KSPACE_VIO}{Kernel space instruction access violation}
\description{kern. acc. vio.\at{}}

This trap is generated by the MMU when an application tries to fetch
instructions from a kernel-only page while running in user mode.

%===============================================================================

\trap{26}{IMEM_ACCESS_VIO}{Instruction access violation}
\description{write acc. vio.\at{}}

This trap is generated by the MMU when an application tries to fetch
instructions from a page that is not executable.

%===============================================================================

\trapgen{range(3)}{248}{SOFT_DEBUG_\n{}}{Software debug traps}
\description{soft debug trap \n{}\at{}}
\debug{}

These traps are never generated by hardware, but are intended to be used as soft
breakpoints using the \insn{TRAP} instruction. That is, the debug system may
override one of the syllables in a any bundle where a breakpoint is desired with
a \insn{TRAP} syllable. It may return control to the application by reverting
the \insn{TRAP} syllable back into the original syllable. If it is not the
intention of the debugger to disable the breakpoint, it may single step over
the instruction at the breakpoint, and then replace the \insn{TRAP} syllable.

Unlike the other undefined traps (which may be used as arbitrary software
traps), these traps behave like hardware debug traps. That is, they will be
handled by halting the core if the core is in external debug mode (i.e. the E
flag in \creg{DCR} is set). This means that an external debugger can also use
this system to support an arbitrary number of breakpoints.

Likewise, disabling breakpoints using the B flag in \creg{CCR} will prevent even
the \insn{TRAP} instruction from actually generating a trap.

%===============================================================================

\trap{251}{STEP_COMPLETE}{Single step complete debug trap}
\description{step complete trap\at{}}
\debug{}

This trap is generated by hardware whenever the S flag in \creg{DCR} is set
while debug traps are enabled. This allows the debug system to single-step.
Refer to the documentation of \creg{DCR} for more information.

%===============================================================================

\trapgen{range(4)}{252}{HW_BREAKPOINT_\n{}}{Hardware breakpoint debug traps}
\description{breakpoint \n{}\at{}, address/PC \arg{x}}
\debug{}

These traps are generated by hardware when the corresponding hardware breakpoint
or watchpoint is hit while debug traps are enabled.

%===============================================================================
