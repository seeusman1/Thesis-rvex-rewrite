from __future__ import print_function

from sys import argv
from sys import exit
import registers
import traps

# Parse command line.
if len(argv) != 5:
    print('Usage: python rvex_h.py <gbreg.tex> <cxreg.tex> <traps.tex> <rvex.h>')
    exit(2)
gbreg = argv[1]
cxreg = argv[2]
traps_fname = argv[3]
rvex_h = argv[4]


def print_def(f, key, value):
    if len(key) < 31:
        key = key + ' ' * (31 - len(key))
    f.write('#define ' + key + ' ' + value + '\n')

def print_reg_defs(f, fname):
    regmap, regdoc = registers.parse(fname)
    for ent in regdoc:
        if type(ent) is dict:
            f.write('// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n')
            f.write('// ' + ent['title'] + '\n')
            f.write('// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n')
            continue
        if ent[1] == 'bit':
            print_def(f, ent[0], "%d" % ent[2])
            continue
        if ent[1] == 'mask':
            print_def(f, ent[0], "0x%08X" % ent[2])
            f.write('\n')
            continue
        tcode = 'INT'
        if ent[1][2] == 'U':
            tcode = 'UINT'
        if ent[1][3] == 'B':
            tcode += '8_R'
        elif ent[1][3] == 'H':
            tcode += '16_R'
        else:
            tcode += '32_R'
        if ent[1][0] == 'W':
            tcode += 'W'
        print_def(f, ent[0] + '_ADDR', "(CREG_BASE + 0x%03X)" % ent[2])
        print_def(f, ent[0], "CREG_%s(%s_ADDR)" % (tcode, ent[0]))
        f.write('\n')

def print_trap_defs(f, fname):
    traptable, trapdoc = traps.parse(fname)
    for index, trap in enumerate(traptable):
        if trap is None:
            continue
        print_def(f, 'TRAP_' + trap['mnemonic'], '0x%02X' % index)
    
    f.write('\n// The following definitions are for compatibility with the older, more verbose\n')
    f.write('// definitions.\n')
    for index, trap in enumerate(traptable):
        if trap is None:
            continue
        print_def(f, 'RVEX_TRAP_' + trap['mnemonic'], 'TRAP_' + trap['mnemonic'])

with open(rvex_h, 'w') as f:
    
    # Write the header.
    f.write("""
/* THIS FILE IS GENERATED BY THE SCRIPTS IN THE /config FOLDER! */
/* DO NOT MODIFY IT DIRECTLY! */

#ifndef _RVEX_H_
#define _RVEX_H_

/*****************************************************************************/
/* Core control registers                                                    */
/*****************************************************************************/

// If CREG_BASE is not overruled by a definition passed to the compiler on the
// command line, default to the rvex core default.
#ifndef CREG_BASE
#define CREG_BASE 0xFFFFFC00
#endif

// Stub definitions for any register type.
#define CREG_UINT32_R(addr)     (*(const volatile unsigned int*)(addr))
#define CREG_INT32_R(addr)      (*(const volatile          int*)(addr))
#define CREG_UINT32_RW(addr)    (*(      volatile unsigned int*)(addr))
#define CREG_INT32_RW(addr)     (*(      volatile          int*)(addr))
#define CREG_UINT16_R(addr)     (*(const volatile unsigned short*)(addr))
#define CREG_INT16_R(addr)      (*(const volatile          short*)(addr))
#define CREG_UINT16_RW(addr)    (*(      volatile unsigned short*)(addr))
#define CREG_INT16_RW(addr)     (*(      volatile          short*)(addr))
#define CREG_UINT8_R(addr)      (*(const volatile unsigned char*)(addr))
#define CREG_INT8_R(addr)       (*(const volatile          char*)(addr))
#define CREG_UINT8_RW(addr)     (*(      volatile unsigned char*)(addr))
#define CREG_INT8_RW(addr)      (*(      volatile          char*)(addr))

//-----------------------------------------------------------------------------
// Global (shared) registers. Refer to lib/rvex/core/core_globalRegLogic.vhd
// for up-to-date documentation about the registers.
//-----------------------------------------------------------------------------

""")
    
    print_reg_defs(f, gbreg)
    
    # Write some comment stuff.
    f.write("""//-----------------------------------------------------------------------------
// Context-specific registers. Refer to lib/rvex/core/core_contextRegLogic.vhd
// for up-to-date documentation about the registers.
//-----------------------------------------------------------------------------

""")
    
    print_reg_defs(f, cxreg)

    f.write("""//-----------------------------------------------------------------------------
// Backwards-compatibility/convenience definitions
//-----------------------------------------------------------------------------

// This section can be changed in config/interpreter/rvex_h.py if necessary.

// Interrupt enable/disable bits in (S)CCR.
#define CR_CCR_IEN                      (1 << CR_CCR_I_BIT)
#define CR_CCR_IEN_C                    (2 << CR_CCR_I_BIT)

// Ready-for-trap enable/disable bits in (S)CCR.
#define CR_CCR_RFT                      (1 << CR_CCR_R_BIT)
#define CR_CCR_RFT_C                    (2 << CR_CCR_R_BIT)

// Breakpoint enable/disable bits in (S)CCR (for self-hosted debug mode).
#define CR_CCR_BPE                      (1 << CR_CCR_B_BIT)
#define CR_CCR_BPE_C                    (2 << CR_CCR_B_BIT)

// Context-switch enable/disable bits in (S)CCR
#define CR_CCR_CSW                      (1 << CR_CCR_C_BIT)
#define CR_CCR_CSW_C                    (2 << CR_CCR_C_BIT)

// Kernel mode enable/disable bits in (S)CCR
#define CR_CCR_KME                      (1 << CR_CCR_K_BIT)
#define CR_CCR_KME_C                    (2 << CR_CCR_K_BIT)

// Shorthand notation for enabling/disabling interrupts/traps (in CCR).
#define ENABLE_IRQ                      (CR_CCR = CR_CCR_IEN)
#define DISABLE_IRQ                     (CR_CCR = CR_CCR_IEN_C)
#define ENABLE_TRAPS                    (CR_CCR = CR_CCR_RFT)
#define DISABLE_TRAPS                   (CR_CCR = CR_CCR_RFT_C)
#define ENABLE_CTXT_SWITCH              (CR_CCR = CR_CCR_CSW)
#define DISABLE_CTXT_SWITCH             (CR_CCR = CR_CCR_CSW_C)

// Deprecated definitions for the first scratchpad register.
#define CR_SCRP_ADDR                    CR_SCRP1_ADDR
#define CR_SCRP                         CR_SCRP1

/*****************************************************************************/
/* Trap causes                                                               */
/*****************************************************************************/

""")
    
    print_trap_defs(f, traps_fname)
    
    f.write("""
#endif
""")
