
--=============================================================================
-- Installation
--=============================================================================

Note: this assumes that you downloaded an rvex release. If you're new to the
rvex project and got this from the (private) git repositories instead, check
out README.INTERNAL.

You will need at least the following things (this list is probably not
complete):

 - A linux environment. Cygwin may work kind of, but you'll probably need to
   handle the symlinks in the repo properly somehow.
 - Xilinx ISE. Version 14.7 is STRONGLY RECOMMENDED; older versions are known
   to synthesize the rvex incorrectly. Vivado (2015.4) is used in the Virtex-7
   based platforms.
 - Modelsim. The system is tested using version SE 10.2a; older versions are
   known to crash when simulating the core.
 - GNU make
 - gcc
 - python 3.x

The release comes with pre-built tools binutils-gdb and gcc 
(in rvex-elf32-32bit), Open64, HP VEX, and a simulator. 
Sources of the are available from TUDelft

In general, as long as you have the dependencies installed, you shouldn't need
to do anything else to get the system to work. If things are missing or are not
yet compiled, the makefiles should take care of it as soon as you do something.

--=============================================================================
-- Basic platform usage
--=============================================================================

There are currently four maintained platforms for the rvex. Their purpose and
a small tutorial for each is listed below. The tutorial assumes you're working
from this directory for simplicity (for those who don't know much about Linux).
Those people who do know about Linux should probably not do more than skim over
this and just run "make" from the platform directory to get more detailed but
less guided usage information.

-------------------------------------------------------------------------------
-- Unit test suite: :/platform/core-tests/
-------------------------------------------------------------------------------

This is a modelsim-only platform which runs unit tests on the rvex core. You
can run the test suite in command line mode as follows:

(cd platform/core-tests && make -j conformance)

You will need to have sourced your modelsim environment setup script before
doing so. Should a test case fail, you'll probably want to run modelsim in GUI
mode to see why; to do this, start the simulation as follows instead:
   
(cd platform/core-tests/<configuration> && make vsim)

You will need to replace <configuration> with the core configuration which you
want to test. The following command lists the valid configurations:

(cd platform/core-tests && make list-configs)

-------------------------------------------------------------------------------
-- Cache/specific program testbench: :/platform/cache-test/
-------------------------------------------------------------------------------
   
This is a simulation-only platform which runs the specified program (from
examples) on a platform with the default rvex processor and reconfigurable
cache. Its primary purpose is to test the cache in a controlled environment,
but it also works nicely to test rvex programs in a full core simulation.

(cd platform/cache-test && make vsim-<prog>)

You will need to have sourced your modelsim environment setup script before
doing so. The following command lists which program names are valid (among
other things):

(cd platform/cache-test && make)

-------------------------------------------------------------------------------
-- Standalone core design: :/platform/ml605-standalone
-------------------------------------------------------------------------------

This is a basic platform for the ML605 FPGA board containing only an rvex
core, the rvex debug support unit (UART) and some basic clock generation.
Here's a little tutorial to get you started, even if you're new to Linux.
(Those who do know how things work can figure out what the commands do for
themselves.)

To simulate the design, source your local Modelsim AND Xilinx ISE
environment setup scripts and run:

(cd platform/ml605-standalone && make vsim-ucbqsort-fast)

Initialization may take up to a couple minutes due to the size of the loaded
program. You can change "ucbqsort-fast" into whatever program you want to, or
to "none" if you don't need a program loaded into the memory. The following
command lists which program names are valid (among other things):

(cd platform/ml605-standalone && make)

You have two options to synthesize the design. You can either do it manually
in the Xilinx ISE GUI, or from the command line. To launch the GUI, make sure
you have sourced the Xilinx ISE startup script and run:

(cd platform/ml605-standalone && make ise-none)

Use the usual Xilinx ISE GUI design flow to synthesize the design and
program the board.

To synthesize from the command line, use the following command.

(cd platform/ml605-standalone && make synth-none NAME=<name>)

Substitute <name> with something arbitrary but unique. <name> will be used to
generate a build directory, so you can run the synthesis tools multiple times
in parallel. The VHDL source files are copied into the build directory
immediately after the command is given, so you can safely modify the sources
without messing up an ongoing synthesis run. By the way, if you don't want to
have to get creative with names, you can ommit the whole NAME=<name> part, in
which case the current timestamp will be used instead.

To program a synthesized design to the ML605 development board, run the
following:

(cd platform/ml605-standalone && make prog-<name>)

You will need to substitute <name> with the same thing you specified when
synthesizing. Alternatively, if you want to program the FPGA manually, the bit
file is stored in platform/ml605-standalone/synth-<name>/routed.bit.

Once the FPGA has been configured, you can load a program onto the board using
the debug support unit. To do that, you first need to start the rvsrv daemon,
which provides a bridge between the hardware and any scripted programs which
may want to connect with it. You can start the server as follows:

(cd platform/ml605-standalone && make server)

If rvsrv won't start because it can't open the serial port, which it
probably will, you'll need to change the configuration file. The file you're
looking for is tools/debug-interface/configuration.cfg. You can edit this
with any text editor. You need to change the SERIAL_PORT = line to the
serial port which rvsrv is to use. This will probably need to be ttyUSB0
since the ML605 board contains an USB to serial converter.

Once started, rvsrv will run in the background. To stop it, you can run the
following command (but you won't want to do this just yet):

(cd platform/ml605-standalone && make stop)

You should also set up the debugging environment at this point. Run the
following commands:

(cd platform/ml605-standalone && make debug)
source platform/ml605-standalone/debug

You can now run the rvd command to give commands to the board. Running rvd
without any parameters should tell you how to use it.

You can now upload the UART test program to the board to see if it works
using the following command:

(cd platform/ml605-standalone && make upload-uart)

The UART program will echo anything sent to it back in all-caps. To open a
UART terminal to communicate with the board, run:

(cd platform/ml605-standalone && make monitor)

You can press ctrl+C to exit the monitor program. Typing anything and
pressing enter will send it to the board; anything received from the board
will be shown in the terminal.

The platform makefile and rvd support a lot more than what's specified here.
For more information, run:

(cd platform/ml605-standalone && make)

-------------------------------------------------------------------------------
-- GRLIB platform: :/platform/ml605-grlib
-------------------------------------------------------------------------------

This platform contains the rvex with instruction and data cache within a grlib
environment. It is based on the leon3mp example project from grlib. A lot of
the commands for this platform are virtually identical to those in the
ml605-standalone platform (just substitute standalone with grlib), so I'm only
going to note the differences.

First of all, simulation. The command is the same. However, if you're going to
restart simulation after only changing VHDL files, you'll probably want to use
"resim" instead of "vsim" to save a bit of time. Also, the startup script is
set up such that it will automatically run the DDR3 controller initialization
procedure and save a checkpoint before giving you control. When you would
normally restart simulation (for example because you forgot to add some signal)
you should in stead run the following TCL command in modelsim:

restore modelsim/cpt

This will restore the simulation state to just after the DDR controller
initialization.

Secondly, synthesis. This can only be done from the command line, as follows:

(cd platform/ml605-grlib && make synth)

You can't run multiple synthesis runs at the same time like in the standalone
platform. If you want to do that, you'll probably need to make copies of the
entire tree.

There is no special command to program the FPGA at this time. Instead, run

impact

and load the bit file from platform/ml605-grlib/work/leon3mp.bit manually.

Finally, the program uploading and debugging commands are similar to the
standalone platform.

--=============================================================================
-- Hacking the core
--=============================================================================

The rvex core files are located in :/lib/rvex/core. The code should be self-
documenting; there's a lot of comments in there. Start with core.vhd.
In the config directory are sources that are used to generate VHDL code and 
documentation. These can be used to do a large amount of design-time
configuration (that can not be done using generics). 

The manual is located in :/doc/reference-manual.pdf

If you change things, please try to keep at least the documentation in the
VHDL comments up-to-date. If you make permanent changes to the debugging
interface (i.e. the control register map), be sure to update the rvd memory map
definitions in :/tools/debug-interface/src/default-memory.map. The next time
you run any make command to do with rvd, you will be queried to commit the new 
you run any make currently active memory map.

-------------------------------------------------------------------------------
-- Adding/modifying control registers
-------------------------------------------------------------------------------

The steps below explain how to properly add control registers to the rvex core.
Modifying/removing registers follows the same steps, pretty much.

 1. Add the mnemonics for the new registers to
    lib/rvex/core/core_ctrlRegs_pkg.vhd. While you're there, you might want to
    look over the subprograms in that file which can be used to easily make
    certain types of registers.
    
 2. Define the logic for your new registers in:
     - lib/rvex/core/core_contextRegLogic.vhd for context-specific registers
     - lib/rvex/core/core_globalRegLogic.vhd for context-specific registers

 3. Register the new mnemonics in the following files:
     - platform/core_tests/design/core_tb.vhd (bottom of the file)
     - examples/src/rvex.h
     - tools/debug-interface/src/default-memory.map

--=============================================================================
-- Adding programs
--=============================================================================

Adding a basic program to be run on the rvex is easy. Simply add a c source
file in :/examples/src/ and add the program name to the EXECUTABLES variable in
:/examples/Makefile. All the platform makefiles eventually use that makefile
for compilation, so your program should run on all platforms by just doing
those things. You can test your program with xstsim using just the makefile in
:/examples, or you can run it in a full hardware simulation with one of the
platforms. The cache-test platform is the best one for the job.


